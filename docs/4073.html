<html>
<head>
<title>Mocking TS method overloads with Jest</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Jest嘲弄TS方法重载</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/mocking-ts-method-overloads-with-jest-e9c3d3f1ce0c?source=collection_archive---------4-----------------------#2020-11-14">https://javascript.plainenglish.io/mocking-ts-method-overloads-with-jest-e9c3d3f1ce0c?source=collection_archive---------4-----------------------#2020-11-14</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8ddc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">用Jest模仿重载的TS方法本身并不难，但是您必须知道如何去做。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/bb00300f0859e1f8b5edfecd7a650557.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*voq03FOFeXtJn7M6JzAIyw.jpeg"/></div></div><figcaption class="kx ky gj gh gi kz la bd b be z dk">Picture courtesy of <a class="ae lb" href="https://unsplash.com/@ammar_sab3" rel="noopener ugc nofollow" target="_blank">Ammar Sabaa</a></figcaption></figure><p id="572c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本文中，我将解释这个“问题”以及如何解决它。</p><h1 id="9b96" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">“问题”</h1><p id="9bf1" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">对于习惯于面向对象编程的开发人员来说，方法重载是一个非常熟悉的概念(顺便说一下，这是我将在我即将出版的书<a class="ae lb" href="http://dev-concepts.dev/" rel="noopener ugc nofollow" target="_blank">中解释的众多概念之一)。</a></p><p id="471c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用方法重载，您可以定义多个名称相同但签名不同的方法/函数。重载可以很好地使用，因为具体的实现是根据您传递的参数来调用的。</p><p id="935c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当然，方法重载是一个有用的概念，它本身根本不是一个问题。虽然在测试时，用TypeScript模拟重载方法可能有点困难。</p><p id="b63d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题是当我们要求TypeScript给我们一个重载方法的参数时，我们得到的是最后一个重载的参数。因此，我们可能会遇到编译器抱怨模拟实现不接受正确的参数或不返回预期类型的问题。是<code class="fe mf mg mh mi b">ReturnType</code>和条件类型的限制之一。</p><p id="6b76" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一开始这可能会有点混乱。</p><p id="28d9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">问题当然是:如何告诉TypeScript我们想要模仿这个或那个版本的函数？</p><h1 id="7bfc" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">一个例子</h1><p id="8952" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这里有一个例子来说明这个问题。</p><p id="d287" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我当前的项目中，我使用<a class="ae lb" href="https://www.npmjs.com/package/nano" rel="noopener ugc nofollow" target="_blank"> nano </a>库连接到一个<a class="ae lb" href="https://couchdb.apache.org/" rel="noopener ugc nofollow" target="_blank"> CouchDB </a>数据库。特别是，我在所谓的存储库类中使用nano，它负责与数据库进行交互。</p><p id="d2c9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在为一个新的“批量删除”操作编写单元测试时，我们需要确保批量删除正在做它需要做的事情。因为我们正在讨论单元测试，所以我们确实想要模拟nano数据库连接以及批量操作数据库调用。</p><p id="7465" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">使用nano，当我们建立一个数据库连接时，我们得到一个类型为<code class="fe mf mg mh mi b">DocumentScope&lt;D&gt;</code>的对象。在许多其他功能中，该接口包括一个<code class="fe mf mg mh mi b">bulk</code>功能，可用于执行批量操作。</p><p id="3d6e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">该功能实际上有两种变体:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="8329" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，根据它被调用的方式，我们得到一个<code class="fe mf mg mh mi b">Promise&lt;DocumentBulkResponse[]&gt;</code>或者一个<code class="fe mf mg mh mi b">Promise&lt;DocumentInsertResponse[]&gt;;</code>。</p><p id="eda5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">第二个变体对应于批量插入操作，而第一个(我们需要模拟的那个)对应于批量删除。</p><p id="9534" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通常，当我们使用Jest模仿函数时，我们是这样做的:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9109" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这对于只有一个变体的情况很好，但是在我们的例子中，我们需要能够告诉TypeScript我们在模仿哪个变体；否则，我们会得到一个编译错误，一开始可能有点误导:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9837" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在你知道了函数的两个变量，你就能理解这个错误来自哪里；TypeScript希望我们尊重第二个变量的签名(以及返回类型)。</p><p id="3fe9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">咩！</p><p id="1d60" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么我们如何解决这个问题呢？</p><h1 id="dcc5" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">解决方案</h1><p id="8511" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">这个测试问题的解决方案实际上非常简单:</p><ul class=""><li id="83ba" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated">定义一个自定义类型，匹配您想要模仿的变量的签名</li><li id="ef8e" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">在创建mock之前，将类型转换为使用您刚刚定义的类型</li></ul><p id="7a97" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里有一个例子:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="9a86" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有了这些，TypeScript不再抱怨了。当然，这只是一种变通方法，有时可能会导致问题(例如，如果被模仿的函数的签名发生了变化)，但这是一种推进测试的有用技巧。</p><p id="9dee" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">参考资料:</p><ul class=""><li id="a5ae" class="ml mm iq jp b jq jr ju jv jy mn kc mo kg mp kk mq mr ms mt bi translated"><a class="ae lb" href="https://stackoverflow.com/questions/61752367/how-to-mock-overload-method-in-jest" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/61752367/how-to-mock-overload-method-in-jest</a></li><li id="c5ba" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated">https://github.com/marchaos/jest-mock-extended/issues/20<a class="ae lb" href="https://github.com/marchaos/jest-mock-extended/issues/20" rel="noopener ugc nofollow" target="_blank"/></li><li id="b894" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated"><a class="ae lb" href="https://stackoverflow.com/questions/52760509/typescript-returntype-of-overloaded-function/52761156#52761156" rel="noopener ugc nofollow" target="_blank">https://stack overflow . com/questions/52760509/typescript-return-type-of-overloaded-function/52761156 # 52761156</a></li><li id="d674" class="ml mm iq jp b jq mu ju mv jy mw kc mx kg my kk mq mr ms mt bi translated"><a class="ae lb" href="https://github.com/DefinitelyTyped/DefinitelyTyped/issues/34889" rel="noopener ugc nofollow" target="_blank">https://github . com/definitely typed/definitely typed/issues/34889</a></li></ul><h1 id="f5fb" class="lc ld iq bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">结论</h1><p id="a5d9" class="pw-post-body-paragraph jn jo iq jp b jq ma js jt ju mb jw jx jy mc ka kb kc md ke kf kg me ki kj kk ij bi translated">在本文中，我解释了如何在使用Jest和TypeScript模仿函数时处理重载。</p><p id="df10" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">还有其他方法可以解决这个问题，但是这种方法非常简单(尽管很“弱”)。TS团队的官方建议是将更一般的重载放在最后定义，但有些库并不总是遵守这一点(我猜主要是因为它并不那么出名)。</p><p id="5d63" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">今天到此为止！</p><p id="32f5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">PS:如果你想了解大量关于软件/Web开发的其他很酷的事情，那么你可以预订<a class="ae lb" href="https://dev-concepts.dev/" rel="noopener ugc nofollow" target="_blank">我即将出版的书</a>，拿一本<a class="ae lb" href="https://www.amazon.com/gp/product/B081FB89BL" rel="noopener ugc nofollow" target="_blank">我的打字本</a>，和/或订阅<a class="ae lb" href="https://mailchi.mp/fb661753d54a/developassion-newsletter" rel="noopener ugc nofollow" target="_blank">我的简讯</a>！</p></div></div>    
</body>
</html>