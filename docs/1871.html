<html>
<head>
<title>Angular Regime Series: A Guide to Change Detection Strategy</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">角度范围系列:变化检测策略指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/angular-regime-series-a-guide-to-change-detection-strategy-2a8a4da46c5c?source=collection_archive---------4-----------------------#2020-04-30">https://javascript.plainenglish.io/angular-regime-series-a-guide-to-change-detection-strategy-2a8a4da46c5c?source=collection_archive---------4-----------------------#2020-04-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="2a8e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated"><em class="kc">开发变革可持续应用</em></h2></div><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi kd"><img src="../Images/65c27ccbdb6d224ac0f00540aaa200f5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rbHbk1cUt8FXGyTDjw-6Ww.jpeg"/></div></div></figure><p id="ec80" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">Angular是最棒的框架之一。它提供您开箱所需的任何东西，绝对是一切。Angular的变化检测策略是一个非常突出的策略，可以使应用程序流畅快速，但不幸的是，Angular的官方网站上没有任何指南。</p><p id="3acf" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在这篇文章中，我们将深入了解Angular在发生变化时的行为。</p><h1 id="5682" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">介绍</h1><p id="aeda" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">作为一名Angular开发人员，您可能经常只在想要优化您的应用程序性能时才考虑变更检测策略，这里有一个令人震惊的消息，如果<strong class="kr io"> <em class="mi">变更检测策略</em> </strong>使用不当，您可能会降低您的应用程序的性能。</p><p id="0d0e" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><em class="mi">那么什么是</em> <strong class="kr io"> <em class="mi"> </em> </strong> <em class="mi">变化检测策略以及为什么需要它</em>？让我们用一个真实的例子来解释这个问题。我发现真实世界的例子很有启发性，更容易抓住主题，而不是用技术定义淹没读者，并使之更加复杂。</p><h1 id="f59c" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">真实世界的例子</h1><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi mj"><img src="../Images/7cf8bd825aeae5113a49bbecb1c5d79d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*59TyEsDJ7kIGlGhetyfG_A.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Students cheating example</figcaption></figure><p id="0f11" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">所以假设学校有考试。老师在学生考试时观察他们。现在，如果老师不知道任何更好的东西，他会关注班上所有的学生，以抓住他们中的任何一个作弊，所以检查每个学生以识别作弊的学生是一项很大的工作。</p><p id="6c2c" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">但是假设老师知道的更多，他知道学生经常作弊。所以在这种情况下，他会一直盯着他们，万一他们试图作弊，老师会立即抓住他们。</p><p id="9876" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">所以作弊是变化，学生是组成部分。老师是棱角分明的，他必须检查每个学生/组件，以找到作弊(改变)的人。</p><p id="d3fb" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">简而言之，通过Angular中的变化检测，我们可以决定哪些组件需要完全检查，哪些组件只需要针对特定事件进行检查。<strong class="kr io"> <em class="mi">变化检测</em> </strong>是关于每当我们的数据更新时更新视图(DOM)。因此，如果发生变化，Angular会完全检查所有组件，但我们可以将其限制为对某些组件进行特定检查。</p><p id="9d12" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这听起来很有趣，但是Angular是如何做到的呢？井幕后Angular使用被称为<strong class="kr io"> <em class="mi">的东西Zone </em> </strong>来处理变化检测。</p><h1 id="c516" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">Zone.js是什么鬼？</h1><p id="ed50" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">作为一个有棱角的人，你可能偶尔听说过这个区域。</p><blockquote class="mo mp mq"><p id="a572" class="kp kq mi kr b ks kt jo ku kv kw jr kx mr kz la lb ms ld le lf mt lh li lj lk ig bi translated">区域是跨异步任务持续存在的执行上下文。你可以把它想象成JavaScript虚拟机的线程本地存储器。</p></blockquote><p id="ec70" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">因此，简而言之，Zone.js处理Angular应用程序中发生的变化检测的所有细节。Angular使用Zone来决定UI的哪个部分将被更新。这省去了我们自己做决定的麻烦，这可能会很麻烦。</p><p id="fbe9" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">还有一个选项是在引导过程中禁用Zone，这样您就可以负责完成所有困难的工作，或者您可能希望在zone之外执行一些任务，在这种情况下，您可以使用NgZone，它允许您在zone之外编写任务。</p><p id="f9cb" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们一会儿就会看到这一点，但首先让我们看看它如何改变检测工作。</p><h1 id="1312" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">变更检测的工作原理</h1><p id="b863" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">角度变化检测有两种策略。</p><ul class=""><li id="d698" class="mv mw in kr b ks kt kv kw ky mx lc my lg mz lk na nb nc nd bi translated">默认策略</li><li id="f309" class="mv mw in kr b ks ne kv nf ky ng lc nh lg ni lk na nb nc nd bi translated">OnPush策略</li></ul><p id="6f93" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">让我们逐一看看这些策略。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi nj"><img src="../Images/c9162aec3276958f61e4c90d28f1f03a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rqwTx3GP3PVPt3b0MmH-yg.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">Change Detection Tree</figcaption></figure><h1 id="8a86" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">变化检测树</h1><p id="9ebc" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">在引导过程(应用程序启动)中，每个组件的变更检测器都被创建并与之关联。这些变化检测器(CD)以父子树的形式组合在一起，因此被称为<em class="mi">变化检测树</em>。在后台，Angular将<code class="fe nk nl nm nn b">onPush</code>(也称为检查一次)设置为0，将Default(也称为总是检查)设置为1。</p><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi no"><img src="../Images/a3ca0560db3717f0cdcd2a5c1b34d0a5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OaLNCeeui6TVeJUgb5-zSg.png"/></div></div></figure><h1 id="3a25" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">默认变化检测策略</h1><figure class="ke kf kg kh gt ki gh gi paragraph-image"><div role="button" tabindex="0" class="kj kk di kl bf km"><div class="gh gi np"><img src="../Images/b7cda9919196910159939d0c51ffb17a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_iowMiLs8DlxkHPTKlfOiQ.jpeg"/></div></div><figcaption class="mk ml gj gh gi mm mn bd b be z dk">change detection strategy — Default</figcaption></figure><p id="49c4" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">默认情况下，Angular使用默认策略<code class="fe nk nl nm nn b">ChangeDetectionStrategy.Default</code>来处理变更，并在DOM中同步它们。默认的策略是，每当一个事件被触发时(如XHR、承诺、用户事件)，从上到下检查整个组件树(变更检测树)。它不知道更改发生在哪里，因此它将遍历整个树，如果有新的值，它将更新该组件的视图。这也被称为<strong class="kr io"> <em class="mi">脏检</em> </strong>。现在，这是一种非常低效的检查方式，因为它运行了许多不必要的更改检测周期，因此会导致性能问题。</p><p id="4b70" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">Angular通过使用组件的关联检测器将模板使用的属性的当前值与以前值进行比较来执行更改检测。如果值被更改，<code class="fe nk nl nm nn b">isChanged</code>场景背后的属性被设置为true，这反过来更新了DOM。所以在幕后没有发生深层的对象检查。所有角度都与等于运算符进行比较。</p><h1 id="148d" class="ll lm in bd ln lo lp lq lr ls lt lu lv jt lw ju lx jw ly jx lz jz ma ka mb mc bi translated">OnPush变化检测策略</h1><p id="5875" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">接下来是onPush策略，可以通过在<code class="fe nk nl nm nn b">@Component</code>装饰器中向<code class="fe nk nl nm nn b">changeDetection</code>属性提供<code class="fe nk nl nm nn b">ChangeDetectionStrategy.OnPush</code>来使用。</p><pre class="ke kf kg kh gt nq nn nr ns aw nt bi"><span id="829a" class="nu lm in nn b gy nv nw l nx ny">@Component({<br/>  selector: 'ml-department-form',<br/>  templateUrl: './department-form.component.html',<br/>  styleUrls: ['./department-form.component.scss'],<br/>  <strong class="nn io">changeDetection: </strong><strong class="nn io">ChangeDetectionStrategy.OnPush</strong><br/>})</span></pre><p id="0981" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我喜欢称这种策略为金矿策略，因为它允许检测器跳过对组件及其子组件的不必要的检查，也称为<strong class="kr io"> <em class="mi">脏检查</em> </strong>。有了这个策略，Angular知道在什么时候更新组件:</p><ul class=""><li id="2535" class="mv mw in kr b ks kt kv kw ky mx lc my lg mz lk na nb nc nd bi translated">组件和子组件触发一个事件</li><li id="15cd" class="mv mw in kr b ks ne kv nf ky ng lc nh lg ni lk na nb nc nd bi translated">组件输入已更改</li><li id="e883" class="mv mw in kr b ks ne kv nf ky ng lc nh lg ni lk na nb nc nd bi translated">链接到模板的可观察对象发出一个新值</li><li id="79ff" class="mv mw in kr b ks ne kv nf ky ng lc nh lg ni lk na nb nc nd bi translated">手动调用更改检测</li></ul><p id="d3a7" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">让我们检查一下。</p><h2 id="dd55" class="nu lm in bd ln nz oa dn lr ob oc dp lv ky od oe lx lc of og lz lg oh oi mb oj bi translated">组件和子组件触发一个事件</h2><p id="9ea2" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">事件是触发变更检测的另一种方式。每当调用输入事件时，总是会触发更改检测。</p><h2 id="273c" class="nu lm in bd ln nz oa dn lr ob oc dp lv ky od oe lx lc of og lz lg oh oi mb oj bi translated">组件输入已更改</h2><p id="6df4" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">每当默认策略中出现任何类型的变化时，Angular都会触发变化检测，但对于<code class="fe nk nl nm nn b">onPush</code>策略，Angular非常挑剔！只有当<code class="fe nk nl nm nn b">@Input</code>传入新的参考时，才会触发变化检测，这将使<code class="fe nk nl nm nn b">@Input</code>发出一个新值。</p><p id="9878" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">对于两种策略，所有的原始类型都在任何变化时触发变化检测，但是当我们使用对象或数组时，我们通常通过其属性更新对象，如果选择了<code class="fe nk nl nm nn b">onPush</code>策略，则不会触发变化检测。</p><p id="716f" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">为了解决这个问题，我们必须创建一个不可变的对象。不可变对象的值不会改变，但是我们通过给它分配一个新的对象来修改它。因为这种方法的不变性是完整的，所以变更检测将被成功触发。</p><p id="d7b4" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">当使用<code class="fe nk nl nm nn b">onPush</code>策略时，你有可能会遇到很多错误。这可以通过在整个应用程序中使用不可变对象来防止。因此，如果你忘了修改一个对象，它将使你避免意外的错误。</p><p id="f5d9" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">在上面的例子中，我们使用了两个数组。<code class="fe nk nl nm nn b">list</code>将包含一些随机数据和另一个带有更新数据的数组。底部有两个按钮，按对象和按值。当您单击“按值”按钮时，如果您观察click事件方法，我们只是通过对象的属性来修改对象，因此视图上没有反映任何更改。现在，单击“按对象”按钮，这将触发一个方法，在该方法中，我们通过给底层对象一个新对象的引用来修改它，从而保持不变性。因此，我们可以看到视图中反映的变化。</p><h2 id="ed5a" class="nu lm in bd ln nz oa dn lr ob oc dp lv ky od oe lx lc of og lz lg oh oi mb oj bi translated">链接到模板的可观察对象发出一个新值</h2><p id="f8b0" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">当我们使用observables时，有几种方法可以用来访问数据，通常在模板中使用异步管道。<strong class="kr io"> <em class="mi">异步管道</em> </strong>订阅可观察对象并发出最新值，因此从响应发出的更改直接从可观察对象显示。</p><p id="f6ca" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">其工作方式是<strong class="kr io"> <em class="mi">异步管道</em> </strong>在发生变化时标记组件。这有助于Angular决定是否执行变化检测。</p><h2 id="bd04" class="nu lm in bd ln nz oa dn lr ob oc dp lv ky od oe lx lc of og lz lg oh oi mb oj bi translated">手动调用更改检测</h2><p id="e421" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">要手动触发变更检测，我们必须依赖基类<strong class="kr io"><em class="mi">changededetorref</em></strong>。这提供了变化检测功能。变更检测树收集了所有要检查变更的视图。使用这些方法在树中添加和删除视图，启动变化检测，并显式地将视图标记为<em class="mi"> dirty </em>，这意味着它们已经发生了变化，需要重新呈现。</p><pre class="ke kf kg kh gt nq nn nr ns aw nt bi"><span id="c695" class="nu lm in nn b gy nv nw l nx ny">abstract <em class="mi">class</em> <strong class="nn io">ChangeDetectorRef</strong> {</span><span id="27ec" class="nu lm in nn b gy ok nw l nx ny">abstract markForCheck(): <em class="mi">void<br/> </em>abstract detach(): <em class="mi">void<br/> </em>abstract detectChanges(): <em class="mi">void<br/> </em>abstract checkNoChanges(): <em class="mi">void<br/> </em>abstract reattach(): <em class="mi">void</em></span><span id="cd21" class="nu lm in nn b gy ok nw l nx ny">}</span></pre><p id="2766" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">我们可以使用这三种方法来手动触发变更检测。</p><ul class=""><li id="8479" class="mv mw in kr b ks kt kv kw ky mx lc my lg mz lk na nb nc nd bi translated"><strong class="kr io"> detectChanges(): </strong>如果你的模型(你的类)内的任何东西已经改变，但是它没有反映视图，你可能需要通知Angular去检测那些改变(检测局部改变)并且更新视图。</li></ul><p id="00b3" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated"><strong class="kr io">用例可能是:</strong></p><p id="70f3" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">1-变化检测器与视图分离。</p><p id="d42c" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">2-更新已经发生，但它不在角度区域内，因此，角度不知道它。</p><p id="0e20" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">3-当第三方功能更新了您的模型，并且您想在此之后更新视图时。</p></div><div class="ab cl ol om hr on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ig ih ii ij ik"><ul class=""><li id="22a9" class="mv mw in kr b ks kt kv kw ky mx lc my lg mz lk na nb nc nd bi translated"><strong class="kr io">markForCheck():</strong>It<strong class="kr io"/>通常在<code class="fe nk nl nm nn b">onPush</code>选择策略时使用。假设您正在使用<code class="fe nk nl nm nn b">onPush</code>策略和<code class="fe nk nl nm nn b">@Input</code>装饰事件触发器。</li></ul><pre class="ke kf kg kh gt nq nn nr ns aw nt bi"><span id="9e01" class="nu lm in nn b gy nv nw l nx ny">var obj = {<br/>     name:'ahmed'<br/>   };</span></pre><p id="6ae7" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">然后你像这样更新它:</p><pre class="ke kf kg kh gt nq nn nr ns aw nt bi"><span id="38f3" class="nu lm in nn b gy nv nw l nx ny">obj.name = "a new name";</span></pre><p id="1c2b" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">输入值是一个对象，其属性值被直接更改，而不是被赋予一个新的对象引用，因此在这种情况下它不会运行更改检测。视图也不会反映这些变化。在这种特殊情况下，您可以使用<code class="fe nk nl nm nn b"><strong class="kr io">markForCheck()</strong></code> <strong class="kr io"> </strong>命令Angular在该视图上执行变化检测，如下所示:</p><pre class="ke kf kg kh gt nq nn nr ns aw nt bi"><span id="2987" class="nu lm in nn b gy nv nw l nx ny">this.cd.markForCheck();</span></pre><ul class=""><li id="e66f" class="mv mw in kr b ks kt kv kw ky mx lc my lg mz lk na nb nc nd bi translated"><strong class="kr io"> ApplicationRef.tick(): </strong>触发整个应用的变更检测</li></ul></div><div class="ab cl ol om hr on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ig ih ii ij ik"><h1 id="b55c" class="ll lm in bd ln lo os lq lr ls ot lu lv jt ou ju lx jw ov jx lz jz ow ka mb mc bi translated">工作时不检测变化</h1><p id="c783" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">正如我们上面已经讨论过的，在没有变化检测的情况下运行任务是可能的。我们可以使用<code class="fe nk nl nm nn b">ngzone</code>来实现这一点。</p><pre class="ke kf kg kh gt nq nn nr ns aw nt bi"><span id="db82" class="nu lm in nn b gy nv nw l nx ny">constructor(private ngZone: NgZone) {}</span><span id="2148" class="nu lm in nn b gy ok nw l nx ny">  runWithoutChangeDetection() {<br/>    this.ngZone.runOutsideAngular(() =&gt; {<br/>      setTimeout(() =&gt; doStuff(), 1000);<br/>    });<br/>  }</span></pre><p id="26ec" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这里<code class="fe nk nl nm nn b">setTimeOut</code>不会触发变化检测。</p><h2 id="c58d" class="nu lm in bd ln nz oa dn lr ob oc dp lv ky od oe lx lc of og lz lg oh oi mb oj bi translated">NgZone</h2><p id="b796" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">NgZone是Angular的内置服务，它使我们能够走出区域，并在需要时重新进入区域。以下是一些可用的方法。</p><ul class=""><li id="340f" class="mv mw in kr b ks kt kv kw ky mx lc my lg mz lk na nb nc nd bi translated">运行():允许我们进入区域</li><li id="9292" class="mv mw in kr b ks ne kv nf ky ng lc nh lg ni lk na nb nc nd bi translated"><strong class="kr io">runoutsidenargular:</strong>允许我们走出区域</li></ul><p id="0684" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">看看下面的例子，以便更好地理解它。</p><p id="45c1" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">上面的例子说明了两个按钮，点击第一个按钮将使它在区域内运行，另一个在区域外运行。区域内的将更新视图，但从外部进行的更新不会反映在视图上。一旦完成，我们再次进入区域内<code class="fe nk nl nm nn b">console.log</code>完成。</p><p id="3a66" class="pw-post-body-paragraph kp kq in kr b ks kt jo ku kv kw jr kx ky kz la lb lc ld le lf lg lh li lj lk ig bi translated">这个例子展示了这两种方法的工作情况，以及一个潜在的用例，在这个用例中，当您在后台执行任务并在完成时显示成功消息时，您可能希望也可能不希望在视图上显示任何内容。</p></div><div class="ab cl ol om hr on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ig ih ii ij ik"><h1 id="0fb4" class="ll lm in bd ln lo os lq lr ls ot lu lv jt ou ju lx jw ov jx lz jz ow ka mb mc bi translated">结论</h1><p id="7969" class="pw-post-body-paragraph kp kq in kr b ks md jo ku kv me jr kx ky mf la lb lc mg le lf lg mh li lj lk ig bi translated">变化检测策略在Angular应用中起着至关重要的作用，每个Angular开发者在构建大规模应用时都需要利用它们。我希望这篇文章对你有所帮助，如果你有，<strong class="kr io">关注我的</strong> <a class="ae mu" href="https://medium.com/@mrahmedkhan019" rel="noopener"> <strong class="kr io">中型</strong> </a> <strong class="kr io">和</strong> <a class="ae mu" href="https://twitter.com/50shadeofkhan" rel="noopener ugc nofollow" target="_blank"> <strong class="kr io">推特</strong> </a> <strong class="kr io">获取更多软件开发文章的通知，别忘了点击按钮</strong>。终于！感谢阅读，快乐学习！</p><div class="ox oy gp gr oz pa"><a href="https://medium.com/javascript-in-plain-english/angular-regime-series-tree-shaking-technique-3dc07f5e85a1" rel="noopener follow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd io gy z fp pf fr fs pg fu fw im bi translated">树木倾斜地摇晃着</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">用温柔的方式，你可以撼动世界！</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">medium.com</p></div></div><div class="pj l"><div class="pk l pl pm pn pj po kn pa"/></div></div></a></div><div class="ox oy gp gr oz pa"><a href="https://medium.com/@mrahmedkhan019/angular-regime-series-content-projection-db0085653354" rel="noopener follow" target="_blank"><div class="pb ab fo"><div class="pc ab pd cl cj pe"><h2 class="bd io gy z fp pf fr fs pg fu fw im bi translated">角度范围系列:内容投影</h2><div class="ph l"><h3 class="bd b gy z fp pf fr fs pg fu fw dk translated">如果你在Angular 1中工作过，那么你可能已经听说过这个概念的名字…</h3></div><div class="pi l"><p class="bd b dl z fp pf fr fs pg fu fw dk translated">medium.com</p></div></div><div class="pj l"><div class="pp l pl pm pn pj po kn pa"/></div></div></a></div></div></div>    
</body>
</html>