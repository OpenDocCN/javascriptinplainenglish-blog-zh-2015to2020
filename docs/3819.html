<html>
<head>
<title>5 Features to Look Out For in Future JavaScript Versions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">未来JavaScript版本中值得关注的5个特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/5-features-to-look-out-for-in-future-javascript-versions-5c21e1f0b2c2?source=collection_archive---------22-----------------------#2020-10-26">https://javascript.plainenglish.io/5-features-to-look-out-for-in-future-javascript-versions-5c21e1f0b2c2?source=collection_archive---------22-----------------------#2020-10-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/650a4755a98b6073bec998191de9c36e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*qZk0Zee2kLp0fis1eoF_Hg.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@gamell?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Joan Gamell</a> on <a class="ae jz" href="https://unsplash.com/s/photos/javascript?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0ef9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript是一种不断发展的语言，每年TC39社区都会发布一个新版本。TC39有一整套增加新功能的系统。开发人员提出的每个新功能都要经过5个阶段。先来了解一下<a class="ae jz" href="https://tc39.es/" rel="noopener ugc nofollow" target="_blank"> TC39 </a>:</p><h1 id="0384" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">TC39</h1><p id="aafd" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">负责维护语言和添加新功能的官方组织。根据官方网站的介绍，Ecma International的TC39是一个由JavaScript开发人员、实现人员、学者等组成的团体，与社区合作维护和发展JavaScript的定义。</p><h1 id="4b94" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">提案制度</h1><ol class=""><li id="0cbd" class="mb mc in kc b kd lw kh lx kl md kp me kt mf kx mg mh mi mj bi translated">阶段0——对规范进行补充的初始计划</li><li id="bc48" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">阶段1 —描述问题和解决方案的正式提案</li><li id="d5d7" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">第2阶段—使用官方规范语言的语法和示意图更新规范的初始草案</li><li id="2055" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">第3阶段——完成草稿，并由指定的审阅者和EcmaScript编辑进行审阅，还从实现和用户那里获得反馈</li><li id="834d" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">第4阶段—一切都已完成，所有的更改都已完成，新的规范将在下一版本中推出</li></ol><blockquote class="mp mq mr"><p id="7235" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated">查看TC39关于<a class="ae jz" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank">提案阶段</a>的官方文件，了解更多详情</p></blockquote><h1 id="e7ac" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">类别字段</h1><p id="162e" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">类字段包括私有方法和访问器(如<code class="fe mw mx my mz b">get</code> &amp; <code class="fe mw mx my mz b">set</code>)、公共和私有实例字段、静态类字段和私有静态方法。让我们来看看它们:</p><h2 id="0bd9" class="na kz in bd la nb nc dn le nd ne dp li kl nf ng lm kp nh ni lq kt nj nk lu nl bi translated">私有方法和字段</h2><p id="f4c0" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我们所要做的就是在名字前加一个<code class="fe mw mx my mz b">#</code>。假设字段是<code class="fe mw mx my mz b">name</code>，那么它的私有版本将是<code class="fe mw mx my mz b">#name</code>。方法也是如此。以下是两者的一个例子:</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h2 id="957d" class="na kz in bd la nb nc dn le nd ne dp li kl nf ng lm kp nh ni lq kt nj nk lu nl bi translated">静态字段和方法</h2><p id="7314" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">就像我们对<code class="fe mw mx my mz b">instance</code>字段和方法所做的一样，我们也可以对静态字段和方法做同样的事情:</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="dae7" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">顶级等待</h1><p id="6397" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">我敢打赌，我们大多数人都使用过<code class="fe mw mx my mz b">async</code> IIFEs(立即调用的函数表达式),也称为IIFEs，以这种方式在模块的顶层使用<code class="fe mw mx my mz b">async/await</code>:</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="8e8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用这个很酷的新特性，我们可以将这段代码简化为:</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="06d2" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Array.prototype.at()</h1><p id="1a70" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated">多年来，程序员希望对javascript数组进行“负索引”，就像你对python所做的那样。“负索引”意味着能够执行<code class="fe mw mx my mz b">array[-1]</code>而不是<code class="fe mw mx my mz b">array[array.length-1]</code>，负数从最后一个元素开始向后计数。</p><p id="d6c0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，<code class="fe mw mx my mz b">[]</code>并不特定于数组和字符串，它适用于所有对象。当按索引取一个元素时，像<code class="fe mw mx my mz b">array[1]</code>，基本上就是一个对象的属性带值<code class="fe mw mx my mz b">1</code>。从技术上来说，<code class="fe mw mx my mz b">arr[-1]</code>在今天的代码中“起作用”，但是它返回对象的<code class="fe mw mx my mz b">-1</code>属性的值，而不是返回一个从末尾向后计数的索引。</p><p id="f6f6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mw mx my mz b">.at()</code>方法特定于<code class="fe mw mx my mz b">Array</code> s、<code class="fe mw mx my mz b">String</code> s和<code class="fe mw mx my mz b">TypedArray</code> s。该方法采用一个整数值并返回该索引处的项目，同时向后计数。它可以这样使用—</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><h1 id="adee" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">Object.hasOwn()</h1><p id="a044" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><code class="fe mw mx my mz b">Object.hasOwn()</code>让<code class="fe mw mx my mz b">Object.prototype.hasOwnProperty()</code>更容易上手。今天，像这样使用<code class="fe mw mx my mz b">Object.prototype.hasOwnProperty()</code>很常见:</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><p id="5734" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个方法简化了代码，如下所示:</p><figure class="nm nn no np gt jo"><div class="bz fp l di"><div class="nq nr l"/></div></figure><blockquote class="mp mq mr"><p id="3a6a" class="ka kb ms kc b kd ke kf kg kh ki kj kk mt km kn ko mu kq kr ks mv ku kv kw kx ig bi translated">点击了解更多关于<code class="fe mw mx my mz b">Object.hasOwn</code>和<a class="ae jz" href="https://github.com/tc39/proposal-accessible-object-hasownproperty" rel="noopener ugc nofollow" target="_blank">的信息</a></p></blockquote><h1 id="8d01" class="ky kz in bd la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv bi translated">新的<code class="fe mw mx my mz b">Set</code>方法</h1><p id="a842" class="pw-post-body-paragraph ka kb in kc b kd lw kf kg kh lx kj kk kl ly kn ko kp lz kr ks kt ma kv kw kx ig bi translated"><code class="fe mw mx my mz b">Set.prototype</code>增加了基于集合论的新方法。如果你在高中时从来没有注意过(我也没有)，不要担心，我也会解释这些方法。让我们来看看它们:</p><ol class=""><li id="ebf6" class="mb mc in kc b kd ke kh ki kl ns kp nt kt nu kx mg mh mi mj bi translated"><code class="fe mw mx my mz b">Set.prototype.intersection(iterable)</code> —通过将当前集合与另一个集合相交创建一个新的<code class="fe mw mx my mz b">Set</code>，即与任一集合中的公共元素相交的集合。</li><li id="8b7c" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><code class="fe mw mx my mz b">Set.prototype.union(iterable)</code> —通过并集创建一个新的<code class="fe mw mx my mz b">Set</code>，它基本上合并了任一集合中的元素，并删除了任何重复的元素。</li><li id="f891" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><code class="fe mw mx my mz b">Set.prototype.difference(iterable)</code> —创建一个新的<code class="fe mw mx my mz b">Set</code>，排除作为参数的集合中的元素。</li><li id="9a30" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><code class="fe mw mx my mz b">Set.prototype.symmetricDifference(iterable)</code> —返回只在<code class="fe mw mx my mz b">this</code>或<code class="fe mw mx my mz b">iterable</code>中找到的元素的<code class="fe mw mx my mz b">Set</code></li><li id="ce2c" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><code class="fe mw mx my mz b">Set.prototype.isSubsetOf(iterable)</code> —检查<code class="fe mw mx my mz b">Set A</code>(调用方法的那个)的元素是否出现在<code class="fe mw mx my mz b">Set B</code>(参数)中</li><li id="ce4c" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><code class="fe mw mx my mz b">Set.prototype.isSupersetOf(iterable)</code> —检查<code class="fe mw mx my mz b">Set B</code>(参数)的元素是否出现在<code class="fe mw mx my mz b">Set A</code>(调用方法的那个)中</li></ol><p id="fc8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个帖子到此为止！我希望你喜欢它。查看我的Twitter，在那里我为开发者发布了技巧、窍门和迷因。再见🤘</p></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><h1 id="7be7" class="ky kz in bd la lb oc ld le lf od lh li lj oe ll lm ln of lp lq lr og lt lu lv bi translated">资源</h1><ol class=""><li id="4640" class="mb mc in kc b kd lw kh lx kl md kp me kt mf kx mg mh mi mj bi translated">私有类字段和方法—<a class="ae jz" href="https://github.com/tc39/proposal-private-methods" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposal-private-methods</a>、<a class="ae jz" href="https://github.com/tc39/proposal-class-fields" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposal-class-fields</a>和<a class="ae jz" href="https://github.com/tc39/proposal-static-class-features" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposal-static-class-features</a></li><li id="8b6b" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">顶级<code class="fe mw mx my mz b">await</code>——<a class="ae jz" href="https://github.com/tc39/proposal-top-level-await" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposal-top-level-await</a></li><li id="52ef" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">https://github.com/tc39/proposal-relative-indexing-method的<code class="fe mw mx my mz b">Array.at()</code></li><li id="11f0" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated"><code class="fe mw mx my mz b">Object.hasOwn()</code>—<a class="ae jz" href="https://github.com/tc39/proposal-accessible-object-hasownproperty" rel="noopener ugc nofollow" target="_blank">https://github . com/tc39/proposal-accessible-object-hasownproperty</a></li><li id="7919" class="mb mc in kc b kd mk kh ml kl mm kp mn kt mo kx mg mh mi mj bi translated">设定方法—<a class="ae jz" href="https://github.com/tc39/proposal-set-methods" rel="noopener ugc nofollow" target="_blank">https://github.com/tc39/proposal-set-methods</a></li></ol></div><div class="ab cl nv nw hr nx" role="separator"><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa ob"/><span class="ny bw bk nz oa"/></div><div class="ig ih ii ij ik"><p id="0db7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ms">更多内容请看</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="ms">plain English . io</em></strong></a></p></div></div>    
</body>
</html>