<html>
<head>
<title>Vue Components — Dynamic and Async Components</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Vue组件—动态和异步组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vue-components-dynamic-and-async-components-9c4e934bd2b8?source=collection_archive---------1-----------------------#2020-03-20">https://javascript.plainenglish.io/vue-components-dynamic-and-async-components-9c4e934bd2b8?source=collection_archive---------1-----------------------#2020-03-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/1460251001050bb450e5937ca2f72a94.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*JH-FRhzXkKsA_NkF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@joshnh?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Joshua Hibbert</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5039" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Vue.js是一个易于使用的web应用框架，我们可以用它来开发交互式前端应用。</p><p id="ea45" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究如何定义和使用动态和异步组件。</p><h1 id="e5c5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">通过动态组件保持活力</h1><p id="1b5c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当我们在组件之间动态切换时，出于性能原因，我们有时希望保持状态或避免重新呈现。</p><p id="0bf8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，当在组件之间切换时，我们可以如下使用它来保持组件的状态:</p><p id="2475" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">src/index.html</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4ad1" class="mq lc iq mh b gy mr ms l mt mu">Vue.component("post", {<br/>  data() {<br/>    return {<br/>      showDetails: false<br/>    };<br/>  },<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Title&lt;/h1&gt;<br/>      &lt;button <a class="ae kc" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>='showDetails = !showDetails'&gt;<br/>        Toggle Details<br/>      &lt;/button&gt;<br/>      &lt;div v-if='showDetails'&gt;<br/>        Lorem ipsum dolor sit amet.<br/>      &lt;/div&gt;<br/>    &lt;/div&gt;<br/>  `<br/>});</span><span id="c5e1" class="mq lc iq mh b gy mv ms l mt mu">Vue.component("archive", {<br/>  data() {<br/>    return {<br/>      showDetails: false<br/>    };<br/>  },<br/>  template: `<br/>    &lt;div&gt;<br/>      &lt;h1&gt;Archive&lt;/h1&gt;<br/>    &lt;/div&gt;<br/>  `<br/>});</span><span id="38de" class="mq lc iq mh b gy mv ms l mt mu">new Vue({<br/>  el: "#app",<br/>  data: {<br/>    tabName: "post"<br/>  }<br/>});</span></pre><p id="bcc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index.html</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="65a9" class="mq lc iq mh b gy mr ms l mt mu">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;App&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kc" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;button <a class="ae kc" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>='tabName = "post"'&gt;Post&lt;/button&gt;<br/>      &lt;button <a class="ae kc" href="http://twitter.com/click" rel="noopener ugc nofollow" target="_blank">@click</a>='tabName = "archive"'&gt;Archive&lt;/button&gt;<br/>      &lt;keep-alive&gt;<br/>        &lt;component v-bind:is="tabName"&gt;&lt;/component&gt;<br/>      &lt;/keep-alive&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="0390" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们单击“切换细节”来显示文章选项卡中的文本时，我们会看到在切换到存档选项卡并返回之后，它仍会显示。</p><p id="5ea8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为我们用<code class="fe me mf mg mh b">component</code>元素包裹了<code class="fe me mf mg mh b">keep-alive</code>。</p><p id="e649" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">keep-alive</code>要求被切换的组件都有名字。</p><h1 id="f045" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">异步组件</h1><p id="d1f3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以创建只在异步组件需要时才从服务器加载的组件。</p><p id="cf5a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们没有传入一个对象作为第二个参数，而是传入一个返回承诺的函数。例如，我们可以这样写:</p><p id="3b79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">src/index.js</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="28e2" class="mq lc iq mh b gy mr ms l mt mu">Vue.component("async-component", (resolve, reject) =&gt; {<br/>  setTimeout(() =&gt; {<br/>    resolve({<br/>      template: "&lt;div&gt;Async component&lt;/div&gt;"<br/>    });<br/>  }, 1000);<br/>});</span><span id="c629" class="mq lc iq mh b gy mv ms l mt mu">new Vue({<br/>  el: "#app"<br/>});</span></pre><p id="cc14" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">index.html</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="35cc" class="mq lc iq mh b gy mr ms l mt mu">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;<br/>  &lt;head&gt;<br/>    &lt;title&gt;App&lt;/title&gt;<br/>    &lt;meta charset="UTF-8" /&gt;<br/>    &lt;script src="<a class="ae kc" href="https://cdn.jsdelivr.net/npm/vue/dist/vue.js" rel="noopener ugc nofollow" target="_blank">https://cdn.jsdelivr.net/npm/vue/dist/vue.js</a>"&gt;&lt;/script&gt;<br/>  &lt;/head&gt;<br/>  &lt;body&gt;<br/>    &lt;div id="app"&gt;<br/>      &lt;async-component&gt;&lt;/async-component&gt;<br/>    &lt;/div&gt;<br/>    &lt;script src="src/index.js"&gt;&lt;/script&gt;<br/>  &lt;/body&gt;<br/>&lt;/html&gt;</span></pre><p id="9569" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">1秒钟后，我们应该会在屏幕上看到“异步组件”。</p><p id="96f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们看到上面的函数从参数中获取了一个<code class="fe me mf mg mh b">resolve</code>函数，并在我们想要从服务器中检索定义时调用它。</p><p id="9098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要指示加载失败，我们可以调用<code class="fe me mf mg mh b">reject(reason)</code>来完成。</p><p id="f0ce" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个例子是将它与Webpack代码分割一起使用，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d6eb" class="mq lc iq mh b gy mr ms l mt mu">Vue.component('async-webpack', function (resolve) {<br/>  require(['./async-component'], resolve)<br/>})</span></pre><p id="4c74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以使用<code class="fe me mf mg mh b">import</code>功能导入一个组件，如下所示:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6979" class="mq lc iq mh b gy mr ms l mt mu">Vue.component(<br/>  'async-webpack',<br/>  () =&gt; import('./async-component')<br/>)</span></pre><p id="4907" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想在本地注册一个组件，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d9e3" class="mq lc iq mh b gy mr ms l mt mu">new Vue({<br/>  // ...<br/>  components: {<br/>    'component': () =&gt; import('./async-component')<br/>  }<br/>})</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/f36e14daafc29fdd4bf992a54957e7e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ydduOZ8FZpUrMEEC"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@chrislawton?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Chris Lawton</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="be34" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理装载状态</h1><p id="e00e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以返回一个承诺，它有一个对象来引用加载和出错的组件。</p><p id="c710" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以通过运行<code class="fe me mf mg mh b">npx vue create app</code>将它与Vue CLI生成的应用程序一起使用，其中<code class="fe me mf mg mh b">app</code>是应用程序名称。然后，我们可以在向导中选择默认选项。</p><p id="b8be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们编写如下代码:</p><p id="b743" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">App.vue</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d0a5" class="mq lc iq mh b gy mr ms l mt mu">&lt;template&gt;<br/>  &lt;div id="app"&gt;<br/>    &lt;AsyncComponent/&gt;<br/>  &lt;/div&gt;<br/>&lt;/template&gt;</span><span id="b8e1" class="mq lc iq mh b gy mv ms l mt mu">&lt;script&gt;<br/>import Loading from "./components/Loading";<br/>import Error from "./components/Error";<br/>import HelloWord from "./components/HelloWorld";</span><span id="56aa" class="mq lc iq mh b gy mv ms l mt mu">const AsyncComponent = () =&gt; ({<br/>  component: new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve(HelloWord);<br/>    }, 1000);<br/>  }),<br/>  loading: Loading,<br/>  error: Error,<br/>  delay: 0,<br/>  timeout: 3000<br/>});</span><span id="47c0" class="mq lc iq mh b gy mv ms l mt mu">export default {<br/>  name: "App",<br/>  components: {<br/>    AsyncComponent<br/>  }<br/>};<br/>&lt;/script&gt;</span><span id="1499" class="mq lc iq mh b gy mv ms l mt mu">&lt;style&gt;<br/>&lt;/style&gt;</span></pre><p id="ddc6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">components/HelloWorld.vue</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8938" class="mq lc iq mh b gy mr ms l mt mu">&lt;template&gt;<br/>  &lt;div&gt;Hello&lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="ede9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">components/Error.vue</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3e12" class="mq lc iq mh b gy mr ms l mt mu">&lt;template&gt;<br/>  &lt;div&gt;Error&lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="e823" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">component/Loading.vue</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="1295" class="mq lc iq mh b gy mr ms l mt mu">&lt;template&gt;<br/>  &lt;div&gt;Loading&lt;/div&gt;<br/>&lt;/template&gt;</span></pre><p id="476d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在<code class="fe me mf mg mh b">App.vue</code>中，下面的代码:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="95c9" class="mq lc iq mh b gy mr ms l mt mu">component: new Promise(resolve =&gt; {<br/>    setTimeout(() =&gt; {<br/>      resolve(HelloWord);<br/>    }, 1000);<br/>  })</span></pre><p id="b6ad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">延迟加载<code class="fe me mf mg mh b">HelloWorld</code>组件一秒钟。<code class="fe me mf mg mh b">delay</code>是显示加载组件之前的毫秒数。</p><p id="c771" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">timeout</code>是Vue停止加载组件之前的毫秒数。</p><p id="7bef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，当<code class="fe me mf mg mh b">HelloWorld</code>组件正在加载时，我们将看到来自<code class="fe me mf mg mh b">Loading</code>组件的加载。</p><p id="55c4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这种组件定义从Vue 2.3.0开始就有了。如果我们想对路由组件使用上述语法，应该使用Vue Router 2.4.0。</p><h1 id="cb14" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="ddff" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">keep-alive</code>来保持组件的当前状态，因为它是用<code class="fe me mf mg mh b">component</code>元素动态呈现的。</p><p id="233b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过传入一个返回承诺的函数来定义带有<code class="fe me mf mg mh b">Vue.component</code>的异步组件。</p><p id="b6f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Vue 2.3.0或更高版本中，我们可以通过创建一个函数来定义一个异步组件，该函数返回一个对象，该对象承诺将组件解析为呈现的组件。</p><p id="4d99" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">除了加载加载组件的延迟和Vue停止尝试加载组件之前的超时之外，我们还可以指定加载和错误组件。</p></div></div>    
</body>
</html>