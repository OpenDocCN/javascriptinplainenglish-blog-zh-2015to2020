<html>
<head>
<title>A Svelte application with authentication and storage</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个带有认证和存储的瘦应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-svelte-application-with-authentication-and-storage-f4a41a73bd5d?source=collection_archive---------4-----------------------#2020-10-16">https://javascript.plainenglish.io/a-svelte-application-with-authentication-and-storage-f4a41a73bd5d?source=collection_archive---------4-----------------------#2020-10-16</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1c83" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何在Svelte / Sapper中建立一个带有API、安全SQL存储和认证的极简情绪跟踪器？</h2></div><p id="9e1c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">最近，Svelte受到了越来越多的关注，但有时缺乏如何使用它来构建现实生活中的应用程序的例子。本教程演示了如何构建一个将数据存储在数据库中并需要登录的极简应用程序。</p><p id="d012" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你可以在<a class="ae ky" href="https://github.com/ehrencrona/sapper-mood" rel="noopener ugc nofollow" target="_blank"> Github </a>上找到完整代码。</p><h2 id="cf97" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">项目设置</strong></h2><p id="b9d2" class="pw-post-body-paragraph kc kd in ke b kf ls jo kh ki lt jr kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">我们将使用<a class="ae ky" href="https://sapper.svelte.dev/" rel="noopener ugc nofollow" target="_blank"> Sapper </a>，一个轻量级的服务器，用于轻松构建同构应用程序。您可以用一个命令建立一个新项目:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="0246" class="kz la in mc b gy mg mh l mi mj">npx degit “sveltejs/sapper-template#rollup” sapper-mood</span></pre><p id="f59c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“工蜂情绪”是你正在创建的项目的名称。</p><p id="4710" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">默认情况下，该项目是普通的JavaScript。要切换到TypeScript，运行<code class="fe mk ml mm mc b">node scripts/setupTypeScript</code>然后运行<code class="fe mk ml mm mc b">yarn</code>来安装依赖项，运行<code class="fe mk ml mm mc b">yarn run dev</code>来启动开发服务器。</p><h2 id="935a" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">存储</strong></h2><p id="8c7c" class="pw-post-body-paragraph kc kd in ke b kf ls jo kh ki lt jr kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">我们会将数据存储在Postgres数据库中。我们将使用<a class="ae ky" href="http://knexjs.org/" rel="noopener ugc nofollow" target="_blank"> Knex </a>来构建SQL查询，而不是在应用程序代码中手工编写SQL。Knex不是一个完全成熟的ORM(对象-关系映射),这通常是不值得的；它只是一个构建SQL查询和管理迁移的API。</p><p id="d0f0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">确保Postgres在本地运行，然后为您的数据库创建一个新数据库和一个可选的新用户:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a42f" class="kz la in mc b gy mg mh l mi mj">&gt; psql<br/># create database coaching;<br/>CREATE DATABASE<br/># create user mooduser with password 'mysecretpassword';<br/>CREATE ROLE</span></pre><p id="d127" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<code class="fe mk ml mm mc b">yarn add knex pg</code>添加Knex和Postgres驱动程序，后跟<code class="fe mk ml mm mc b">npx knex init</code>，这将创建Knex的配置文件<code class="fe mk ml mm mc b">knexfile.js</code>。</p><p id="3179" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编辑文件以输入本地Postgres的凭证，例如</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a510" class="kz la in mc b gy mg mh l mi mj">development: {<br/>  client: 'postgresql',<br/>  connection: {<br/>    database: 'mood',<br/>    user:     'mooduser',<br/>    password: 'mysecretpassword'<br/>  }<br/>}</span></pre><p id="bd85" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在需要建立一个数据库模式。将有一个按用户和日期存储情绪数据的单一表格。运行<code class="fe mk ml mm mc b">npx knex migrate:make create_schema</code>创建一个迁移文件(名为<code class="fe mk ml mm mc b">create_schema</code>)。Knex将自动运行任何尚未运行的迁移，从而使它们保持最新的数据库模式。</p><p id="92ea" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在<code class="fe mk ml mm mc b">migrations</code>目录中，您现在将拥有一个名为<code class="fe mk ml mm mc b">&lt;timestamp&gt;_create_schema.js</code>的文件。它应该导出一个<code class="fe mk ml mm mc b">up</code>函数(应用迁移)和一个<code class="fe mk ml mm mc b">down</code>函数(撤销<code class="fe mk ml mm mc b">up</code>，以防您需要回滚:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="edee" class="kz la in mc b gy mg mh l mi mj">exports.up = (knex) =&gt;<br/> knex.schema.createTable('mood', (table) =&gt; {<br/>  table.increments();<br/>  table.string('user').notNullable();<br/>  table.date('date').notNullable();<br/>  table.integer('score').notNullable();<br/>  table.unique(['user', 'date']);<br/> });</span><span id="6017" class="kz la in mc b gy mn mh l mi mj">exports.down = (knex) =&gt; knex.schema.dropTable('mood');</span></pre><p id="eee4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<code class="fe mk ml mm mc b">npx knex migrate:up</code>运行迁移以创建模式。</p><p id="abf7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，我们可以使用来检索到数据库的连接</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d763" class="kz la in mc b gy mg mh l mi mj">import * as Knex from 'knex';<br/>import knexfile from '../knexfile';</span><span id="7c95" class="kz la in mc b gy mn mh l mi mj">let connection: Knex;</span><span id="b1ec" class="kz la in mc b gy mn mh l mi mj">export function connectToDb() {<br/> connection = Knex.default(<br/>  process.env.NODE_ENV === 'production'<br/>   ? knexfile.production<br/>   : knexfile.development<br/> );<br/>}</span></pre><p id="13ec" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mk ml mm mc b">connection</code>实例具有用于执行所有通用SQL命令的方法。例如，我们可以使用检索用户的情绪历史</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="37c1" class="kz la in mc b gy mg mh l mi mj">export async function getMoodHistory(user: string) {<br/> return await connection<br/>   .select('date', 'score')<br/>   .from('mood')<br/>   .where('user', user)<br/>   .orderBy('date', 'desc')<br/>}</span></pre><p id="cae5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们应该添加一些类型和一个<code class="fe mk ml mm mc b">storeMood</code>功能，为用户更新当前的情绪。完整的代码可以在<code class="fe mk ml mm mc b"><a class="ae ky" href="https://github.com/ehrencrona/sapper-mood/blob/master/src/db.ts" rel="noopener ugc nofollow" target="_blank">src/db.ts</a></code>找到。</p><p id="5c3d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">别忘了在你的<code class="fe mk ml mm mc b">server.ts</code>里加上一个到<code class="fe mk ml mm mc b">connectToDb</code>的电话。</p><p id="bb36" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样就完成了存储层。目前还不能真正测试它，所以接下来我们将添加一个API来访问它。</p><h2 id="5ad5" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak"> API </strong></h2><p id="070a" class="pw-post-body-paragraph kc kd in ke b kf ls jo kh ki lt jr kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">使用Sapper可以非常轻松地创建API终结点。只需创建一个名为<code class="fe mk ml mm mc b">src/routes/api/mood.ts</code>的文件，并使用<code class="fe mk ml mm mc b">get</code>和<code class="fe mk ml mm mc b">put</code>方法来处理这两个HTTP谓词。</p><p id="afaf" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mk ml mm mc b">get</code>方法应返回当前用户的情绪历史。这是必需的基本代码:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="ed3b" class="kz la in mc b gy mg mh l mi mj">import { getMoodHistory } from '../../db';<br/>import { formatDate, getToday } from '../../date';</span><span id="ca79" class="kz la in mc b gy mn mh l mi mj">export function getUserId(req: IncomingMessage) {<br/>  return 'noidea';<br/>}</span><span id="fbcb" class="kz la in mc b gy mn mh l mi mj">export async function get(req, res) {<br/>  const user = getUserId(req);</span><span id="0113" class="kz la in mc b gy mn mh l mi mj">  let history = await getMoodHistory(user);</span><span id="4b81" class="kz la in mc b gy mn mh l mi mj">  res.setHeader('Content-Type', 'application/json');<br/>  res.end(JSON.stringify({ history });<br/>}</span></pre><p id="1302" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">get方法的工作原理类似于Express 中的<a class="ae ky" href="https://expressjs.com/en/guide/routing.html" rel="noopener ugc nofollow" target="_blank">路由，只是我们不需要进行路由；Sapper根据文件名称为我们执行此操作。</a></p><p id="66d9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你在浏览器中打开<code class="fe mk ml mm mc b"><a class="ae ky" href="http://localhost:3000/api/mood" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/api/mood</a></code>，你会得到<code class="fe mk ml mm mc b">{history:[]}</code>的结果，因为——事实上——数据库是空的。</p><p id="e449" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">剩下的就是:要分清今天的心情和前几天的心情，加上一些类型，实行<code class="fe mk ml mm mc b">put</code>法。结果可以在<code class="fe mk ml mm mc b"><a class="ae ky" href="https://github.com/ehrencrona/sapper-mood/blob/master/src/routes/api/mood.ts" rel="noopener ugc nofollow" target="_blank">src/routes/api/mood.ts</a></code>找到。</p><h2 id="da1b" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">认证</strong></h2><p id="2fe1" class="pw-post-body-paragraph kc kd in ke b kf ls jo kh ki lt jr kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">为了构建一个简单的身份验证层，我们将使用<a class="ae ky" href="http://auth0.com/" rel="noopener ugc nofollow" target="_blank"> Auth0 </a>，这是一个商业服务，但有一个免费层。它允许您使用外部OAuth提供商(如Google或脸书)即时添加注册、登录和身份验证。</p><p id="2bfd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，您需要<a class="ae ky" href="https://auth0.com/signup" rel="noopener ugc nofollow" target="_blank">创建一个Auth0帐户</a>并从仪表板创建一个应用程序。应用程序的类型应为“简单Web应用程序”</p><p id="1d66" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">唯一需要的配置是将允许的回调URL设置为<code class="fe mk ml mm mc b">http://localhost:3000/callback</code>，允许的注销URL设置为<code class="fe mk ml mm mc b">http://localhost:3000</code>，允许的Web源设置为<code class="fe mk ml mm mc b">http://localhost:3000</code>。</p><p id="1247" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您知道以后将在哪里托管您的应用程序，您可以添加多个用逗号分隔的域。</p><p id="cf78" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Auth0提供了中间件，使得集成到Express应用程序变得简单，但是Sapper模板使用了一个不同的服务器，叫做Polka。还好Express也支持。所以从<code class="fe mk ml mm mc b">server.ts</code>中用Express代替波尔卡开始；你可以直接搜索并替换:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3a7e" class="kz la in mc b gy mg mh l mi mj">// instead of: import polka from 'polka';<br/>import express from 'express'; </span><span id="cbb4" class="kz la in mc b gy mn mh l mi mj">// ...</span><span id="8e1d" class="kz la in mc b gy mn mh l mi mj">express().use(...) // instead of polka().use(...)</span></pre><p id="bc19" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae ky" href="https://github.com/auth0/express-openid-connect/blob/master/EXAMPLES.md" rel="noopener ugc nofollow" target="_blank">auth 0中间件</a>被称为<code class="fe mk ml mm mc b">express-openid-connect</code>，所以使用<code class="fe mk ml mm mc b">yarn add express-openid-connect</code>将其添加为依赖项。</p><p id="42e6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然后，您需要在<code class="fe mk ml mm mc b">server.ts</code>中添加中间件:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="a54f" class="kz la in mc b gy mg mh l mi mj">import authConfig from './authConfig';</span><span id="3f48" class="kz la in mc b gy mn mh l mi mj">express.use(<br/>  // ...<br/>  // the following replaces the sapper.middleware() line:<br/>  auth(authConfig),<br/>  (req, res, next) =&gt;<br/>   sapper.middleware({<br/>    session: () =&gt; ({<br/>     user: req['oidc'].user<br/>    })<br/>   })(req, res, next)</span></pre><p id="2e9b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe mk ml mm mc b">auth()</code>处理认证，仅允许通过认证的用户访问以下路由。我们在Sapper中间件中覆盖了<code class="fe mk ml mm mc b">session</code>来从Auth0获取用户，并将其放入<a class="ae ky" href="https://sapper.svelte.dev/docs#Seeding_session_data" rel="noopener ugc nofollow" target="_blank"> Sapper会话</a>。这使得它在客户端和服务器端都可用于每个路由的<code class="fe mk ml mm mc b">preload</code>功能。</p><p id="d073" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将您的Auth0配置放入<code class="fe mk ml mm mc b">src/authConfig.ts</code>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="5194" class="kz la in mc b gy mg mh l mi mj">export default {<br/> authRequired: false,<br/> auth0Logout: true,<br/> baseURL: '<a class="ae ky" href="http://localhost:3000'" rel="noopener ugc nofollow" target="_blank">http://localhost:3000'</a>,<br/> clientID: '&lt;long sequence of letters and numbers&gt;',<br/> // a.k.a. "domain" in the Auth0 admin; prepend "https://"<br/> issuerBaseURL: '<a class="ae ky" href="https://dev-ylt2rw9o.eu.auth0.com'" rel="noopener ugc nofollow" target="_blank">https://&lt;an ID&gt;.&lt;eu/us&gt;.auth0.com'</a>,<br/> // choose a long, random string.<br/> secret: 'AyBYwCy73cBystBD6iZgYFNdquqqP'<br/>};</span></pre><p id="c69b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当您登录到Auth0时，您会在您的应用程序中找到客户端ID和域(<code class="fe mk ml mm mc b">issueBaseURL</code>)。参见<code class="fe mk ml mm mc b"><a class="ae ky" href="https://github.com/ehrencrona/sapper-mood/blob/master/src/authConfig.ts" rel="noopener ugc nofollow" target="_blank">src/authConfig.ts</a></code>了解如何将该配置应用于生产环境。</p><p id="6c2e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以为上面添加的<code class="fe mk ml mm mc b">getUserId</code>函数提供一个更好的实现:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="4a76" class="kz la in mc b gy mg mh l mi mj">function getUserId(req) {<br/>  return req['oidc'].user;<br/>}</span></pre><p id="cd85" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还有一点:上面的配置说不需要认证。这会阻止用户立即被重定向到登录页面。但是我们仍然希望API路由总是需要登录。我们可以通过在<code class="fe mk ml mm mc b">auth()</code>之后的<code class="fe mk ml mm mc b">server.ts</code>中添加更多的中间件来解决这个问题:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d770" class="kz la in mc b gy mg mh l mi mj">(req, res, next) =&gt; {<br/>  if (req.path.startsWith('/api') &amp;&amp; !req['oidc']?.user) {<br/>    notAuthorized(res);<br/>  } else {<br/>    next();<br/>  }<br/>},</span></pre><p id="8bae" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果请求路径以<code class="fe mk ml mm mc b">/api</code>开始，并且没有用户登录，发送401响应，否则一切正常。401响应可能是这样的:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="9224" class="kz la in mc b gy mg mh l mi mj">function notAuthorized(res: Response) {<br/> res.setHeader('Content-Type', 'application/json');<br/> res.status(401).send(JSON.stringify({ error: 'Not authorized' }));<br/>}</span></pre><p id="c997" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这就完成了认证。如果现在加载<code class="fe mk ml mm mc b"><a class="ae ky" href="http://localhost:3000/api/mood" rel="noopener ugc nofollow" target="_blank">/api/mood</a></code>，应该会得到<code class="fe mk ml mm mc b">Not authorized</code>。如果你去<code class="fe mk ml mm mc b"><a class="ae ky" href="http://localhost:3000/login" rel="noopener ugc nofollow" target="_blank">http://localhost:3000/login</a></code>,你应该会看到一个登录/注册页面，一旦完成，会将你重定向回应用程序。</p><h2 id="bb3b" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">前端</strong></h2><p id="dc6d" class="pw-post-body-paragraph kc kd in ke b kf ls jo kh ki lt jr kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">在前端，我们希望获取情绪历史并呈现它。Sapper有一个负责获取数据的“预加载”函数的概念。</p><p id="b98e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将以下内容放入<code class="fe mk ml mm mc b">index.svelte</code>:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="6ad2" class="kz la in mc b gy mg mh l mi mj">&lt;script context="module" lang="ts"&gt;<br/> export async function preload() {<br/>   let history;<br/>   const res = await this.fetch(`/api/mood`);</span><span id="d5f5" class="kz la in mc b gy mn mh l mi mj">   if (res.status == 200) {<br/>     ({ history } = await res.json());<br/>   }</span><span id="f0d7" class="kz la in mc b gy mn mh l mi mj">   return { history }<br/> }<br/>&lt;/script&gt;</span></pre><p id="c53e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">预加载功能将在服务器端和客户端执行。如果用户通过了身份验证(这是通过cookie实现的)，状态将是200(“OK”)，我们可以检索历史记录。</p><p id="7458" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">无论<code class="fe mk ml mm mc b">preload</code>返回什么，都可以作为当前组件的属性。我们需要声明我们需要历史属性，然后我们准备使用它:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="d2d4" class="kz la in mc b gy mg mh l mi mj">&lt;script lang="ts"&gt;<br/> export let history: Day[];<br/>&lt;/script&gt;</span><span id="3cb5" class="kz la in mc b gy mn mh l mi mj">&lt;ul&gt;<br/>  {#each history as day}<br/>    &lt;li&gt;<br/>      &lt;div class="date"&gt;{day.date}&lt;/div&gt;<br/>      &lt;div class="score"&gt;{day.score}&lt;/div&gt;<br/>    &lt;/li&gt;<br/>  {/each}<br/>&lt;/ul&gt;</span></pre><p id="a895" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">要设置您当前的心情，我们需要调用API的<code class="fe mk ml mm mc b">PUT</code>方法。在带有<code class="fe mk ml mm mc b">history</code>声明的<code class="fe mk ml mm mc b">&lt;script&gt;</code>内添加<code class="fe mk ml mm mc b">storeMood</code>函数(不是带有预加载函数的那个):</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="c4bf" class="kz la in mc b gy mg mh l mi mj">const storeMood = (score: number) =&gt; {<br/>  fetch("/api/mood", {<br/>    method: "PUT",<br/>    headers: {<br/>      "Content-Type": "application/json"<br/>    },<br/>    body: JSON.stringify({ today: score })<br/>  })<br/>};</span></pre><p id="85e0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们现在可以从模板中调用它:</p><pre class="lx ly lz ma gt mb mc md me aw mf bi"><span id="3c10" class="kz la in mc b gy mg mh l mi mj">&lt;h3&gt;How do you feel?&lt;/h3&gt;</span><span id="35c7" class="kz la in mc b gy mn mh l mi mj">&lt;button on:click={{} =&gt; storeMood(1)}&gt;Good&lt;/button&gt;</span><span id="4d3d" class="kz la in mc b gy mn mh l mi mj">&lt;button on:click={{} =&gt; storeMood(0)}&gt;Bad&lt;/button&gt;</span></pre><p id="d50f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这为您留下了一个功能完整的应用程序:如果您登录并单击按钮，您应该看到您的数据库正在被填充。</p><p id="88da" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它的美妙之处在于你可以自动获得水合作用:你从服务器获得的HTML已经包含了情绪历史，结果是一个即使没有JavaScript也能呈现的页面，并且不会渐进加载；一打开，所有的数据都在那里。</p><p id="bd20" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了完成用户界面，你应该添加一些CSS，错误处理，并将其分解成组件。你可以在<code class="fe mk ml mm mc b"><a class="ae ky" href="https://github.com/ehrencrona/sapper-mood/blob/master/src/routes/index.svelte" rel="noopener ugc nofollow" target="_blank">src/routes/index.svelte</a></code>和<code class="fe mk ml mm mc b"><a class="ae ky" href="https://github.com/ehrencrona/sapper-mood/tree/master/src/components" rel="noopener ugc nofollow" target="_blank">src/components</a></code>中看到这个结果。</p><p id="e802" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完成的应用程序如下所示</p><figure class="lx ly lz ma gt mp gh gi paragraph-image"><div role="button" tabindex="0" class="mq mr di ms bf mt"><div class="gh gi mo"><img src="../Images/1150119ce8e07029e6aac7b03cc02315.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Qq4M83sSag9qufpOOGfzQQ.png"/></div></div></figure><h2 id="8c0e" class="kz la in bd lb lc ld dn le lf lg dp lh kl li lj lk kp ll lm ln kt lo lp lq lr bi translated"><strong class="ak">结论</strong></h2><p id="6af7" class="pw-post-body-paragraph kc kd in ke b kf ls jo kh ki lt jr kk kl lu kn ko kp lv kr ks kt lw kv kw kx ig bi translated">我希望这表明用Svelte和Sapper构建一个完整的应用程序是多么容易。我们可以免费获得很多东西，例如让应用程序离线工作的服务人员、服务器端渲染和水合作用，以获得惊人的性能和SEO。</p></div></div>    
</body>
</html>