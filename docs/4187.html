<html>
<head>
<title>Decouple Data from UI with React Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用React钩子将数据从UI解耦</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/decouple-data-from-ui-with-react-hooks-6f7fe968c3e3?source=collection_archive---------3-----------------------#2020-11-23">https://javascript.plainenglish.io/decouple-data-from-ui-with-react-hooks-6f7fe968c3e3?source=collection_archive---------3-----------------------#2020-11-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="019e" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">以及我如何用JavaScript函数“编程到一个接口”</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f8d04aff0787612ac43215ce0aca2453.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ysy1EpS9hF5J3qnkT5TX3A.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Source: <a class="ae ks" href="https://imgur.com/gallery/CgWZFId" rel="noopener ugc nofollow" target="_blank">Imgur</a></figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="e142" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">我相信您已经见过(或写过)这种常见的React模式:(a)在通过AJAX获取一些数据的同时呈现一个占位符/加载器/微调器，然后(b)根据接收到的数据重新呈现组件。让我们编写一个功能组件，利用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank">获取API </a>来完成这个任务。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="7a4e" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">假设我的应用增长了，有<code class="fe ly lz ma mb b">X</code>个组件使用相同的数据获取逻辑，因为……原因。为了避免服务器收到垃圾数据请求，我决定使用<a class="ae ks" href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage" rel="noopener ugc nofollow" target="_blank">本地存储</a>来缓存数据。</p><p id="11be" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><strong class="lc io">好的……这是否意味着我需要更新数据逻辑</strong> <code class="fe ly lz ma mb b"><strong class="lc io">X</strong></code> <strong class="lc io">次？😬😱</strong></p><p id="64ac" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">不，让我们<a class="ae ks" href="https://medium.com/better-programming/kiss-dry-and-code-principles-every-developer-should-follow-b77d89f51d74" rel="noopener">写一个自定义的钩子<code class="fe ly lz ma mb b">useSomeData</code>来干掉</a>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="aa0c" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">共享这个数据逻辑的组件现在看起来很简洁。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="911a" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><strong class="lc io">好吧……干代码很棒，但那又怎样？</strong></p><p id="110f" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">假设我的应用程序变得复杂，所以我决定使用Redux来处理AJAX请求并维护全局应用程序状态。我只是简单地更新了<code class="fe ly lz ma mb b">useSomeData</code> <em class="mc">的实现，而没有触及UI组件</em>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="e01e" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">然后GraphQL出现了，我也跟上了潮流。同样，我只是简单地更新了<code class="fe ly lz ma mb b">useSomeData</code>T19的实现，而没有触及UI组件。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="lw lx l"/></div></figure><p id="ed17" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><strong class="lc io">每当我被迫用最新/最热的状态管理框架或API范式更新数据层时，就清洗并重复。</strong></p><p id="5131" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">对我来说，这看起来很像经典的依赖倒置原则，即SOLID中的“D”(查看Matthew Lucas 的优秀<a class="ae ks" href="https://medium.com/better-programming/revisiting-solid-927e6a5202d3" rel="noopener">讲解者</a>)。虽然这无论如何都不是OOP，我们正式定义了一个抽象的<code class="fe ly lz ma mb b">Interface</code>并创建了一个实现那个<code class="fe ly lz ma mb b">Interface</code>的具体的<code class="fe ly lz ma mb b">Class</code>，但我认为有一个事实上的“接口”<code class="fe ly lz ma mb b">useSomeData</code>提供给使用它的各种UI组件。在这个例子中，UI不关心<code class="fe ly lz ma mb b">useSomeData</code>如何工作，只要它从钩子接收到<code class="fe ly lz ma mb b">someData</code>、<code class="fe ly lz ma mb b">loading</code>和<code class="fe ly lz ma mb b">error</code>。</p><p id="24c2" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><strong class="lc io">所以从理论上来说，这将用户界面从被锁定到数据层的任何特定实现中解放出来，并且支持迁移到新的实现(框架/库/等等),而不必更新用户界面代码，只要“接口”契约被兑现。</strong></p><p id="21e5" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">很想听听你的想法。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi mf"><img src="../Images/413c5c0714fc977fcfae1bc6d3771125.png" data-original-src="https://miro.medium.com/v2/resize:fit:1080/format:webp/1*F1CfUAi51VQA4NJd3Fj_cA.jpeg"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Source: <a class="ae ks" href="https://www.pinterest.com/pin/333759022356307210/" rel="noopener ugc nofollow" target="_blank">Pinterest</a></figcaption></figure></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="bc14" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated"><strong class="lc io">p . s .</strong><a class="ae ks" href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" rel="noopener">容器模式</a>、<a class="ae ks" href="https://reactjs.org/docs/render-props.html" rel="noopener ugc nofollow" target="_blank">渲染道具</a>和<a class="ae ks" href="https://reactjs.org/docs/higher-order-components.html" rel="noopener ugc nofollow" target="_blank"> HOC </a>是将传统组件的数据层与UI层分离的流行选项。这篇文章并不是要讨论Hooks是好是坏。我只是分享我是如何学会使用钩子来应用同样的关注点分离的。</p></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><h1 id="8f27" class="mg mh in bd mi mj mk ml mm mn mo mp mq jt mr ju ms jw mt jx mu jz mv ka mw mx bi translated">阅读更多</h1><div class="my mz gp gr na nb"><a href="https://medium.com/javascript-in-plain-english/how-to-decouple-data-from-ui-in-react-d6b1516f4f0b" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">在React第2部分中将数据从UI中分离出来</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">对钩子、渲染道具和特设模式的进一步探索</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np km nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://medium.com/javascript-in-plain-english/intro-to-react-server-side-rendering-3c2af3782d08" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd io gy z fp ng fr fs nh fu fw im bi translated">React服务器端渲染简介</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">如何在没有任何工具或框架的情况下构建一个React SSR app？</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np km nb"/></div></div></a></div></div><div class="ab cl kt ku hr kv" role="separator"><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky kz"/><span class="kw bw bk kx ky"/></div><div class="ig ih ii ij ik"><p id="a251" class="pw-post-body-paragraph la lb in lc b ld le jo lf lg lh jr li lj lk ll lm ln lo lp lq lr ls lt lu lv ig bi translated">📫<em class="mc">我们来连线上</em><a class="ae ks" href="https://www.linkedin.com/in/suhanwijaya/" rel="noopener ugc nofollow" target="_blank"><em class="mc">LinkedIn</em></a><em class="mc">或者</em><a class="ae ks" href="https://twitter.com/suhanw" rel="noopener ugc nofollow" target="_blank"><em class="mc">Twitter</em></a><em class="mc">！</em></p></div></div>    
</body>
</html>