<html>
<head>
<title>How to use Vue Lifecycle Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Vue生命周期挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/vue-lifecycle-hooks-part-2-16ccfd2516de?source=collection_archive---------6-----------------------#2020-10-08">https://javascript.plainenglish.io/vue-lifecycle-hooks-part-2-16ccfd2516de?source=collection_archive---------6-----------------------#2020-10-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3c4d" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">第2部分:激活、停用、错误捕获、渲染跟踪、渲染触发</h2></div><h1 id="a943" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">介绍</h1><p id="386f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">让我们在本文中探索Vue的生命周期挂钩，包括<strong class="kw io">激活的</strong>、<strong class="kw io">去激活的</strong>、<strong class="kw io">错误捕获的</strong>、<strong class="kw io">渲染跟踪的</strong>和<strong class="kw io">渲染触发的</strong>。Vue 3最近刚刚发布，更新了一些很酷的特性，例如<strong class="kw io"> renderTracked </strong>和<strong class="kw io">render trigged</strong>生命周期挂钩。其他生命周期挂钩在这里解释<a class="ae lq" href="https://medium.com/@eng5128/vue-lifecycle-hooks-75d296e7ef8" rel="noopener">。</a></p><h2 id="ec3f" class="lr kd in bd ke ls lt dn ki lu lv dp km ld lw lx ko lh ly lz kq ll ma mb ks mc bi translated">激活和停用</h2><p id="659e" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">当一个组件被一个动态组件<strong class="kw io"> keep-alive </strong>包装时，<code class="fe md me mf mg b">activated</code>和<code class="fe md me mf mg b">deactivated</code>生命周期钩子将被相应地调用。当切换选项卡或导航到另一个页面时，如果想要保留/维护以前的状态，这个动态组件非常有用。</p><ul class=""><li id="eea1" class="mh mi in kw b kx mj la mk ld ml lh mm ll mn lp mo mp mq mr bi translated"><code class="fe md me mf mg b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#activated" rel="noopener ugc nofollow" target="_blank">activated</a></code>钩显示动态组件<strong class="kw io">如<em class="ms">首页组件</em> </strong>在网页上是活动的。</li><li id="a067" class="mh mi in kw b kx mt la mu ld mv lh mw ll mx lp mo mp mq mr bi translated">当加载另一个动态组件并且动态组件<strong class="kw io">如<em class="ms"> Home组件</em> </strong>不活动时，调用<code class="fe md me mf mg b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#deactivated" rel="noopener ugc nofollow" target="_blank">deactivated</a></code>钩子。但是，当动态组件不活动时，它们的状态不会改变。</li></ul></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="34cb" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld nf lf lg lh ng lj lk ll nh ln lo lp ig bi translated"><strong class="kw io">演示场景</strong>:创建标签组件并用保活包装。</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">activated and deactivated hooks (JavaScript Code)</figcaption></figure><figure class="ni nj nk nl gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi nt"><img src="../Images/fcb10916bbd5834a3f72c8e2bbc28198.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*2Ewf-E2C4myf5dMpXFt67w.gif"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">activated and deactivated for each component</figcaption></figure><h2 id="17a3" class="lr kd in bd ke ls lt dn ki lu lv dp km ld lw lx ko lh ly lz kq ll ma mb ks mc bi translated">错误被捕获</h2><p id="61f8" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated"><code class="fe md me mf mg b">errorCaptured</code>仅由任何后代组件触发被捕获。全局错误处理器还有另一个函数<code class="fe md me mf mg b"><a class="ae lq" href="https://vuejs.org/v2/api/#errorHandler" rel="noopener ugc nofollow" target="_blank">errorHandler</a></code>。但是这个函数不捕获事件处理程序错误。它将在组件渲染期间捕获函数和观察器。更多信息，你可以从<a class="ae lq" href="https://stackoverflow.com/questions/49214634/how-to-capture-vuejs-errors-from-a-single-point-inside-a-component" rel="noopener ugc nofollow" target="_blank">这里</a>阅读。</p><p id="79fc" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld nf lf lg lh ng lj lk ll nh ln lo lp ig bi translated"><code class="fe md me mf mg b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#errorcaptured" rel="noopener ugc nofollow" target="_blank">errorCaptured</a></code>钩子接收3个参数:</p><ul class=""><li id="875c" class="mh mi in kw b kx mj la mk ld ml lh mm ll mn lp mo mp mq mr bi translated">显示消息的<strong class="kw io">错误</strong>。</li><li id="0cfd" class="mh mi in kw b kx mt la mu ld mv lh mw ll mx lp mo mp mq mr bi translated">一个<strong class="kw io">组件</strong>，它将输出一个代理对象。</li><li id="4ff1" class="mh mi in kw b kx mt la mu ld mv lh mw ll mx lp mo mp mq mr bi translated"><strong class="kw io">信息</strong>会告诉你哪种错误，例如<em class="ms">渲染函数</em>或<em class="ms">本地事件处理程序</em>。</li></ul></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="9671" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld nf lf lg lh ng lj lk ll nh ln lo lp ig bi translated"><strong class="kw io">演示场景</strong>:在<strong class="kw io"> Home </strong>模板中创建一个带有click事件<strong class="kw io"> notDefinedMethod </strong>的按钮，但是没有在Vue实例中定义该方法。点击<strong class="kw io"> Home </strong>组件按钮时捕捉到错误。</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">errorCapture hook (JavaScript Code)</figcaption></figure><figure class="ni nj nk nl gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oa"><img src="../Images/0fc42261bfb0ce8b6f112ebf5f7651c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9zwE-CCbwYtvEOkb4nY6dA.png"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">The output from errorCaptured hook</figcaption></figure><h2 id="2aa2" class="lr kd in bd ke ls lt dn ki lu lv dp km ld lw lx ko lh ly lz kq ll ma mb ks mc bi translated">渲染跟踪和渲染触发</h2><p id="3f2f" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">根据Vue的创造者尤雨溪的说法:</p><p id="ec23" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld nf lf lg lh ng lj lk ll nh ln lo lp ig bi translated"><em class="ms">更好的调试能力:我们可以使用新的</em> <code class="fe md me mf mg b"><em class="ms">renderTracked</em></code> <em class="ms">和</em> <code class="fe md me mf mg b"><em class="ms">renderTriggered</em></code> <em class="ms">钩子精确地跟踪和触发组件重渲染的时间和原因。</em></p><p id="e66f" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld nf lf lg lh ng lj lk ll nh ln lo lp ig bi translated">这两个生命周期挂钩有助于通过减少不必要的组件重新呈现来提高web页面性能。第一次渲染时,<code class="fe md me mf mg b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#rendertracked" rel="noopener ugc nofollow" target="_blank">renderTracked</a></code>钩子将被记录一次。这个钩子<strong class="kw io">跟踪</strong>虚拟DOM的重新渲染。</p></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="f03c" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld nf lf lg lh ng lj lk ll nh ln lo lp ig bi translated"><strong class="kw io">演示场景</strong>:创建标签组件并用保活包装。另一个例子是在没有保持活动的情况下创建和包装的标签组件。在<strong class="kw io">信息选项卡</strong>输入姓名，切换到<strong class="kw io">关于选项卡</strong>。我们将看到<code class="fe md me mf mg b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#rendertracked" rel="noopener ugc nofollow" target="_blank">renderTracked</a></code>如何在控制台上挂钩输出以及它们之间的区别。</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">renderTracked hook (JavaScript Code)</figcaption></figure><figure class="ni nj nk nl gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ob"><img src="../Images/279cf76db80e0f368eaabb7621723902.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*zlGX_sdO3AZBG2nI1MsoCQ.gif"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">component wrapped with keep-alive</figcaption></figure><figure class="ni nj nk nl gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi ob"><img src="../Images/669c0a3a246298008b885c6621da76d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*AO0vQew3uXnRgEvOJ5Tciw.gif"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">component wrapped without keep-alive</figcaption></figure><p id="fa3e" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld nf lf lg lh ng lj lk ll nh ln lo lp ig bi translated">使用keep-alive，它会停止重新渲染组件。在由keep-alive包装的组件中，<code class="fe md me mf mg b">renderTracked</code>钩子记录了4次。</p><p id="a33f" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld nf lf lg lh ng lj lk ll nh ln lo lp ig bi translated"><code class="fe md me mf mg b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#rendertriggered" rel="noopener ugc nofollow" target="_blank">renderTriggered</a></code>钩子告诉你什么事件被触发来重新渲染一个组件。</p></div><div class="ab cl my mz hr na" role="separator"><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd ne"/><span class="nb bw bk nc nd"/></div><div class="ig ih ii ij ik"><p id="f4a2" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld nf lf lg lh ng lj lk ll nh ln lo lp ig bi translated"><strong class="kw io">演示场景</strong>:点击Tab组件会触发<code class="fe md me mf mg b"><a class="ae lq" href="https://v3.vuejs.org/api/options-lifecycle-hooks.html#rendertriggered" rel="noopener ugc nofollow" target="_blank">renderTriggered</a></code>钩子。</p><figure class="ni nj nk nl gt nm"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">renderTriggered hook (JavaScript Code)</figcaption></figure><figure class="ni nj nk nl gt nm gh gi paragraph-image"><div role="button" tabindex="0" class="nu nv di nw bf nx"><div class="gh gi oc"><img src="../Images/70136810db5e08fe9ce1108eca925737.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*nchrJ2PJFZKcMQpbvMRDZg.gif"/></div></div><figcaption class="np nq gj gh gi nr ns bd b be z dk">renderTriggered will be called when clicking the tabs</figcaption></figure><h1 id="a2a5" class="kc kd in bd ke kf kg kh ki kj kk kl km jt kn ju ko jw kp jx kq jz kr ka ks kt bi translated">结论</h1><p id="5637" class="pw-post-body-paragraph ku kv in kw b kx ky jo kz la lb jr lc ld le lf lg lh li lj lk ll lm ln lo lp ig bi translated">当我们想要开发更大、更复杂的应用程序时，这些生命周期挂钩是有用和强大的。</p><p id="5de0" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld nf lf lg lh ng lj lk ll nh ln lo lp ig bi translated">这里是<a class="ae lq" href="https://github.com/Chueeng/vue-s-lifecycle" rel="noopener ugc nofollow" target="_blank">完整版代码</a>。</p><p id="f3a7" class="pw-post-body-paragraph ku kv in kw b kx mj jo kz la mk jr lc ld nf lf lg lh ng lj lk ll nh ln lo lp ig bi translated">谢谢你。</p></div></div>    
</body>
</html>