<html>
<head>
<title>What is Array.reduce() in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的Array.reduce()是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-array-reduce-4409d9706f27?source=collection_archive---------5-----------------------#2020-02-01">https://javascript.plainenglish.io/what-is-array-reduce-4409d9706f27?source=collection_archive---------5-----------------------#2020-02-01</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/3e242c6601d15084407cb97043045f76.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*IpzUhrAc3jYUw3OL"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0180" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">发布版<a class="ae jz" href="https://www.ecma-international.org/ecma-262/6.0/" rel="noopener ugc nofollow" target="_blank"> ECMAScript 2015语言规范</a>(通常称为ES6)为JavaScript引入了一系列新功能，包括在<code class="fe ky kz la lb b">Array</code>原型上的一些新功能。当我第一次发现这些并开始尝试在我的代码中使用它们时，它们中的大多数看起来非常简单。当您需要以某种统一的方式转换数组的每个元素时，<code class="fe ky kz la lb b">map</code>是显而易见的选择。如果我们需要根据一些标准过滤掉一些元素，那么很容易假设<code class="fe ky kz la lb b">filter</code>会完成这个任务。但是<code class="fe ky kz la lb b">Array.reduce</code>是做什么的，它是如何工作的，我们什么时候想要使用它？这篇文章旨在回答这些问题，并提供一些如何在现实生活中应用的例子。</p><h1 id="243d" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">它是做什么的？</h1><p id="890f" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">事实证明，这个函数的通用性和强大之处在于它缺乏专门化。像<code class="fe ky kz la lb b">Array.map</code>一样，<code class="fe ky kz la lb b">Array.reduce</code>遍历数组并调用每个元素的回调函数。不同之处在于，它不是返回包含回调在每个元素中返回的内容的大小相等的数组，而是返回回调的最终调用返回的内容。这很有用，因为除了当前元素和索引之外，回调还会接受上一次调用回调时返回的值。<a class="ae jz" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" rel="noopener ugc nofollow" target="_blank"> MDN </a>将其描述为“累加器”,因为在大多数情况下，您将以某种有意义的方式修改这个值，并将其返回供下一次迭代使用。<code class="fe ky kz la lb b">reduce</code>函数将用于第一次迭代的初始值作为第二个参数。我意识到这个描述并不比<a class="ae jz" href="https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.reduce" rel="noopener ugc nofollow" target="_blank">规范</a>更清晰，如果你和我一样，一个简单的例子会让你更容易完全理解。</p><h1 id="f7b5" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">将数组简化为其元素之和</h1><p id="44c3" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">每个程序员在某个时候都不得不这样做，如果你没有使用<code class="fe ky kz la lb b">reduce</code>，你的解决方案可能看起来像这样:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="bffc" class="mn ld in lb b gy mo mp l mq mr">let arr = [1, 2, 3, 4, 5]<br/>let sum = 0<br/>for (let i = 0; i &lt; arr.length; i++) {<br/>  sum += arr[i]<br/>}<br/>console.log(sum) // 15</span></pre><p id="cb64" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下面是你如何使用<code class="fe ky kz la lb b">Array.reduce</code>来做这件事:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="6bf1" class="mn ld in lb b gy mo mp l mq mr">let arr = [1, 2, 3, 4, 5]<br/>let sum = arr.reduce((prev, cur) =&gt; prev + cur, 0)<br/>console.log(sum) // 15</span></pre><p id="86f3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，让我们快速确定函数中包含的内容。作为参考，下面是<code class="fe ky kz la lb b">Array.reduce</code>的定义:</p><p id="d30d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe ky kz la lb b">Array.prototype.reduce(cb(prev, cur, idx, arr)[, initialValue])</code></p><p id="c389" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们知道<code class="fe ky kz la lb b">reduce</code>将一个回调函数和一个初始值作为它的参数，回调函数将前一个结果(我们调用<code class="fe ky kz la lb b">acc</code>作为‘累加器’)、当前索引和我们正在处理的数组的副本作为它的参数。在这种情况下，回调是箭头函数<code class="fe ky kz la lb b">(prev, cur) =&gt; prev + cur</code>，初始值是<code class="fe ky kz la lb b">0</code>。在这个例子中，我们不关心当前的索引或者原始的数组。</p><p id="068c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意:不要害怕箭头函数，它所做的只是返回<code class="fe ky kz la lb b">prev</code>和<code class="fe ky kz la lb b">cur</code>的和。</p><p id="6731" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们玩调试器，在数组的每个元素上逐步调用<code class="fe ky kz la lb b">(prev, cur) =&gt; prev + cur</code>:</p><ol class=""><li id="3134" class="ms mt in kc b kd ke kh ki kl mu kp mv kt mw kx mx my mz na bi translated">初始值是<code class="fe ky kz la lb b">0</code>，所以<code class="fe ky kz la lb b">callback(prev: 0, cur: arr[0])</code>会执行<code class="fe ky kz la lb b">0 + 1</code>，求值到<code class="fe ky kz la lb b">1</code>。</li><li id="7b43" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated">该值被用作下一个调用的第一个参数，因此<code class="fe ky kz la lb b">callback(prev: 1, cur: arr[1])</code>将执行<code class="fe ky kz la lb b">1 + 2</code>并评估为<code class="fe ky kz la lb b">3</code>。</li><li id="fab0" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated"><code class="fe ky kz la lb b">callback(prev: 3, cur: arr[2])</code>执行<code class="fe ky kz la lb b">3 + 3</code>并评估为<code class="fe ky kz la lb b">6</code>。</li><li id="da3f" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated"><code class="fe ky kz la lb b">callback(prev: 6, cur: arr[3])</code>执行<code class="fe ky kz la lb b">6 + 4</code>并评估为<code class="fe ky kz la lb b">10</code>。</li><li id="2ba0" class="ms mt in kc b kd nb kh nc kl nd kp ne kt nf kx mx my mz na bi translated"><code class="fe ky kz la lb b">callback(prev: 10, cur: arr[4])</code>执行<code class="fe ky kz la lb b">10 + 5</code>并评估为<code class="fe ky kz la lb b">15</code>。</li></ol><h1 id="603e" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">从数组创建地图</h1><p id="7c96" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">有时候，当您从API或数据库中获取一组对象时，您需要能够通过id或其他一些属性轻松地访问它们。这是我最喜欢使用的<code class="fe ky kz la lb b">reduce</code>之一。假设我们收到了以下数组:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="7bb2" class="mn ld in lb b gy mo mp l mq mr">const data = [{<br/>    id: 01395,<br/>    name: 'Adam', <br/>    phone: 1233454567<br/>  }, {<br/>    id: 8593,<br/>    name: 'Beth',<br/>    phone: 3452348765<br/>  }, {<br/>    id: 3824,<br/>    name: 'Carol'<br/>  },<br/>  ...<br/>]</span></pre><p id="8083" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们有了这些数据，我们需要能够使用<code class="fe ky kz la lb b">id</code>找到一个人的<code class="fe ky kz la lb b">phone</code>和<code class="fe ky kz la lb b">name</code>。因为我们的程序需要多次这样做，所以遍历数组直到找到一个带有我们正在寻找的<code class="fe ky kz la lb b">id</code>的对象是没有意义的。相反，我们可以迭代一次，并使用<code class="fe ky kz la lb b">reduce</code>创建一个键为<code class="fe ky kz la lb b">id</code>的对象。</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="a460" class="mn ld in lb b gy mo mp l mq mr">const users = data.reduce((acc, cur) =&gt; {<br/>  acc[cur.id] = cur<br/>  return acc<br/>}, {})</span></pre><p id="528b" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种情况下，我们使用一个空对象作为初始值，并在每次迭代中向它添加属性，使用<code class="fe ky kz la lb b">cur.id</code>作为键，使用<code class="fe ky kz la lb b">cur</code>作为值。这使得<code class="fe ky kz la lb b">users</code>看起来像这样:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="d92c" class="mn ld in lb b gy mo mp l mq mr">{ <br/>  01395: {<br/>    id: 01385,<br/>    name: 'Adam',<br/>    phone: 1233454567<br/>  }, {<br/>...<br/>}</span></pre><p id="4497" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以通过元素的<code class="fe ky kz la lb b">id</code>来查找其中一个元素:</p><pre class="mf mg mh mi gt mj lb mk ml aw mm bi"><span id="c86f" class="mn ld in lb b gy mo mp l mq mr">let user = users[id]</span></pre><h1 id="76a3" class="lc ld in bd le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz bi translated">警告:不要什么都用它</h1><p id="4720" class="pw-post-body-paragraph ka kb in kc b kd ma kf kg kh mb kj kk kl mc kn ko kp md kr ks kt me kv kw kx ig bi translated">当我第一次知道这个函数是如何工作的时候，我有点兴奋，并开始用它来做各种实际上应该用传统循环来做的事情。像我一样发疯，开始使用<code class="fe ky kz la lb b">reduce</code>将对象数组聚合成其他漂亮的对象，这可能不是一个好主意。代码很容易失去可读性和性能，所以您可以这样做并不意味着您应该这样做。</p><p id="f093" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">编码快乐！</p></div></div>    
</body>
</html>