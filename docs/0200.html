<html>
<head>
<title>A Guide to JavaScript Promises</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript承诺指南</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/a-guide-to-javascript-promises-da50eff327d7?source=collection_archive---------0-----------------------#2019-08-07">https://javascript.plainenglish.io/a-guide-to-javascript-promises-da50eff327d7?source=collection_archive---------0-----------------------#2019-08-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4bd4" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中所有异步事物的短暂游览:从回调地狱到异步/等待</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/52bcac33109236c1d2f9d9d4fe44fb26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*e-1gfnNch17BxEOcwQuaKQ.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image Credit: <a class="ae kv" href="https://unsplash.com/photos/8_NI1WTqCGY" rel="noopener ugc nofollow" target="_blank">Marcos Mayer / Unsplash</a></figcaption></figure><p id="d1cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我对web开发了解得越多，就越开始意识到异步代码的重要性。一旦你超越了静态网站，异步代码就变得不可或缺。每个全栈应用都依赖于通过API发送、接收和处理数据。</p><p id="4ea3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是编写异步代码和编写常规的同步JavaScript感觉非常不同。同步代码允许你做更多的事情。例如，同步代码中的操作顺序更宽松。结构混乱的代码仍然可以成功执行——即使这会让你的同事不高兴！</p><p id="0aec" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相比之下，异步代码的结构和顺序必须严格得多，在本文中，我们将看到如何做到这一点。我们将看看编写异步代码的三个主要系统，我还将分享一些使同步函数异步的方法。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="99f1" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">回调函数，尝试和捕捉</h1><p id="aac0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在JavaScript的早期，连续进行多个异步操作会导致所谓的末日金字塔，如下图所示。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="395f" class="nb ma iq mx b gy nc nd l ne nf">func1(function(result) {<br/>  func2(result, function(newResult) {<br/>    func3(newResult, function(finalResult) {<br/>      func4(newResult, function(finalResult) {<br/>        console.log(finalResult);<br/>      }, failureCallback);<br/>    }, failureCallback);<br/>  }, failureCallback);<br/>}, failureCallback);</span></pre><p id="56fd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这种情况也被称为回调地狱。随着异步操作数量的增加，跟踪正在发生的事情很快变得非常困难。</p><p id="bedb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">对于更简单的情况，指定失败回调也可以使用<code class="fe ng nh ni mx b">try</code>和<code class="fe ng nh ni mx b">catch</code>语句来处理，这在JavaScript早期就已经存在了。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="1a9f" class="nb ma iq mx b gy nc nd l ne nf">try {<br/>  asyncFunction();<br/>} <br/>catch (err) {<br/>  console.error(err);<br/>}</span></pre><p id="0286" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，对多个异步动作的需求会很快导致更糟糕的混乱！</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="cc1c" class="nb ma iq mx b gy nc nd l ne nf">try {<br/>  func1();<br/>  try {<br/>    func2();<br/>    try {<br/>      func3();<br/>    } catch {<br/>      failureFunc1();<br/>    }<br/>  } catch {<br/>    failureFunc2();<br/>  }<br/>} catch {<br/>  failureFunc3();<br/>}</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="3c91" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">承诺，然后抓住</h1><p id="47d0" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">ES6中出现了一个重大转变，引入了一个新对象:承诺。<code class="fe ng nh ni mx b">Promise</code>对象表示异步操作的完成或失败以及该操作的结果值。</p><p id="cea3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">可以使用<code class="fe ng nh ni mx b">new Promise()</code>构造函数创建一个<code class="fe ng nh ni mx b">Promise</code>。这需要一个带有两个参数的函数，如下面的例子所示:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="5a79" class="nb ma iq mx b gy nc nd l ne nf">const foo = new Promise(function(resolve, reject) {<br/>  setTimeout(function() {<br/>    resolve('bar');<br/>  }, 3000);<br/>});</span></pre><p id="44a6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们试图在<code class="fe ng nh ni mx b">Promise</code>被解决或拒绝之前调用<code class="fe ng nh ni mx b">console.log(foo)</code>，我们将简单地看到<code class="fe ng nh ni mx b">Promise {&lt;pending&gt;}</code>。</p><p id="6749" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是一旦动作完成，调用<code class="fe ng nh ni mx b">console.log(foo)</code>将返回一个包含值的Promise对象:在本例中为<code class="fe ng nh ni mx b">Promise {&lt;resolved&gt;}: "bar"</code>。</p><h2 id="dff8" class="nb ma iq bd mb nj nk dn mf nl nm dp mj lf nn no ml lj np nq mn ln nr ns mp nt bi translated">然后接住</h2><p id="4aea" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">为了对解决或拒绝的承诺执行后续操作，ES6还引入了两个新方法:<code class="fe ng nh ni mx b">then</code>和<code class="fe ng nh ni mx b">catch</code>。这可能会束缚我们最初的承诺。例如，要访问上面承诺<code class="fe ng nh ni mx b">foo</code>的结果，我们可以使用:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="65ff" class="nb ma iq mx b gy nc nd l ne nf">foo<br/>  .then(result =&gt; console.log(result)<br/>  .catch(err =&gt; console.error(err);</span></pre><p id="bbf4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ng nh ni mx b">then</code>承诺得到解决时触发，<code class="fe ng nh ni mx b">catch</code>承诺被拒绝时触发。这些方法可以根据需要链接多次。例如，使用<code class="fe ng nh ni mx b">fetch</code>请求JSON数据时的常见模式如下:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="b128" class="nb ma iq mx b gy nc nd l ne nf">fetch(myRequest)<br/>  .then(response =&gt; response.json())<br/>  .then(data =&gt; {<br/>    processData(data);<br/>  });</span></pre><p id="bf49" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一个<code class="fe ng nh ni mx b">then</code>方法中，我们使用<code class="fe ng nh ni mx b">json()</code>来读取和解析数据并将其返回。在下一个<code class="fe ng nh ni mx b">then</code>方法中，我们可以处理解析后的JSON数据。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4ab7" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">异步和等待</h1><p id="b54f" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在ES8中，异步代码变得更加方便，引入了两个新的关键字:<code class="fe ng nh ni mx b">async</code>和<code class="fe ng nh ni mx b">await</code>。</p><p id="90eb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个系统没有引入任何新的功能。相反，它提供了一个抽象层(或“语法糖”)，允许以非常类似于同步代码的方式编写异步代码。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="0706" class="nb ma iq mx b gy nc nd l ne nf">const foo = async () =&gt; {<br/>  const result = await new Promise(function(resolve, reject) {<br/>  setTimeout(function() {<br/>    resolve('bar');<br/>  }, 3000)<br/>  });<br/>  console.log(result);<br/>};</span></pre><p id="88f5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您可以使用<code class="fe ng nh ni mx b">async function() {}</code>定义一个异步函数，或者像上面的例子一样，使用<code class="fe ng nh ni mx b">const myFunctionName = async () =&gt; {}</code>定义一个异步函数。</p><p id="1ede" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe ng nh ni mx b">async</code>函数中，您可以使用<code class="fe ng nh ni mx b">await</code>关键字来暂停函数的执行，直到承诺得到解决。</p><p id="7637" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里是另一个例子，我们将使用<code class="fe ng nh ni mx b">fetch</code>发出GET请求，使用Github的API检索用户数据。不需要显式使用<code class="fe ng nh ni mx b">Promise</code>对象，因为这隐含在<code class="fe ng nh ni mx b">fetch</code>方法中:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="6c78" class="nb ma iq mx b gy nc nd l ne nf">const getUserData = async (user) =&gt; {<br/>  <!-- -->let response = await fetch(`https://api.github.com/users/${name}`);<br/>  let data = await response.json();<br/>  return data;<br/>}</span></pre><p id="154c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">async/await语法的唯一问题是，由于它与同步代码相似，很容易陷入同步思维模式。尤其是当我刚接触async/await时，我犯了一些错误，忘记了我正在处理的是承诺！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="f5ab" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">将同步功能变为异步功能</h1><p id="1455" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">让我们来看一个同步函数，它返回数组中每个值的和。</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="5bb5" class="nb ma iq mx b gy nc nd l ne nf">function sum(arr) {<br/>  return arr.reduce((x, y) =&gt; x + y);<br/>};</span></pre><p id="c831" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果我们的数组特别大，我们可能不希望这个函数阻止其他JavaScript代码执行。为了允许其他代码继续运行，我们需要使我们的函数异步。而要做<em class="nu">那个</em>，我们需要它来回报一个承诺。从ES8开始，最简单的方法就是添加<code class="fe ng nh ni mx b">async</code>关键字:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="121d" class="nb ma iq mx b gy nc nd l ne nf">async function sum(arr) {<br/>  return arr.reduce((x, y) =&gt; x + y);<br/>};</span></pre><p id="35a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是，如果我们想要更多地控制我们的承诺的执行呢？隐式地，<code class="fe ng nh ni mx b">async</code>关键字将我们的函数返回的任何内容转换成一个Promise对象，因此下面的函数与上面的函数具有大致相同的行为:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="594d" class="nb ma iq mx b gy nc nd l ne nf">const asyncSum = (arr) =&gt; {<br/>  return new Promise((resolve, reject) =&gt; {<br/>    resolve(arr.reduce((x, y) =&gt; x + y))<br/>  });<br/>};</span></pre><p id="8dc8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后我们可以调用这个函数，并使用上面描述的方法或关键字来定义进一步的动作，这取决于我们的承诺是否被成功返回。通常，如果我们使用React这样的库，我们可能希望在结果返回时更新状态:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="19a3" class="nb ma iq mx b gy nc nd l ne nf">asyncSum(veryLargeArray)<br/>  .then(result =&gt; {<br/>    <em class="nu">this</em>.setState({ sum: result });<br/>  });<br/>  .catch(err =&gt; console.log(err));</span></pre><p id="648d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，对于使用<code class="fe ng nh ni mx b">async</code>和<code class="fe ng nh ni mx b">await</code>的相同结果:</p><pre class="kg kh ki kj gt mw mx my mz aw na bi"><span id="d0bb" class="nb ma iq mx b gy nc nd l ne nf">(async () =&gt; {<br/>  const result = await asyncSum(veryLargeArray);<br/>  <em class="nu">this</em>.setState({ sum: result });<br/>})()</span></pre></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="4be8" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">奖励:异步冗余</strong></h1><p id="1456" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">最后，鉴于Redux的流行，我想我应该提到如何将Redux动作——默认情况下是同步的——转换成异步的。</p><p id="70c5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦你安装了<code class="fe ng nh ni mx b">redux</code>和<code class="fe ng nh ni mx b">react-redux</code>，你还需要安装中间件来允许你的动作创建者返回一个函数而不是一个动作。最受欢迎的选择是<code class="fe ng nh ni mx b">redux-thunk</code>。</p><p id="486a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要将Redux Thunk合并到您的Redux存储中，您可以使用以下样板代码:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="33ce" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">然后，您可以返回函数以及动作。下面是一个示例函数，它发出POST请求来创建一个项目:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nv nw l"/></div></figure><p id="c9f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">多亏了Redux Thunk，这个动作现在是‘thenable ’,这意味着我们可以执行一次进一步的动作——而且只能执行一次——结果被成功返回。我用Redux很少不实现Redux Thunk！</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="c49e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望这篇文章对你有用，不管你是承诺的新手还是想要复习。如有任何问题，欢迎留言评论！</p></div></div>    
</body>
</html>