<html>
<head>
<title>React.useMemo and when you should use it</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React.useMemo以及何时应该使用它</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-usememo-and-when-you-should-use-it-e69a106bbb02?source=collection_archive---------1-----------------------#2020-02-12">https://javascript.plainenglish.io/react-usememo-and-when-you-should-use-it-e69a106bbb02?source=collection_archive---------1-----------------------#2020-02-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/93bfda55bc1de63f1d8039c566eaa815.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*u5vgVgQIkItnTN_O.jpg"/></div></div></figure><p id="a6cc" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">随着应用程序的扩展，性能问题变得越来越明显。尽管React经过了很好的优化，开箱即用，但了解它提供的工具以使您的代码更快是很重要的。其中一种工具是<code class="fe kw kx ky kz b">React.useMemo</code>钩子和它的助手<code class="fe kw kx ky kz b">React.useCallback</code>。</p><h1 id="8720" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">useMemo解决什么问题？</h1><p id="27be" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated"><code class="fe kw kx ky kz b">useMemo</code>是一个记住函数输出的React钩子。就是这样。useMemo接受两个参数:一个函数和一个依赖列表。<code class="fe kw kx ky kz b">useMemo</code>会调用函数并返回其返回值。然后，每次你再次调用<code class="fe kw kx ky kz b">useMemo</code>时，它会首先检查是否有任何依赖关系发生了变化。如果不是，它将返回缓存的返回值，而不是调用函数。如果它们已经改变，<code class="fe kw kx ky kz b">useMemo</code>将再次调用提供的函数，并重复该过程。</p><p id="e127" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这应该让您想起了<code class="fe kw kx ky kz b">useEffect</code>钩子:<code class="fe kw kx ky kz b">useMemo</code>和<code class="fe kw kx ky kz b">useEffect</code>都接受依赖列表。唯一的区别是<code class="fe kw kx ky kz b">useEffect</code>是针对副作用的(因此得名)，而useMemo中的函数应该是纯净的，没有副作用。</p><h1 id="0378" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">你应该什么时候使用它？</h1><p id="6751" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">首先，重要的是要注意你的代码不能依赖于<code class="fe kw kx ky kz b">useMemo</code>。换句话说，您应该能够用直接的函数调用替换<code class="fe kw kx ky kz b">useMemo</code>调用，而不改变应用程序的任何行为，除了性能。最简单的方法是先写没有<code class="fe kw kx ky kz b">useMemo</code>的代码，然后根据需要添加。</p><p id="43fb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">要了解<code class="fe kw kx ky kz b">useMemo</code>以及何时应该使用它，请看这个例子。首先，看看这段没有<code class="fe kw kx ky kz b">useMemo</code>的代码:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4236" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">这个小程序可以让你输入你的名字和号码。然后它会问候你并显示斐波纳契数列的数字。如果您运行它，您会注意到如果我们更改名称或数字,<code class="fe kw kx ky kz b">NameDisplay</code>组件和<code class="fe kw kx ky kz b">FibDisplay</code>组件都将重新呈现(并运行昂贵的计算)。这是不可接受的，解决方法如下:</p><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="6e03" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">首先，注意<code class="fe kw kx ky kz b">FibDisplay</code>中<code class="fe kw kx ky kz b">useMemo</code>的使用。我们将昂贵的计算封装在一个函数中，该函数仅在<code class="fe kw kx ky kz b">length</code>改变时运行。组件仍将重新呈现，但除非需要，否则昂贵的计算不会运行。</p><p id="abb6" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">其次，注意到<code class="fe kw kx ky kz b">NameDisplay</code>组件用<code class="fe kw kx ky kz b">React.memo</code>包装。<code class="fe kw kx ky kz b">React.memo</code>是记忆整个构件的一种方法。只有当道具改变时，它才会重新渲染，从而彻底解决我们的问题。</p><h1 id="b22f" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">但是不要过度使用它</h1><p id="6c37" class="pw-post-body-paragraph jy jz iq ka b kb ly kd ke kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv ij bi translated">虽然优化性能是一项崇高的追求，但您应该始终考虑这样做的含义和副作用。在React.useMemo的情况下，有几个:</p><ol class=""><li id="6d8e" class="mj mk iq ka b kb kc kf kg kj ml kn mm kr mn kv mo mp mq mr bi translated"><strong class="ka ir">开销</strong>。挂钩本身引入了新的复杂逻辑，并且它可能引入比它解决的更多的性能问题。除非这是一个非常昂贵的计算，否则不要使用useMemo，或者，如果您不确定，您可以对两种方法进行基准测试并做出明智的决定。</li><li id="6bbb" class="mj mk iq ka b kb ms kf mt kj mu kn mv kr mw kv mo mp mq mr bi translated">没有担保。根据<a class="ae mx" href="https://reactjs.org/docs/hooks-reference.html#usememo" rel="noopener ugc nofollow" target="_blank">反应文件</a>，你可能永远不会依赖<code class="fe kw kx ky kz b">useMemo</code>上的内部机制。换句话说，虽然<code class="fe kw kx ky kz b">useMemo</code>应该只在依赖关系改变时被调用，但这是没有保证的。如果<code class="fe kw kx ky kz b">useMemo</code>在每次渲染时都调用你的回调函数，你的应用程序一定会运行得很好(虽然可能有点慢)。</li></ol><p id="b8e2" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">考虑到React.memo，所有这些问题同样适用。但是还有一点:<code class="fe kw kx ky kz b">React.memo</code>应该只适用于<a class="ae mx" href="https://medium.com/better-programming/working-with-react-pure-components-166ded26ae48" rel="noopener">纯组件</a>。另一个问题与Redux/Context和钩子有关。在钩子出现之前，Redux选择器通过props传递存储值，而<code class="fe kw kx ky kz b">React.memo</code>会捕获它们。然而，如果你使用的是<code class="fe kw kx ky kz b">useSelector/useContext</code>，当这些改变时<code class="fe kw kx ky kz b">React.memo</code>不会重新呈现你的组件。由于这些复杂性，我建议不要使用<code class="fe kw kx ky kz b">React.memo</code>，因为<code class="fe kw kx ky kz b">useMemo</code>在大多数情况下应该足够了。</p><h1 id="a44b" class="la lb iq bd lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx bi translated">奖励:使用回调</h1><figure class="md me mf mg gt jr"><div class="bz fp l di"><div class="mh mi l"/></div></figure><p id="4bdb" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">我注意到很多人对<code class="fe kw kx ky kz b">useCallback</code>感到困惑。<code class="fe kw kx ky kz b">useCallback</code>与useMemo非常相似，只是功能不同。其实<code class="fe kw kx ky kz b">useCallback(fn, deps)</code>相当于<code class="fe kw kx ky kz b">useMemo(() =&gt; fn, deps)</code>。<code class="fe kw kx ky kz b">useCallback</code>在使用lof回调函数时，除非依赖关系改变，否则不重新声明它们，这样可以加速应用程序。这是我们之前使用<code class="fe kw kx ky kz b">useCallback</code>的例子:</p><p id="e186" class="pw-post-body-paragraph jy jz iq ka b kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv ij bi translated">感谢您的阅读，希望您喜欢。请在评论中告诉我你对<code class="fe kw kx ky kz b">useMemo</code>的看法，并查看我的其他文章:</p><div class="my mz gp gr na nb"><a href="https://medium.com/javascript-in-plain-english/10-javascript-interview-questions-for-2020-697b40de9480" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">2020年10个JavaScript面试问题</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">随着对JS开发人员需求的增长，你必须做好准备。这里有10个问题可以帮助你…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nl l nm nn no nk np jw nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://medium.com/javascript-in-plain-english/7-really-good-reasons-not-to-use-typescript-166af597c466" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">不使用TypeScript的7个非常好的理由</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">有很多理由使用TypeScript，但我会给你7个不使用的理由。</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nq l nm nn no nk np jw nb"/></div></div></a></div><div class="my mz gp gr na nb"><a href="https://medium.com/javascript-in-plain-english/to-infinity-and-beyond-with-javascript-proxy-api-8d4f7a26c8dc" rel="noopener follow" target="_blank"><div class="nc ab fo"><div class="nd ab ne cl cj nf"><h2 class="bd ir gy z fp ng fr fs nh fu fw ip bi translated">使用JavaScript代理API无限超越</h2><div class="ni l"><h3 class="bd b gy z fp ng fr fs nh fu fw dk translated">代理API是一个高级的概念，但是如果你想掌握JavaScript，代理API是你绝对需要的…</h3></div><div class="nj l"><p class="bd b dl z fp ng fr fs nh fu fw dk translated">medium.com</p></div></div><div class="nk l"><div class="nr l nm nn no nk np jw nb"/></div></div></a></div><figure class="md me mf mg gt jr gh gi paragraph-image"><a href="http://eepurl.com/gYiA29"><div class="gh gi ns"><img src="../Images/446049aa060bbaea15a64e1a907b1030.png" data-original-src="https://miro.medium.com/v2/resize:fit:1240/format:webp/1*zWeFS3E1gbkEuBmpbvm6Rg.jpeg"/></div></a></figure></div></div>    
</body>
</html>