<html>
<head>
<title>Asynchronous Processing in JavaScript Loops</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript循环中的异步处理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/asynchronous-processing-in-javascript-loops-2acdbe674303?source=collection_archive---------2-----------------------#2020-09-20">https://javascript.plainenglish.io/asynchronous-processing-in-javascript-loops-2acdbe674303?source=collection_archive---------2-----------------------#2020-09-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cd8fb43c8f9ada6ecb60b1ca85347c14.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0WDPU39Cr1hnmYna"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@flowforfrank?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Ferenc Almasi</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="4946" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在过去的三年里，我一直在学习JavaScript及其不同的风格、框架和库。这种语言功能强大、有趣，并且有一个大型开源社区作为后盾。作为一名全栈JavaScript开发人员，您真正受到限制的只是您的想象力。</p><p id="8a1e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Node.js是JavaScript的一个<strong class="kc io">异步</strong>事件驱动运行时。它允许您构建具有高性能的高可伸缩性应用程序。Node.js高性能背后的秘密是，它违背了其他运行时、框架和语言中使用的常见并发模型。</p><p id="4411" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Node.js进程中的所有代码从头到尾都是按顺序执行的，但是，该进程只有一个线程，这意味着它只有一个调用堆栈和内存堆。简而言之，如果线程不是空闲的，代码执行会延迟到它空闲时。这是开发人员在构建应用程序时需要格外小心以避免性能瓶颈的地方。你应该始终遵循一条规则:<strong class="kc io">永远不要阻塞主线程！</strong></p><p id="13a9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">阻塞方法同步执行，而非阻塞方法异步执行。当阻塞方法消耗主线程并冻结整个进程时，它们就变得很危险。作为一个例子，考虑这样一个场景，一个API请求发送到一个web服务器，需要100毫秒才能完成。假设通过IO查询后端数据库需要90毫秒，处理数据并将数据返回给客户端需要10毫秒。通过选择对数据库的非阻塞异步查询操作，我们可以从主线程中释放90毫秒，让我们在后台做其他事情(比如处理第二个或第三个请求)，直到第一个请求的数据从数据库返回。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="58f7" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">同步环路</h1><p id="a1d4" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">所有开发人员都熟悉传统的for循环:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="f8aa" class="mr lg in mn b gy ms mt l mu mv">for (var i=0; i &lt; arr.length; i++) {<br/>    var item = arr[i];<br/>    // do something with item<br/>}</span></pre><p id="e518" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个循环简单、快速、同步，这意味着它将从头到尾遍历数组中的每个元素。因此，您应该避免在这个循环中有任何长时间运行的同步操作，因为它会冻结主线程。</p><p id="554a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">注意:编写这个完全相同的循环的更简洁的方法是使用forEach方法。</p><blockquote class="mw mx my"><p id="0305" class="ka kb mz kc b kd ke kf kg kh ki kj kk na km kn ko nb kq kr ks nc ku kv kw kx ig bi translated"><em class="in">以后想看这个故事吗？保存在</em> <a class="ae jz" href="https://usejournal.com/?utm_source=medium.com&amp;utm_medium=blog&amp;utm_campaign=noteworthy&amp;utm_content=eid7" rel="noopener ugc nofollow" target="_blank"> <em class="in">日记本</em> </a> <em class="in">。</em></p></blockquote><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="6d75" class="mr lg in mn b gy ms mt l mu mv">arr.forEach((item) =&gt; {<br/>    // do something with item<br/>});</span></pre></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="b044" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">异步循环</h1><p id="2ee7" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">作为ES7的一部分，Javascript引入了async/await函数的概念，允许开发人员编写看起来像同步代码的异步代码。</p><p id="5ae2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">以下是如何在循环中使用await的示例:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bb8f" class="mr lg in mn b gy ms mt l mu mv">async function printArray(array) {<br/>    array.forEach(async (item) =&gt; {<br/>        await doSomething(item);<br/>    )}<br/>    console.log('Done');<br/>}</span></pre><p id="0b35" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们有一个大问题。即使forEach方法是同步的，它实际上也不会等待doSomething方法完成，因为它是在异步匿名函数中异步调用的。正因为如此，程序执行将经过函数调用，并将首先记录“完成”。下面是为什么会发生这种情况的形象化描述:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi nd"><img src="../Images/e72073d1bdf818afc2addf0c55b30b07.png" data-original-src="https://miro.medium.com/v2/resize:fit:682/format:webp/1*NyyKVpnkOV5i8R5AV9HbUg.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Async forEach</figcaption></figure><p id="98cf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有一个简单的测试来证明我的意思:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="2fbb" class="mr lg in mn b gy ms mt l mu mv">function delay() {<br/>    return new Promise(resolve =&gt; setTimeout(resolve, 1000));<br/>}</span><span id="5869" class="mr lg in mn b gy ne mt l mu mv">async function delayedLog(item) {<br/>    await delay();<br/>    console.log(item);<br/>}</span><span id="daa5" class="mr lg in mn b gy ne mt l mu mv">async function printArray(array) {<br/>    array.forEach(async (item) =&gt; {<br/>        await delayedLog(item);<br/>    });<br/>    console.log('Done');<br/>}</span><span id="93b8" class="mr lg in mn b gy ne mt l mu mv">printArray([1, 2, 3]);</span></pre><p id="af5c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">delay函数只是返回一个Promise对象，该对象在1秒钟后解析。delayedLog函数在等待从delay函数返回的承诺解决后，记录传递给它的任何内容。这是前面代码块的输出:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="2401" class="mr lg in mn b gy ms mt l mu mv">Done<br/>1<br/>2<br/>3</span></pre><p id="283a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果阵列不需要顺序处理，这不是问题。这个用例的一个例子是您想要下载的一组文件。只要它们都被下载了，你真的不在乎它们以什么顺序被下载。但是，有时您希望在继续下一个操作之前完全处理异步操作。那么你是如何做到这一点的呢？</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="1403" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">绘图</h1><p id="13f0" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">将map函数与Promise.all结合起来，可以保证从map函数返回的所有承诺都在继续下一个操作之前得到解决。这里有一个如何使用它们的例子:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="cde6" class="mr lg in mn b gy ms mt l mu mv">async function printArray(array) {<br/>    await Promise.all(array.map(async (item) =&gt; {<br/>        await delayedLog(item);<br/>    }));<br/>    console.log('Done');<br/>}</span></pre><p id="7f64" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这一次，我们得到了我们期望的结果:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="dc9d" class="mr lg in mn b gy ms mt l mu mv">1<br/>2<br/>3<br/>Done</span></pre><p id="ef6f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是，需要注意的是，在这个场景中，尽管我们在进入下一个操作之前处理了数组中的所有内容，但是我们并没有按顺序处理数组。以下是Promise.all是如何解决的形象化视图:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/73f7ad5dd7c0538a9899d434f8b17eae.png" data-original-src="https://miro.medium.com/v2/resize:fit:586/format:webp/1*Z_sfkVS-XwMCkzeSqs6Q8w.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Async forEach with map</figcaption></figure><p id="0f5a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">map()方法返回了以不确定方式解析的承诺数组。Promise.all()唯一保证的是它们都已解决。而不是他们解决的顺序。那么，如果我们想要对集合中的异步操作进行真正的顺序处理呢？</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="3670" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">减低</h1><p id="17f4" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">array reduce方法获取一组项目，并将其缩减为一个值，如下所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3283" class="mr lg in mn b gy ms mt l mu mv">let result = [1, 2, 3].reduce((previous, item) =&gt; {<br/>    return previous + item;<br/>}, 0); // the initial value<br/>console.log(result) // 6</span></pre><p id="db18" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们可以对异步承诺使用同样的方法，如下所示:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="bb26" class="mr lg in mn b gy ms mt l mu mv">async function printArray(array) {<br/>    await array.reduce(async (previousPromise, item) =&gt; {<br/>        await previousPromise;<br/>        return delayedLog(item);<br/>    }, Promise.resolve());<br/>}</span></pre><p id="49cc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是怎么回事？这种方法背后有两个关键思想。首先，当用于顺序解析承诺时，reduce()循环根本不会变慢。它完全同步运行，速度和主线程让它运行的一样快。其次，每次异步匿名回调触发时，它返回一个承诺，该承诺解析为另一个承诺。由于reduce()为开发人员提供了在每次运行后将对象传递回同一个回调的能力，我们可以构建一个连续的承诺链。如果我们展开reduce循环，它实际上会像这样:</p><pre class="mi mj mk ml gt mm mn mo mp aw mq bi"><span id="3e13" class="mr lg in mn b gy ms mt l mu mv">new Promise( (resolve, reject) =&gt; {<br/>  // Promise #1<br/>  <br/>  resolve();<br/>}).then( (result) =&gt; { <br/>  // Promise #2<br/>  <br/>  return result;<br/>}).then( (result) =&gt; { <br/>  // Promise #3<br/>  <br/>  return result;<br/>}); // ...</span></pre><p id="a917" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">视觉上，承诺是这样解决的:</p><figure class="mi mj mk ml gt jo gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/8e33244c8cd27b20e178b4909f8d8f3c.png" data-original-src="https://miro.medium.com/v2/resize:fit:666/format:webp/1*bPJg6tZUM0qPVkObA4vs0A.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Async forEach with reduce</figcaption></figure><p id="2954" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这样，数组元素被一个接一个地按顺序处理，程序执行等待整个数组完成后再继续。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h1 id="b9d1" class="lf lg in bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">结论</h1><p id="2a9b" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">JavaScript中有多种异步处理集合的方法。这两种方法的区别取决于时间的要求。如果想在没有计时要求的元素上运行函数，请使用forEach他们最终会执行。如果您想确保在继续之前处理好这些元素，请使用地图。最后，如果你想一个接一个地处理元素，使用reduce。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><h2 id="41ba" class="mr lg in bd lh nh ni dn ll nj nk dp lp kl nl nm lt kp nn no lx kt np nq mb nr bi translated">更多来自期刊</h2><p id="8533" class="pw-post-body-paragraph ka kb in kc b kd md kf kg kh me kj kk kl mf kn ko kp mg kr ks kt mh kv kw kx ig bi translated">有许多黑人创造者在科技领域做着令人难以置信的工作。这些资源为我们中的一些人提供了启示:</p><figure class="mi mj mk ml gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="0587" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="mz">更多内容尽在</em><a class="ae jz" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="mz">plain English . io</em></a></p></div></div>    
</body>
</html>