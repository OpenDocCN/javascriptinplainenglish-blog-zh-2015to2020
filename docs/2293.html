<html>
<head>
<title>Basic Building Blocks of JavaScript Design Patterns</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript设计模式的基本构件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/basic-building-blocks-of-javascript-design-patterns-340ae33a0f69?source=collection_archive---------10-----------------------#2020-06-08">https://javascript.plainenglish.io/basic-building-blocks-of-javascript-design-patterns-340ae33a0f69?source=collection_archive---------10-----------------------#2020-06-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/27f5873ae82b78ace34f05bc8265e598.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wjvrWQUvK3Wq_nAE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@koushikc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Koushik Chowdavarapu</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="7042" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">设计模式是任何好软件的基础。JavaScript程序也不例外。</p><p id="53ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将看看如何构建好的软件所基于的设计模式。</p><h1 id="91e5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">设计模式</h1><p id="ffe0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们应该遵循一些设计模式，这样我们就可以很好地组织我们的代码。</p><p id="205f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们的代码组织良好，那么现在或将来与他们一起工作都不会是一件痛苦的事。</p><h1 id="3233" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">面向对象编程的四大构件</h1><p id="a70c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">几乎所有好的设计模式都是基于4个构件的。他们应该具备以下条件。</p><h1 id="6efc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">抽象</h1><p id="b988" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">抽象是好的设计模式的组成部分之一。</p><p id="cf6e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是对我们如何处理问题的仔细考虑。</p><p id="c352" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">抽象不是一种编程技术。这是一种在应用面向对象技术之前将问题概念化的方法。</p><p id="7f1e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我们将程序分成自然片段的一种方式。</p><p id="110d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们不把我们的程序分成小的部分，我们在管理复杂性方面会有问题。</p><p id="1fad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是把程序分成小的、可重复使用的部分，这样我们就可以处理它们。</p><p id="5e4b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，我们可以用不同的方式划分程序。</p><p id="0405" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把它们分成不同的功能。所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8a82" class="mn lc iq mj b gy mo mp l mq mr">const speak = () =&gt; {<br/>  //...<br/>}</span></pre><p id="1955" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以在任何有它的地方调用它。</p><p id="5d20" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以把程序分成类。类是一种创建新对象的机制。</p><p id="8360" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4388" class="mn lc iq mj b gy mo mp l mq mr">class Animal {<br/>  //...<br/>}</span></pre><p id="3796" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe ms mt mu mj b">new</code>操作符调用它，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="8deb" class="mn lc iq mj b gy mo mp l mq mr">const animal = new Animal();</span></pre><p id="c5fb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以访问它的成员。假设它有<code class="fe ms mt mu mj b">speak</code>方法，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="96f6" class="mn lc iq mj b gy mo mp l mq mr">animal.speak();</span></pre><h1 id="f2aa" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">包装</h1><p id="ffd7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">封装是将方法和数据包装到一个对象中。</p><p id="56f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们希望这样做，这样不同的对象就不会太了解彼此。</p><p id="e3a7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样，我们就不会遇到项目在不应该被访问时被访问的问题。</p><p id="8dea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该尽可能地隐藏，以便对象之间的耦合尽可能地松散。</p><p id="eec6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它们是松散耦合的，那么当我们改变一个对象时，它破坏另一个对象的机会就低了。</p><p id="9822" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以把暴露给外界的东西分开。</p><p id="6aa2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">变化最大的部分可以隐藏起来，我们向外界公开一个变化不大的接口。</p><h1 id="9695" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">多态性</h1><p id="df99" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">多态性允许我们用不同的对象类型编写代码，我们可以决定在运行时我们希望它是哪个对象。</p><p id="55b2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript没有多态性，我们可以显式地将它们转换成我们想要的任何东西。</p><p id="17a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是由于JavaScript对象是动态的，我们可以动态地添加或删除属性。</p><p id="ad68" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们仍然可以用我们想要的方式改变我们的物体。</p><p id="b1e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以根据对象的类型来执行操作。</p><p id="cc03" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以动态地添加和删除属性。</p><p id="7a6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4017" class="mn lc iq mj b gy mo mp l mq mr">animal.run = () =&gt; {<br/>  //...<br/>}</span></pre><p id="0c3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在对象上定义新方法。</p><p id="2494" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以用<code class="fe ms mt mu mj b">Object.assign</code>或扩展语法来合并不同的对象。</p><p id="d8f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7ed9" class="mn lc iq mj b gy mo mp l mq mr">const obj = Object.assign({}, foo, bar);</span></pre><p id="13a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="eb57" class="mn lc iq mj b gy mo mp l mq mr">const obj = {...foo, ...bar };</span></pre><p id="e78d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">两行代码将<code class="fe ms mt mu mj b">foo</code>和<code class="fe ms mt mu mj b">bar</code>对象合并在一起。</p><p id="5d63" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">由于JavaScript的动态特性，我们不会为了多态性而直接将对象转换为不同的类型。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/88fa98a7209abcb082b3811373109c78.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yejpN-_rCMXYk8bl"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@boxedwater?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Boxed Water Is Better</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="e1c4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">遗产</h1><p id="2392" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">继承是指我们的对象继承另一个对象的属性和方法。</p><p id="53e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用JavaScript有几种方法可以做到这一点。</p><p id="561f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以对类或构造函数使用<code class="fe ms mt mu mj b">extends</code>关键字:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5e16" class="mn lc iq mj b gy mo mp l mq mr">class Animal {<br/>  //...<br/>}</span><span id="7dc5" class="mn lc iq mj b gy mw mp l mq mr">class Dog extends Animal {<br/>  //...<br/>}</span></pre><p id="a4ab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">extends</code>关键字表明我们继承了<code class="fe ms mt mu mj b">Dog</code>类中<code class="fe ms mt mu mj b">Animal</code>的成员。</p><p id="24ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当我们创建一个<code class="fe ms mt mu mj b">Dog</code>实例时，我们将在<code class="fe ms mt mu mj b">Dog</code>实例的<code class="fe ms mt mu mj b">__proto__</code>属性中看到<code class="fe ms mt mu mj b">Animal</code>成员。</p><p id="9875" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们创建对象文字，我们可以如下使用<code class="fe ms mt mu mj b">Object.create</code>方法:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f4ba" class="mn lc iq mj b gy mo mp l mq mr">const parent = {<br/>  foo: 1<br/>};</span><span id="a765" class="mn lc iq mj b gy mw mp l mq mr">const child = Object.create(parent);</span></pre><p id="3073" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我们运行上面的代码，<code class="fe ms mt mu mj b">child</code>就会在<code class="fe ms mt mu mj b">__proto__</code>属性中有<code class="fe ms mt mu mj b">foo</code>。</p><p id="e2d6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">__proto__</code>是当前对象的直接原型。</p><p id="e150" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">原型是一个模板对象，其他对象可以从中继承成员。</p><p id="791e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过直接访问来访问对象原型的属性。</p><p id="05f3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以我们可以写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="4d1c" class="mn lc iq mj b gy mo mp l mq mr">child.foo</span></pre><p id="6635" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">访问<code class="fe ms mt mu mj b">child</code>的<code class="fe ms mt mu mj b">foo</code>属性。</p><h1 id="37e8" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="f75a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">抽象、封装、多态和继承是面向对象设计模式的四个组成部分。</p><p id="7e38" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它们为我们提供了划分代码的清晰方法。当我们设计我们的程序时，我们应该记住这些。</p><h2 id="9a98" class="mn lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="3560" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>