<html>
<head>
<title>Amazing Parallax Effect in Pure JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">纯JavaScript中惊人的视差效果</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/amazing-parallax-effect-in-pure-js-hungry-turtle-code-e4663af35c9f?source=collection_archive---------15-----------------------#2020-11-05">https://javascript.plainenglish.io/amazing-parallax-effect-in-pure-js-hungry-turtle-code-e4663af35c9f?source=collection_archive---------15-----------------------#2020-11-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><h1 id="7e61" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">视差效果不一定是令人讨厌的</h1><p id="19f0" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated"><strong class="kk io"> <em class="lg">注意:</em> </strong> <em class="lg">这是系列文章的第一部分，我们将从想法和杂乱的代码到一个概括的抽象，我们将在NPM上发布为开源库</em></p><p id="aa6a" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我不想说谎，视差网站在某些圈子里没有最好的声誉，这是理所当然的。通常，视差效果是通过某种劫持用户在页面上的滚动位置来实现的。这只会导致可怕的经历，让许多人讨厌这个概念。然而，互联网上有很多这种效果的好例子。</p><p id="815d" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">一个好的parallax网站的关键是用户完全控制滚动，但是滚动的位置直接决定了页面上应该显示什么。换句话说，UI上显示的是滚动位置的纯函数。然后体验感觉很好。就好像在页面上滚动就像在视频时间轴上滑动一样。该网站成为互动视频类型体验的画布。</p><p id="b48c" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在这篇文章中，我想尝试使用纯JavaScript来创建这样的东西，只是为了展示做好它是多么简单。</p><h1 id="9672" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">我们会做什么？</h1><p id="e29e" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">这是我们将要做的:<a class="ae lm" href="https://hungryturtlecode.com/demos/parallaxbasic/" rel="noopener ugc nofollow" target="_blank">现场演示</a></p><p id="2632" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">您也可以查看视频教程的开头，快速浏览我们将要创建的内容。</p><p id="945f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">正如你所看到的，我们将创建一个非常有趣的3d视差效果，看起来像我们正在穿越一些山脉，一些移动的文本动画和一个典型的滚动视差。</p><p id="ef9a" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">当我第一次开始建立网站时，这种事情看起来非常困难，远远超出了我的能力范围。但是我在这里告诉你，这真的没有你想象的那么难。所以让我们开始吧。</p><h1 id="8afb" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">搭建出HTML和CSS</h1><p id="336f" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们将开始一个简单的HTML页面和一些CSS:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="105c" class="lw jl in ls b gy lx ly l lz ma">&lt;!DOCTYPE html&gt;<br/>&lt;html lang="en"&gt;<br/>&lt;head&gt;<br/>  &lt;meta charset="UTF-8"&gt;<br/>  &lt;title&gt;Turtle Parallax&lt;/title&gt;<br/>  &lt;link href="main.css" rel="stylesheet" /&gt;<br/>&lt;/head&gt;<br/>&lt;body&gt;<br/>  &lt;script src="index.js"&gt;&lt;/script&gt;<br/>&lt;/body&gt;<br/>&lt;/html&gt;</span><span id="4532" class="lw jl in ls b gy mb ly l lz ma">code<br/>* {<br/>  margin: 0;<br/>  padding: 0;<br/>}<br/><br/>body {<br/>  height: 5000px;<br/>}</span></pre><p id="9053" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io"> <em class="lg">注意:</em> </strong> <em class="lg">将主体高度设置为5000像素在这一点上是任意的，因为我们只是想要比屏幕高的东西，这样我们就有东西可以滚动了。这可以在以后变得更加清晰和精确，但是现在将其设置为某个随机的大值就可以了。</em></p><h1 id="6ed2" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">写一些JavaScript</h1><p id="203c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">您可能已经注意到我们在html中包含了一个到<code class="fe mc md me ls b">index.js</code>的链接，所以现在让我们创建它，并通过监听滚动事件开始。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="d15f" class="lw jl in ls b gy lx ly l lz ma">document.addEventListener('scroll', () =&gt; {<br/>  // do something on scroll<br/>  console.log('We are scrolling!');<br/>});</span></pre><p id="7bdc" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">现在，如果我们打开浏览器，我们可以稍微滚动一下，看看控制台输出:</p><figure class="ln lo lp lq gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mf"><img src="../Images/b90ed549324f4204cf1fbd41cef2ef41.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Vu5z3PB_IO4JUW5U.png"/></div></div></figure><p id="fe8d" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io"> <em class="lg">注:</em> </strong> <em class="lg">为了方便起见，我喜欢使用一个名为</em> <code class="fe mc md me ls b"><em class="lg">live-server</em></code> <em class="lg">的npm包，它让我在开发时可以实时重新加载浏览器。你可以使用</em> <code class="fe mc md me ls b"><em class="lg">npm install -g live-server</em></code> <em class="lg">全局安装它，然后在项目目录中运行</em> <code class="fe mc md me ls b"><em class="lg">live-server</em></code> <em class="lg">，index.html将在浏览器中弹出打开，为一些实时重载做好准备。</em></p><h1 id="1a15" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">我们需要一些html来处理</h1><p id="9d2c" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">在这一点上，我们有了一个基本的结构，我们可以听滚动，但我们需要在页面上的一些实际的html，让我们在滚动时进行操作。因此，让我们创建初始的山看起来的东西。</p><p id="a336" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在index.html的正文顶部插入以下内容:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="a95a" class="lw jl in ls b gy lx ly l lz ma">&lt;div id="app"&gt;<br/><br/>  &lt;div class="fixed-section firstpage"&gt;<br/><br/>    &lt;h1 class="heading"&gt;Hungry Turtle Code&lt;/h1&gt;<br/><br/>    &lt;div class="background"&gt;<br/>      &lt;div class="bg-block"&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/><br/>    &lt;div class="middleground"&gt;<br/>      &lt;div class="mg-block"&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/><br/>    &lt;div class="foreground"&gt;<br/>      &lt;div class="fg-block"&gt;&lt;/div&gt;<br/>    &lt;/div&gt;<br/><br/>  &lt;/div&gt;<br/><br/>&lt;/div&gt; &lt;!-- end of #app --&gt;</span></pre><p id="aade" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">因此，我们为整个应用程序创建了一个容器，我们给它的id是<code class="fe mc md me ls b">app</code>，在这个容器中，我们为应用程序的“第一页”创建了另一个包装器，这将是mountain fly through部分。里面有一个标题和三个部分:背景、中间地带和前景。每一个里面都有另一个div，它将是实际的“mountain-y”部分。</p><p id="b2b6" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们在每个部分中都有一个div的原因是，我们可以有一个统一的锚点来操作所有不同的部分。我的意思是，所有的“山”部分都在不同的地方，所以如果我们没有将每个部分包装在一个容器中，它们都将有不同的锚点，如果我们开始扩展或转换它们，将会变得一团糟，以保持一切一致。</p><p id="7680" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">取而代之的是，我们将每一个包裹在一个容器中，这个容器的大小相当于整个窗户的大小。现在，我们可以自由地将每个元素放在容器中我们想要的任何位置，并简单地相对于容器调整它的大小。当需要操作和变换每个部分时，我们可以操作容器(它们都是窗口的大小，因此具有相同的定位点),因此一切都保持一致，我们不必处理不同定位点的混乱。</p><p id="b20f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io">可能在视频中说明这一点，并链接到文章中的时间戳</strong></p><p id="6440" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这是使用的CSS:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="259b" class="lw jl in ls b gy lx ly l lz ma">#app {                                <br/>  position: fixed;    <br/>  top: 0;           <br/>  left: 0;                  <br/>  width: 100%;            <br/>  height: 100%; <br/>}<br/><br/>.fixed-section {<br/>  position: fixed;<br/>  top: 0;            <br/>  bottom: 0;         <br/>  left: 0;     <br/>  right: 0;                <br/>  background: #71b1d9;<br/>  z-index: 2; <br/>}                     <br/><br/>.background,<br/>.middleground,<br/>.foreground {<br/>  position: absolute;<br/>  top: 0;<br/>  bottom: 0;<br/>  left: 0;<br/>  right: 0;<br/>}<br/>                     <br/>.bg-block {<br/>  background: #c3af9d;<br/>  position: absolute;<br/>  bottom: -10vh;<br/>  left: 0;<br/>  width: 100%;<br/>  height: 40vh;<br/>  transform: skewY(-2deg);<br/>}<br/><br/>.mg-block {<br/>  background: #ab805c;<br/>  position: absolute;<br/>  bottom: -45vh;<br/>  left: -30vw;<br/>  width: 100%;<br/>  height: 40vh;<br/>  transform: skewY(40deg);<br/>}<br/><br/>.fg-block {<br/>  background: #6d5a44;<br/>  position: absolute;<br/>  bottom: -45vh;<br/>  left: 0;<br/>  width: 100%;<br/>  height: 60vh;<br/>  transform: skewY(-20deg);<br/>}<br/><br/>.heading {<br/>  position: absolute;<br/>  font-size: 5vw;<br/>  left: 26vw;<br/>  bottom: 24vw;<br/>}<br/><br/>.firstpage h1 {<br/>  color: #f4f4f4;<br/>}</span></pre><p id="764a" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这里的核心是整个首页部分的位置是固定的，所以滚动实际上不会影响元素。每一个“山”部分都是div，它们已经被着色并使用倾斜变换进行了变换，以使它们成角度。剩下的只是将元素放置在正确的位置。</p><p id="283f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">所以现在我们有了以下内容:</p><figure class="ln lo lp lq gt mg gh gi paragraph-image"><div role="button" tabindex="0" class="mh mi di mj bf mk"><div class="gh gi mn"><img src="../Images/df3b138d956a2798e4000add04d8d6d8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*4eQxTMOlCwE6CtD_.png"/></div></div></figure><h1 id="6309" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">让它动起来！</h1><p id="b8e7" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">我们有一些html山-y的东西，我们可以听滚动。让我们在滚动的时候操作html。</p><p id="3549" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">首先，我们需要获取对我们想要操作的元素的引用。因此，将以下内容添加到您的<code class="fe mc md me ls b">index.js</code>脚本的顶部:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="2d21" class="lw jl in ls b gy lx ly l lz ma">const fg = document.querySelector('.foreground');<br/>const mg = document.querySelector('.middleground');<br/>const bg = document.querySelector('.background');<br/>const title = document.querySelector('.firstpage h1');</span></pre><p id="a314" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">然后，在滚动事件侦听器中，我们希望获得总滚动偏移量，并定义穿过山脉的缩放动画的长度。这个长度将是一个像素值。例如，如果我们将长度定义为500，那么动画将需要滚动500个像素才能完成。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="f4d1" class="lw jl in ls b gy lx ly l lz ma">document.addEventListener('scroll', () =&gt; {<br/>  const yoff = window.pageYOffset;<br/><br/>  const MOUNT_SCALE_END = 500;<br/>});</span></pre><p id="db84" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">紧接着我们将开始逻辑。我们将检查当前的滚动位置是否小于动画的结尾，如果是，我们将缩放山峰和标题。我们通过缩放离我们“近”的元素而不是“远”的元素来创造3d的幻觉。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="f81a" class="lw jl in ls b gy lx ly l lz ma">document.addEventListener('scroll', () =&gt; {<br/>  const yoff = window.pageYOffset;<br/><br/>  const MOUNT_SCALE_END = 500;<br/><br/>  if (yoff &lt; MOUNT_SCALE_END) {<br/>    const perc = yoff / MOUNT_SCALE_END; // how far through the animation are we?<br/>    fg.style.transform = `scale(${1 + 0.4 * perc})`;<br/>    mg.style.transform = `scale(${1 + 0.1 * perc})`; <br/>    bg.style.transform = `scale(${1 + 0.04 * perc})`;<br/>    title.style.transform = `scale(${1 + 0.35 * perc})`;<br/>  }<br/>});</span></pre><p id="3adb" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated"><strong class="kk io"> <em class="lg">注意:</em> </strong> <em class="lg">我们使用</em> <a class="ae lm" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" rel="noopener ugc nofollow" target="_blank"> <em class="lg">模板字符串</em> </a> <em class="lg">来允许我们轻松地将变量添加到字符串中，而不必做大量的字符串连接。</em></p><p id="e2ff" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们实际操作元素的第一件事是将<code class="fe mc md me ls b">pageYOffset</code>归一化，以表示通过将偏移量除以缩放山峰部分的末端而完成的动画的百分比。</p><p id="d9f6" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">一旦我们有了这个百分比，我们就可以用它来缩放不同的元素，方法是将百分比乘以某个常数，从而得到每个元素的不同缩放比例。</p><p id="427c" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">当我们开始滚动时，最终结果是一个美丽的视差缩放效果，当我们向下滚动页面达到500像素时就停止了。</p><h1 id="4db0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">第二节</h1><p id="dfe6" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">接下来要做的是添加第二部分。我要做的第一件事是创建一个淡出过渡，它将在后面引入第二部分。</p><p id="2f13" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们将改变<code class="fe mc md me ls b">.firstpage</code>元素的不透明度，所以我们需要抓住它。因此，在脚本的顶部添加以下内容:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="942c" class="lw jl in ls b gy lx ly l lz ma">const firstpage = document.querySelector('.firstpage');</span></pre><p id="fc5f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在我们创建的另一个名为<code class="fe mc md me ls b">MOUNT_SCALE_END</code>的定时常数下，我将在第二部分添加另一个标志过渡期结束的常数:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="b5a6" class="lw jl in ls b gy lx ly l lz ma">const TRANSITION_END = 800;</span></pre><p id="a9f5" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">然后，我们可以将else if语句添加到if块中，我们当前必须检查偏移量是否在转换的边界内:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="d4fc" class="lw jl in ls b gy lx ly l lz ma">if (yoff &lt; MOUNT_SCALE_END) {<br/>  // code from above<br/>} else if (yoff &lt; TRANSITION_END) {<br/>  const perc = (yoff - MOUNT_SCALE_END) / (TRANSITION_END - MOUNT_SCALE_END);<br/>  firstpage.style.opacity = `${1 - perc}`;<br/>}</span></pre><p id="bb5b" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">同样的想法在这里，我们计算百分比，我们通过过渡，并改变不透明度的基础上，该百分比。</p><p id="bb32" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这次百分比的计算有点复杂，因为过渡不是从0开始，而是从爬山部分的终点开始，所以我们必须从偏移中去掉<code class="fe mc md me ls b">MOUNT_SCALE_END</code>来得到起点，现在因为我们已经通过去掉<code class="fe mc md me ls b">MOUNT_SCALE_END</code>使起点正常化，我们也必须从终点去掉它。</p><p id="476c" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">现在，当我们向下滚动时，群山会慢慢消失。但是，我们希望第二部分显示下面，因为它褪色。现在让我们为该部分创建标记。</p><h1 id="0ca4" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">小问题</h1><p id="e48a" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果您修改浏览器中的滚动，您可能会注意到当前代码中的一个小问题。这个问题是，如果你向下滚动经过过渡，然后快速向上滚动，第一部分的不透明度可能不会一直回到1。这是因为你滚动得太快了，以至于在我们离开过渡代码回到缩放代码之前，滚动事件不能被足够快地调用来改变不透明度。</p><p id="fa0a" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">为了解决if语句中的这个问题，我们应该添加一些代码来使第一部分1不透明，以保证即使我们滚动得很快，它也会被重置。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="06c2" class="lw jl in ls b gy lx ly l lz ma">if (yoff &lt; MOUNT_SCALE_END) {<br/>  // rest of scaling code<br/><br/>  firstpage.style.opacity = '1';<br/>} else if (yoff &lt; TRANSITION_END) {<br/>  // transition code<br/>}</span></pre><h1 id="3529" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">第2节加价</h1><p id="8ffd" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">下面是要添加到首页标记下的html:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="919e" class="lw jl in ls b gy lx ly l lz ma">&lt;div class="fixed-section secondpage"&gt;<br/>  &lt;h1 class="heading"&gt;<br/>    &lt;span&gt;Hungry&lt;/span&gt;<br/>    &lt;span&gt;Turtle&lt;/span&gt;<br/>    &lt;span&gt;Code&lt;/span&gt;<br/>  &lt;/h1&gt;<br/>   &lt;imgsrc="https://res.cloudinary.com/djxscnpzf/image/upload/v1538571617/hungryturtle_high3_af4hyq.png"<br/>    class="turtlemascot"<br/>  &gt;<br/>&lt;/div&gt;</span></pre><p id="4101" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">如你所见，我们再次使用了<code class="fe mc md me ls b">.fixed-section</code>类，所以这将与第一页具有相同的基本样式。我们还重用了<code class="fe mc md me ls b">.heading</code>类，因为我们想让标题看起来和第二部分一样。</p><p id="abe4" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们将标题中的每个单词放入它自己的范围，这样我们就可以挂钩到每个单词，并在以后单独转换它们。</p><p id="36eb" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们还将添加以下额外样式:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="51da" class="lw jl in ls b gy lx ly l lz ma">.secondpage {<br/>  background: #cabaad;<br/>}<br/><br/>.secondpage h1 {<br/>  color: #fdeabf;<br/>  transform: scale(1.35);<br/>}<br/><br/>.secondpage h1 span {<br/>  display: inline-block;<br/>}<br/><br/>.turtlemascot {<br/>  position: absolute;<br/>  width: 40vw;<br/>  left: 32vw;<br/>  bottom: 17vw;<br/>  transform: scale(0);<br/>}</span></pre><p id="9eba" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">这里需要注意的是，我们将h1的比例设置为1.35。为什么？在第一部分中，我们正在缩放标题，缩放比例使用常数0.35，这意味着在动画结束时，标题被缩放到1.35。我们希望第二页中的标题与第一页中的标题完全匹配，所以我们需要将其缩放到1.35，以便匹配。乌龟吉祥物也是从0开始缩放，所以它可以随着滚动而放大。</p><h1 id="ebdc" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">动画标题</h1><p id="5a45" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">首先，我们需要理解JavaScript中的标题:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="012b" class="lw jl in ls b gy lx ly l lz ma">const titleParts = document.querySelectorAll('.secondpage h1 span');</span></pre><p id="4b37" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">你大概可以知道此时会发生什么。我们需要将标题动画的结尾指定为一个常量，然后添加另一个else if来检查我们是否在标题过渡动画边界内。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="3d1e" class="lw jl in ls b gy lx ly l lz ma">// Other constants defined here<br/>const WORD_SPLIT_END = 2300;<br/><br/>if (yoff &lt; MOUNT_SCALE_END) {<br/>  // Mountain scaling code<br/>} else if (yoff &lt; TRANSITION_END) {<br/>  // Transition code<br/>} else if (yoff &lt; WORD_SPLIT_END) {<br/>  const offset = yoff - TRANSITION_END;<br/>  titleParts[0].style.transform = `translate3d(0, -${offset}px, 0)`;<br/>  titleParts[1].style.transform = `translate3d(0, 0, 0)`;<br/>  titleParts[2].style.transform = `translate3d(0, ${offset}px, 0)`;<br/><br/>  if (offset &gt; 300) {<br/>    titleParts[1].style.transform = `translate3d(-${offset - 300}px, 0, 0)`;<br/>  }<br/>}</span></pre><p id="be23" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">像往常一样，我们通过减去前一部分的结尾来标准化偏移量，然后使用该值来转换<code class="fe mc md me ls b">translate3d</code>属性。请注意，我们最初没有对标题的中间部分做任何事情，但是如果标准化的偏移量大于300，那么我们开始移动中间部分。这就是我们如何延迟中间部分的动画，正如你在演示中看到的。</p><h1 id="1df3" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">给乌龟称重</h1><p id="fc29" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">参考海龟的形象:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="ebd7" class="lw jl in ls b gy lx ly l lz ma">const mascotimg = document.querySelector('.turtlemascot');</span></pre><p id="8190" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">然后通过比例计算百分比，并使用该百分比更新比例:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="412c" class="lw jl in ls b gy lx ly l lz ma">if (yoff &lt; MOUNT_SCALE_END) {<br/>  // Mountain scaling code<br/>} else if (yoff &lt; TRANSITION_END) {<br/>  // Transition code<br/>} else if (yoff &lt; WORD_SPLIT_END) {<br/>  // Rest of title animation<br/><br/>  if (offset &gt; 500) {<br/>    const perc = Math.min(<br/>      1, <br/>      (offset - 500) / (WORD_SPLIT_END - TRANSITION_END - 500)<br/>    );<br/>    mascotimg.style.transform = `scale(${1.2 * perc})`;<br/>  }<br/>}</span></pre><p id="c19a" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">同样，这里的百分比计算有点复杂。最终，它只是偏移除以动画的长度。偏移量就是我们之前的值，动画的持续时间是通过从当前部分的结尾减去前一部分的结尾来计算的。然而，因为我们只是从500像素开始，我们需要从两边减去500。然后我们将这个值加上1，以确保我们永远不会得到大于1的值。</p><h1 id="0755" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">第三节</h1><p id="62e2" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">第三部分也是最后一部分更像是传统的视差滚动。</p><p id="f290" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">以下是标记:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="62c9" class="lw jl in ls b gy lx ly l lz ma">&lt;div class="thirdpage"&gt;<br/>  &lt;div class="progress-line"&gt;<br/>  &lt;/div&gt;<br/><br/>  &lt;div class="title"&gt;<br/>    &lt;h2&gt;Hello Parallax&lt;/h2&gt;<br/>  &lt;/div&gt;<br/><br/>  &lt;div class="imgs"&gt;<br/>    &lt;img class="img img1" src="https://placekitten.com/g/400/400"&gt;<br/>    &lt;img class="img img2" src="https://placekitten.com/g/400/500"&gt;<br/>  &lt;/div&gt;<br/><br/>  &lt;div class="bottom-sect"&gt;&lt;/div&gt;<br/>&lt;/div&gt;</span></pre><p id="a652" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">和CSS:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="b0e8" class="lw jl in ls b gy lx ly l lz ma">.thirdpage {         <br/>  transform: translate3d(0, 100vh, 0);<br/>  background: #231f20;<br/>  padding-top: 50px;     <br/>}              <br/><br/>.thirdpage .title {       <br/>  display: flex;     <br/>  align-items: center;  <br/>  justify-content: center;<br/>  font-size: 2vw;     <br/>}                    <br/><br/>.thirdpage .imgs {   <br/>  margin: 100px 0;<br/>  position: relative;<br/>}              <br/>                           <br/>.img {     <br/>  position: absolute; <br/>  display: block;    <br/>  top: 10vw;         <br/>}                <br/>              <br/>.img1 {         <br/>  left: calc(50vw - 350px);<br/>}            <br/><br/>.img2 {           <br/>  left: calc(50vw - 50px);<br/>  top: 16vw;          <br/>}                    <br/>                                      <br/>.thirdpage .title h2 {<br/>  color: #c2c2c2;        <br/>} <br/><br/>.bottom-sect {<br/>  height: 1000px;<br/>}<br/><br/>.progress-line {<br/>  position: absolute;<br/>  width: 2px;<br/>  background: red;<br/>  height: 100%;<br/>  left: 5vw;<br/>  top: 0;<br/>  transform: translate3d(0, -100%, 0);<br/>  z-index: 0;<br/>}</span></pre><p id="6927" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">像往常一样，我们将不得不抓住我们想要操纵的元素。在这种情况下，我们显然需要抓取我们要视差的图像，但我们也要抓取整个应用程序容器。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="6ff6" class="lw jl in ls b gy lx ly l lz ma">const app = document.querySelector('#app');<br/>const imgs = document.querySelectorAll('.imgs .img')<br/>const progressLine = document.querySelector('.progress-line');</span></pre><p id="3c15" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">为了使这部分滚动，我们需要做一些欺骗。这样做的原因是前两个部分已经被<code class="fe mc md me ls b">position: fixed</code>了，因为我们希望它们在我们滚动时保持不动，并且只对其中的元素进行动画处理。不过现在我们希望一切都滚动，包括定位第二部分。</p><p id="48b9" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">实现这一点的最好方法是让整个应用程序容器固定位置(我们实际上已经在上面这样做了，卑鄙吧？)然后以与窗口滚动相同的速度平移3d应用程序容器的位置。这会给人一种视觉上的感觉，我们实际上是在滚动，而我们实际上只是以与滚动相同的速度平移容器。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="c71e" class="lw jl in ls b gy lx ly l lz ma">const END_OF_PAGE = 3450;<br/><br/>if (yoff &lt; MOUNT_SCALE_END) {<br/>  // Mountain scaling code<br/>} else if (yoff &lt; TRANSITION_END) {<br/>  // Transition code<br/>} else if (yoff &lt; WORD_SPLIT_END) {<br/>  // Title animation code<br/>} else if (yoff &lt; END_OF_PAGE) {<br/>  const offset = yoff - WORD_SPLIT_END;<br/>  const duration = END_OF_PAGE - WORD_SPLIT_END;<br/><br/>  app.style.transform = `translate3d(0, -${offset}px, 0)`;<br/>  imgs[0].style.transform = `translate3d(0, -${offset * 0.1}px, 0)`;<br/>  imgs[1].style.transform = `translate3d(0, -${offset * 0.25}px, 0)`;<br/>}</span></pre><p id="ccbc" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">此时，您应该对上面的代码非常熟悉。我们通过减去前一部分的结尾，将总偏移量归一化为该部分的偏移量。然后，我们通过从当前部分的末尾减去上一部分的末尾来计算滚动的持续时间。将很快使用持续时间。</p><p id="e229" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">然后，计算出的偏移量被用来翻译应用程序容器，以模拟如上所述的滚动。我们也用两个不同的常数乘以偏移量来平移每张图片。通过使用两个不同的值，我们创建了视差效果，因为每个图像以不同的速度移动。</p><h1 id="26a0" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">进度条</h1><p id="6d02" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">现在要做的最后一件事是添加跟踪视差滚动部分进度的红色条。</p><p id="d679" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们不想立即触发进度条，所以我们将使用与上面徽标缩放代码相似的逻辑。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="8743" class="lw jl in ls b gy lx ly l lz ma">if (yoff &lt; MOUNT_SCALE_END) {<br/>  // Mountain scaling code<br/>} else if (yoff &lt; TRANSITION_END) {<br/>  // Transition code<br/>} else if (yoff &lt; WORD_SPLIT_END) {<br/>  // Title animation code<br/>} else if (yoff &lt; END_OF_PAGE) {<br/>  // rest of scrolling code<br/><br/>  const progressTrigger = duration * 0.2;<br/><br/>  if (offset &gt; progressTrigger) {<br/>    const progressDur = duration - progressTrigger;<br/>    const progressOff = offset - progressTrigger;<br/>    const progress = Math.min(1, progressOff / progressDur) * 100;<br/>    progressLine.style.transform = `translate3d(0, -${100 - progress}%, 0)`;<br/>  } else {<br/>    progressLine.style.transform = `translate3d(0, -100%, 0)`;<br/>  }<br/>}</span></pre><p id="9a6c" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">在这里，我们计算进度条的偏移量和持续时间，然后计算用于转换div的进度百分比(在CSS中转换为100%)。我们添加else块以确保当我们在进度条动画的边界之外时，我们重置进度条位置的状态。这是一个类似于我们之前展示的关于滚动太快和没有正确重置第一部分的不透明度所造成的错误的修复。</p><h1 id="9cbf" class="jk jl in bd jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh bi translated">修复bug</h1><p id="d79b" class="pw-post-body-paragraph ki kj in kk b kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf ig bi translated">如果您在浏览器中修改网页并滚动，您会注意到，当我们快速滚动时，还有一些其他问题没有正确地重置元素状态。我们现在将清理这些bug。</p><p id="af5f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">您可能注意到的第一个问题是，如果我们快速向上滚动标题动画，我们不会将标题位置重置回0。为了解决这个问题，我们将在过渡部分将其重置为零，如下所示:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="2de4" class="lw jl in ls b gy lx ly l lz ma">} else if (yoff &lt; TRANSITION_END) {<br/>  titleParts[0].style.transform = `translate3d(0, 0, 0)`;<br/>  titleParts[2].style.transform = `translate3d(0, 0, 0)`;<br/>  titleParts[2].style.transform = `translate3d(0, 0, 0)`;<br/>}</span></pre><p id="e2f6" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">一个稍微微妙的错误是，如果你在第二或第三部分刷新页面，然后向上滚动到第一部分，当“山”部分的缩放开始时，会有一个闪光。这是因为比例从1开始，并在第一部分动画中放大到某个更大的值。然而，如果我们刷新第三部分中的页面，那么第一部分中的动画从未运行过，因此当我们在过渡阶段中向后滚动时，比例仍然为1，但是一旦我们再次点击第一部分动画，它将弹出更大的比例值。</p><p id="cecc" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">因此，在我们返回到过渡部分之前，我们需要将音阶重置为较大的值。我们还会将不透明度重置为0，以准备进入将转换回1的过渡。将此添加到word动画块:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="0c5c" class="lw jl in ls b gy lx ly l lz ma">} else if (yoff &lt; WORD_SPLIT_END) {<br/>  title.style.transform = `scale(1.35)`;<br/>  fg.style.transform = `scale(1.4)`;<br/>  mg.style.transform = `scale(1.1)`;<br/>  bg.style.transform = `scale(1.04)`;<br/>  firstpage.style.opacity = `0`; <br/><br/>  // rest of word animation code<br/>}</span></pre><p id="bf30" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">海龟形象也存在同样的问题。我们将它放大到1.2，但在下一节中不要将其重置为1.2，以避免我们向后滚动时可能出现的闪烁。</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="f35f" class="lw jl in ls b gy lx ly l lz ma">} else if (yoff &lt; END_OF_PAGE) {<br/>  mascotimg.style.transform = `scale(1.2)`;<br/><br/>  // rest of scrolling code<br/>}</span></pre><p id="a417" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">最后一个bug相当微妙，实际上可能没那么重要。问题是，我们只是通过将不透明度更改为0来从视图中删除第一页，但元素实际上仍然在那里，在页面上的所有其他内容之上，我们只是看不到它。这意味着，如果我们试图选择文本或其他东西，它不会工作，因为我们实际上是在点击不可见的第一页。</p><p id="668f" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们将通过以下方法解决此问题:当页面不在视图中时，使其不显示，当它重新出现在视图中时，将其更改为阻止显示:</p><pre class="ln lo lp lq gt lr ls lt lu aw lv bi"><span id="9e95" class="lw jl in ls b gy lx ly l lz ma">if (yoff &lt; MOUNTAIN_SCALE_END) {<br/>  // mountain scale code<br/>} else if (yoff &lt; TRANSITION_END) {<br/>  firstpage.style.display = 'block';<br/><br/>  // rest of transition code<br/>} else if (yoff &lt; WORD_SPLIT_END) {<br/>  firstpage.style.display = 'none';<br/><br/>  // rest of word animation code<br/>}</span></pre><p id="0b49" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">我们做到了！使用纯JavaScript完成了一个漂亮的视差效果(但是很粗糙)。我真的希望你喜欢它，我期待在<a class="ae lm" href="https://hungryturtlecode.com/projects/parallax-library/" rel="noopener ugc nofollow" target="_blank">的下一部分</a>看到你，我们将把这段代码，清理并转换成一个通用库，我们将发布到NPM，这样任何人都可以轻松地创建像这样的惊人视差网站！到时候见。</p><p id="bf7a" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">保持饥饿，继续编码。</p><p id="8b8a" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">艾德里安(男子名)</p><p id="230c" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">如果你喜欢这篇文章，请分享一下。每个人都需要那个<strong class="kk io">的好朋友</strong>给他们发送令人惊奇的东西。</p><figure class="ln lo lp lq gt mg"><div class="bz fp l di"><div class="mo mp l"/></div></figure><p id="cde0" class="pw-post-body-paragraph ki kj in kk b kl lh kn ko kp li kr ks kt lj kv kw kx lk kz la lb ll ld le lf ig bi translated">【https://hungryturtlecode.com】最初发表于<a class="ae lm" href="https://hungryturtlecode.com/projects/parallax-mountains/" rel="noopener ugc nofollow" target="_blank"><em class="lg"/></a><em class="lg">。</em></p></div></div>    
</body>
</html>