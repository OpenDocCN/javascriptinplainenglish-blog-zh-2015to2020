<html>
<head>
<title>How to use the Generator function* in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中使用生成器函数*</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-the-generator-function-in-javascript-6ab00380cc5f?source=collection_archive---------0-----------------------#2020-03-12">https://javascript.plainenglish.io/how-to-use-the-generator-function-in-javascript-6ab00380cc5f?source=collection_archive---------0-----------------------#2020-03-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/bf2dc896b84fdc50e0a18722f950aee8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AjRxFCZ_9BOE_u1_t8FK0A.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@jayphen?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Jayphen Simpson</a> on <a class="ae jd" href="https://unsplash.com/?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><p id="ac74" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Function关键字后跟一个星号用于定义一个生成器函数，该函数返回一个<strong class="kf jh"> <em class="lb">生成器</em> </strong>对象。</p><p id="58d5" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><em class="lb">我们可以稍后退出并重新进入生成器功能。在重入的情况下，它们的上下文(变量绑定)将被保存。</em></p><p id="5293" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这里需要注意的重要一点是，调用一个生成器函数并不立即执行它的主体，事实上它返回的是这个函数的迭代器对象。</p><blockquote class="lc"><p id="de8e" class="ld le jg bd lf lg lh li lj lk ll la dk translated">简而言之，生成器看起来像一个函数，但它的行为像一个迭代器。</p></blockquote><h2 id="5950" class="lm ln jg bd lo lp lq dn lr ls lt dp lu ko lv lw lx ks ly lz ma kw mb mc md me bi translated">语法:</h2><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3f46" class="lm ln jg mk b gy mo mp l mq mr">function* generatorFunctionName([param[, param[, ... param]]]) {<br/>   statements<br/>}</span></pre><ul class=""><li id="6c6d" class="ms mt jg kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated"><strong class="kf jh"> <em class="lb">名称:</em> </strong>功能名称</li><li id="92d2" class="ms mt jg kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated"><strong class="kf jh"> <em class="lb"> param |可选:</em> </strong>函数的形参。</li><li id="d4d0" class="ms mt jg kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated"><strong class="kf jh"> <em class="lb">语句:</em> </strong>组成函数体。</li></ul><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="ce1f" class="lm ln jg mk b gy mo mp l mq mr">function* generator(i) {<br/>  yield i;<br/>  yield i + 1;<br/>}</span><span id="a488" class="lm ln jg mk b gy ng mp l mq mr">const gen = generator(1);<br/>console.log(gen.next().value);<br/>// expected output: 1</span><span id="0c1a" class="lm ln jg mk b gy ng mp l mq mr">console.log(gen.next().value);<br/>// expected output: 2</span></pre><p id="9ce3" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">只有当迭代器的<strong class="kf jh"> <em class="lb"> next() </em> </strong>方法被调用时，生成体才会被执行。执行一直进行到第一个yield表达式(用yield*指定从迭代器返回的值)委托给另一个生成器函数。</p><p id="1468" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> <em class="lb"> next() </em> </strong>方法以一个<strong class="kf jh"> <em class="lb"> Boolean </em> </strong>的形式返回一个对象，该对象的value属性包含生成的值，以及一个<strong class="kf jh"><em class="lb">【done】</em></strong>属性，该属性指示生成器是否已生成其最后一个值。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6e92" class="lm ln jg mk b gy mo mp l mq mr">{ <br/>  value: AnyValue,<br/>  done: true|false<br/>}</span></pre><p id="b1ea" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> <em class="lb">要恢复执行</em> </strong>的生成器功能，我们可以调用<strong class="kf jh"> <em class="lb"> next() </em> </strong>带参数的方法。此操作也将导致用来自<strong class="kf jh"> <em class="lb"> next() </em> </strong>的参数替换执行暂停处的yield表达式。</p><p id="2ccd" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> <em class="lb">要完成</em> </strong>生成器功能的执行，我们可以使用return语句。返回值将用于设置生成器返回的对象的value属性。在生成器函数内部抛出的任何异常，也会导致生成器结束，除非它已经被捕获到它的主体内部。</p><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi nh"><img src="../Images/9575564fd5a16698f48f83ef3996e70f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*idKr82ABbNTfHTvO.png"/></div></div></figure><p id="4fa2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> GeneratorFunction </strong>构造函数，或者函数表达式语法也可以用来定义<strong class="kf jh">生成器函数</strong>。然而，我们应该记住，发电机是不可建造的。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="9f86" class="lm ln jg mk b gy mo mp l mq mr">function* generatorFunction() {}<br/>var obj = new generatorFunction;</span><span id="ee83" class="lm ln jg mk b gy ng mp l mq mr">// Uncaught TypeError: generatorFunction is not a constructor</span></pre><p id="2065" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> <em class="lb">一旦生成器完成，</em> </strong>我们将无法使用后续的<strong class="kf jh"> <em class="lb"> next() </em> </strong>调用来执行生成器的任何代码。他们只会返回一个这样形式的对象:<strong class="kf jh"> <em class="lb"> {value: undefined，done: true}。</em> </strong>在下面的例子中，我们可以同样检查。</p><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="6b09" class="lm ln jg mk b gy mo mp l mq mr">function* generatorFunction() {<br/>  var index = 0;<br/>  while (true)<br/>  {<br/>    yield index++;<br/>      if(index &gt; 2)<br/>      {<br/>          return;<br/>      }<br/>  }<br/>}</span><span id="c5ea" class="lm ln jg mk b gy ng mp l mq mr">var gen = generatorFunction();</span><span id="04b5" class="lm ln jg mk b gy ng mp l mq mr">console.log(gen.next()); <br/>console.log(gen.next()); <br/>console.log(gen.next()); <br/>console.log(gen.next());</span><span id="d70f" class="lm ln jg mk b gy ng mp l mq mr"><strong class="mk jh">// Output --&gt;</strong><br/>{ value: 0, done: false }<br/>{ value: 1, done: false }<br/>{ value: 2, done: false }<br/>{ value: undefined, done: true }</span></pre><h2 id="7f97" class="lm ln jg bd lo lp ni dn lr ls nj dp lu ko nk lw lx ks nl lz ma kw nm mc md me bi translated">将参数传递给生成器:</h2><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="3ba4" class="lm ln jg mk b gy mo mp l mq mr">function* logGenerator(i) {<br/>    while(i &lt; 3)<br/>    {<br/>      console.log(i++, yield);  <br/>    }<br/>}</span><span id="aa75" class="lm ln jg mk b gy ng mp l mq mr">var gen = logGenerator(0);</span><span id="cc07" class="lm ln jg mk b gy ng mp l mq mr">// the first call of next executes from the start of the function<br/>// until the first yield statement<br/>gen.next();            <br/>gen.next('Logging Starts...');   <br/>gen.next('Logging Going On...'); <br/>gen.next('Logging Ends...');</span><span id="edae" class="lm ln jg mk b gy ng mp l mq mr"><strong class="mk jh">// Output --&gt;</strong><br/>0 Logging Starts...<br/>1 Logging Going On...<br/>2 Logging Ends...</span></pre><h2 id="6496" class="lm ln jg bd lo lp ni dn lr ls nj dp lu ko nk lw lx ks nl lz ma kw nm mc md me bi translated">使用产量*:</h2><pre class="mf mg mh mi gt mj mk ml mm aw mn bi"><span id="c199" class="lm ln jg mk b gy mo mp l mq mr">function* anotherGenerator(i) {<br/>  yield i + 10;<br/>  yield i + 20;<br/>  yield i + 30;<br/>}</span><span id="6714" class="lm ln jg mk b gy ng mp l mq mr">function* functionGenerator(i) {<br/>  yield i;<br/>  yield* anotherGenerator(i);<br/>  yield i + 1;<br/>}</span><span id="93eb" class="lm ln jg mk b gy ng mp l mq mr">var gen = functionGenerator(1);</span><span id="9298" class="lm ln jg mk b gy ng mp l mq mr">console.log(gen.next()); <br/>console.log(gen.next()); <br/>console.log(gen.next()); <br/>console.log(gen.next()); <br/>console.log(gen.next());</span><span id="4bc1" class="lm ln jg mk b gy ng mp l mq mr"><strong class="mk jh">// Output --&gt;</strong><br/>{ value: 1, done: false }<br/>{ value: 11, done: false }<br/>{ value: 21, done: false }<br/>{ value: 31, done: false }<br/>{ value: 2, done: false }</span></pre><p id="3a6b" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf jh"> <em class="lb">注意:</em> </strong> <em class="lb">我们还可以在</em> <strong class="kf jh"> <em class="lb">异步编程</em> </strong> <em class="lb">中使用</em> <strong class="kf jh"> <em class="lb">生成器函数</em> </strong> <em class="lb">，并承诺使用它们将减轻(如果不能完全消除)与</em><strong class="kf jh"><em class="lb"/></strong><em class="lb">有关的问题，例如回调地狱和控制反转。然而，我们也可以使用</em><strong class="kf jh"><em class="lb">async</em></strong><em class="lb">函数来做同样的事情，其实现将会简单得多。</em></p><h1 id="bb52" class="nn ln jg bd lo no np nq lr nr ns nt lu nu nv nw lx nx ny nz ma oa ob oc md od bi translated">浏览器兼容性</h1><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi oe"><img src="../Images/9d6915d770711e2f363cbf688688153a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UW2d17eCB3g06_qOZCozuw.png"/></div></div></figure><h1 id="f6fb" class="nn ln jg bd lo no np nq lr nr ns nt lu nu nv nw lx nx ny nz ma oa ob oc md od bi translated">结论</h1><ul class=""><li id="a833" class="ms mt jg kf b kg of kk og ko oh ks oi kw oj la mx my mz na bi translated">生成器是一类特殊的函数，它简化了编写迭代器的任务。</li><li id="bb96" class="ms mt jg kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">生成器是一个产生一系列结果而不是单个值的函数，即您<em class="lb">生成</em>一系列值。</li></ul><figure class="mf mg mh mi gt is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi ok"><img src="../Images/a8bb6af1fe0b5ec210728a8283dd91d6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1236/format:webp/0*JCCcGKtOTLRIU6fP.png"/></div></div></figure><p id="cbb2" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">暂时就这样了。在下面的文章中，我已经介绍了更多关于生成器功能的内容，比如用例、优点等等…</p><p id="473e" class="pw-post-body-paragraph kd ke jg kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae jd" href="https://medium.com/javascript-in-plain-english/how-to-use-the-generator-function-in-javascript-continued-aada07d220c7" rel="noopener">如何在JavaScript中使用生成器函数*(续…) </a></p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><h2 id="2ef3" class="lm ln jg bd lo lp ni dn lr ls nj dp lu ko nk lw lx ks nl lz ma kw nm mc md me bi translated">参考</h2><p id="1feb" class="pw-post-body-paragraph kd ke jg kf b kg of ki kj kk og km kn ko os kq kr ks ot ku kv kw ou ky kz la ij bi translated">Mozilla MDN <br/>代码爆发</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><h2 id="b8cc" class="lm ln jg bd lo lp ni dn lr ls nj dp lu ko nk lw lx ks nl lz ma kw nm mc md me bi translated"><strong class="ak">用简单英语写的JavaScript的注释:</strong></h2><p id="f5ad" class="pw-post-body-paragraph kd ke jg kf b kg of ki kj kk og km kn ko os kq kr ks ot ku kv kw ou ky kz la ij bi translated">我们总是有兴趣帮助推广高质量的内容。如果你有一篇文章想用简单的英语提交给JavaScript，用你的中级用户名发邮件到submissions@javascriptinplainenglish.com<a class="ae jd" href="mailto:submissions@javascriptinplainenglish.com" rel="noopener ugc nofollow" target="_blank">给我们，我们会把你添加为作者。</a></p></div></div>    
</body>
</html>