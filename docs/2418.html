<html>
<head>
<title>Simple shop app using Node.js and React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Node.js和React的简单商店应用程序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/simple-shop-app-using-node-js-and-react-d7b4f50e26c?source=collection_archive---------2-----------------------#2020-06-22">https://javascript.plainenglish.io/simple-shop-app-using-node-js-and-react-d7b4f50e26c?source=collection_archive---------2-----------------------#2020-06-22</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/6ab37a6f4cc3bed6bf8a30fa0acc1bbf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*7IiaCMe_UlBjaJCn"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@autthaporn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Mr.Autthaporn Pradidpong</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6c42" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我做前端开发已经快6年了，在这段时间里，我意识到对一个项目的后端和前端都有一个清晰的印象将有助于对它有一个整体的理解。几个月前，我决定学习一些后端技能，主要是因为我想成为一名更独立的开发人员，并对我可能参与的任何项目的业务逻辑有更好的理解。</p><p id="b57d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我从Scott Moss主持的一个关于frontendmasters的课程开始，在这个课程中，他详细解释了如何使用Express(一个Node.js框架)创建一个简单且可测试的API，以及一些最佳实践，还有一些特定的技术，比如jwt和Mongo。</p><div class="ky kz gp gr la lb"><a href="https://frontendmasters.com/courses/api-design-nodejs-v3/" rel="noopener  ugc nofollow" target="_blank"><div class="lc ab fo"><div class="ld ab le cl cj lf"><h2 class="bd io gy z fp lg fr fs lh fu fw im bi translated">学习用Express和MongoDB在Node.js - Model数据和REST APIs中构建API</h2><div class="li l"><h3 class="bd b gy z fp lg fr fs lh fu fw dk translated">使用Express在Node.js中构建一个REST API——处理REST API动词方法来创建、读取、更新和删除资源…</h3></div><div class="lj l"><p class="bd b dl z fp lg fr fs lh fu fw dk translated">frontendmasters.com</p></div></div><div class="lk l"><div class="ll l lm ln lo lk lp jt lb"/></div></div></a></div><p id="2377" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我将解释一些初始步骤，并更深入地研究对我来说也是新的东西。</p><p id="41e2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了创建一个节点应用程序，我们将创建一个新文件夹，并在终端中为该文件夹运行<code class="fe lq lr ls lt b">npm init</code>,并按照初始步骤进行设置。</p><p id="ebdc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完成这些步骤后，创建一个名为<code class="fe lq lr ls lt b">index.js</code>的新文件，我们将在其中编写代码。使用Express启动一个简单的应用程序只需:</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div class="gh gi lu"><img src="../Images/14966d32f8397f243e7b0b93eeb05567.png" data-original-src="https://miro.medium.com/v2/resize:fit:964/format:webp/1*O962n9A6rpGQIL8PMgTPig.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Express `Hello World` app</figcaption></figure><p id="fdac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">假设我们想要创建一个API，让我们对数据库中的一些产品执行所有CRUD操作，就像一个在线商店一样。</p><p id="59d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从体系结构的角度来看，我们可以将其分为三个主要的资源类别或类型:</p><ul class=""><li id="c57e" class="lz ma in kc b kd ke kh ki kl mb kp mc kt md kx me mf mg mh bi translated">模型——实体在数据库中的形式</li><li id="1aea" class="lz ma in kc b kd mi kh mj kl mk kp ml kt mm kx me mf mg mh bi translated">控制器——这里我们定义了可以在数据库中的实体上执行的不同操作</li><li id="f10a" class="lz ma in kc b kd mi kh mj kl mk kp ml kt mm kx me mf mg mh bi translated">路由器—将每条路由与适当的控制器相关联</li></ul><h1 id="08db" class="mn mo in bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated"><strong class="ak">数据库</strong></h1><p id="1004" class="pw-post-body-paragraph ka kb in kc b kd nl kf kg kh nm kj kk kl nn kn ko kp no kr ks kt np kv kw kx ig bi translated">对于数据库，我使用了MongoDB和mongoose，因为它很容易与Node集成。</p><p id="01e3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果这是您第一次听到这个，您只需要知道MongoDB是一个无模式的NoSQL数据库，这意味着您可以在其中存储JSON实体，并且这些实体的结构可以变化，因为它不像SQL数据库那样是强制的。</p><p id="a7bf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">更简单地说，如果SQL数据看起来像带有id的表，并定义了它们之间的关系，那么在NoSQL中，它看起来就像这样:</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/1aed0944968bdcd9c7080f246bcaf3ee.png" data-original-src="https://miro.medium.com/v2/resize:fit:476/format:webp/1*rTy5v5lqYPelmHatM-vnwQ.png"/></div></figure><p id="fb71" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因为MongoDB不强制数据的结构，所以我们使用mongoose，它提供了一个“模式”，这是一个数据结构或形状。为了进一步参考，你可以阅读这篇<a class="ae jz" href="https://www.freecodecamp.org/news/introduction-to-mongoose-for-mongodb-d2a7aa593c57/#:~:text=Mongoose%20is%20an%20Object%20Data,of%20those%20objects%20in%20MongoDB.&amp;text=MongoDB%20is%20a%20schema%2Dless%20NoSQL%20document%20database." rel="noopener ugc nofollow" target="_blank">文章</a>，或者只是阅读mongoose的文档。</p><p id="edb1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了将我们的应用程序连接到数据库，我</p><p id="91d4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的例子中，我创建了一个新文件夹<code class="fe lq lr ls lt b">src/resources/product</code>并在其中添加了3个文件。</p><figure class="lv lw lx ly gt jo gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/0cb79495f4a25d08fa2a77604fcc480a.png" data-original-src="https://miro.medium.com/v2/resize:fit:518/format:webp/1*bNxMJHJPzV6dYZWoKVY4og.png"/></div></figure><p id="b1fe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了了解每个文件的作用，在文件的命名中添加了解释(控制器、型号、路由器)。</p><p id="4536" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">该产品的模式创建如下:</p><figure class="lv lw lx ly gt jo"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Product model</figcaption></figure><p id="f188" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe lq lr ls lt b">timestamps</code>选项告诉mongoose将<code class="fe lq lr ls lt b">createdAt</code>和<code class="fe lq lr ls lt b">updatedAt</code>字段分配给模式。</p><h1 id="1e19" class="mn mo in bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">控制器</h1><p id="2d68" class="pw-post-body-paragraph ka kb in kc b kd nl kf kg kh nm kj kk kl nn kn ko kp no kr ks kt np kv kw kx ig bi translated">好了，现在我们已经定义了我们想要的产品外观，我们可以继续实现API的CRUD操作。</p><p id="1919" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae jz" href="https://gist.github.com/Raduuu/66d22d1a821ec6e77c6ac203e2eda359" rel="noopener ugc nofollow" target="_blank">https://gist . github . com/Raduuu/66 d22d 1 a 821 EC 6 e 77 c 6 AC 203 e 2 EDA 359</a></p><p id="9b29" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我从课程中学到的一些非常有用的东西是用这些CRUD函数创建一个通用文件，可以用在我们应用程序中的任何模型上，基本上，正如你在上面看到的，每个函数接收一个<code class="fe lq lr ls lt b">model</code>参数并返回一个新的异步函数，该函数接收来自客户端的请求和将作为参数发送给客户端的响应对象。</p><p id="3907" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我们的<code class="fe lq lr ls lt b">product.controllers.js</code>文件中，我们可以这样使用上面的文件:</p><pre class="lv lw lx ly gt nu lt nv nw aw nx bi"><span id="d09f" class="ny mo in lt b gy nz oa l ob oc">import { crudControllers } from './crud'</span><span id="1cf2" class="ny mo in lt b gy od oa l ob oc">import { Product } from './product.model'</span><span id="53c7" class="ny mo in lt b gy od oa l ob oc">export default crudControllers(Product)</span></pre><p id="20b1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您可以在这里看到我们导出了<code class="fe lq lr ls lt b">crudControllers(Product)</code>，这意味着我们从<code class="fe lq lr ls lt b">crud.js</code>文件中导出了每个函数返回的函数。</p><h1 id="88c6" class="mn mo in bd mp mq mr ms mt mu mv mw mx my mz na nb nc nd ne nf ng nh ni nj nk bi translated">路由器</h1><p id="d4f8" class="pw-post-body-paragraph ka kb in kc b kd nl kf kg kh nm kj kk kl nn kn ko kp no kr ks kt np kv kw kx ig bi translated">正如我们已经知道的，每个控制器都应该绑定到一个路径，客户端可以用它来请求数据。</p><p id="e98f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Express有自己的路由器组件，我们可以使用它来完成这项工作。</p><figure class="lv lw lx ly gt jo"><div class="bz fp l di"><div class="ns nt l"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Router.js</figcaption></figure><p id="fc4e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但我们还没有完成，我们仍然需要连接到数据库，并告诉我们的应用程序使用<code class="fe lq lr ls lt b">/product</code> url上的产品路由器。</p><p id="43db" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，在我们的index.js中，我们需要连接到数据库，并将我们的路线绑定到我们的控制器。</p><figure class="lv lw lx ly gt jo"><div class="bz fp l di"><div class="ns nt l"/></div></figure><p id="34ff" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果你想知道morgan包是什么，根据npm的定义，它是node.js的HTTP请求记录器中间件，这意味着如果我们终端中的日志使用它会看起来更漂亮，成功时它们会是绿色的，错误时是红色的。</p><p id="31f4" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这只是展示如何创建一个小的工作API的一部分。</p><p id="4162" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在下一篇文章中，我们将看看如何保护我们的API，我们将创建更多的端点，我们将添加一个认证模块，我们还将看到如何使用jwt令牌来保护我们的应用程序。</p></div></div>    
</body>
</html>