<html>
<head>
<title>Can you implement an async-await function with just 20 lines of code?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你能用20行代码实现一个异步等待函数吗？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/can-you-implement-an-async-await-function-with-just-20-lines-of-code-1f5b187c6a4f?source=collection_archive---------10-----------------------#2020-05-04">https://javascript.plainenglish.io/can-you-implement-an-async-await-function-with-just-20-lines-of-code-1f5b187c6a4f?source=collection_archive---------10-----------------------#2020-05-04</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="b775" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">有一件事会让你在面试中脱颖而出</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/6bf3228ee094ae3952967dc44403cdd9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vihKFiaE2zuuWuJJ"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@moritz_photography?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Moritz Kindler</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6976" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果面试官让你手写一个异步函数，你能完成任务吗？</p><p id="dcbd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">异步函数是生成器函数的语法糖。在本文中，我将首先研究<code class="fe lp lq lr ls b">async</code>关键字和生成器函数如何协同工作来管理异步编程。然后，我将与您一起使用生成器函数实现一个简单的异步函数。</p><p id="b348" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">首先，让我们看一个使用async/await关键字的函数。</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="2df1" class="lx ly in ls b gy lz ma l mb mc">const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000))</span><span id="e6d3" class="lx ly in ls b gy md ma l mb mc">async function test() {<br/>  const data = await getData()<br/>  console.log('data: ', data);<br/>  const data2 = await getData()<br/>  console.log('data2: ', data2);<br/>  return 'success'<br/>}</span><span id="67ec" class="lx ly in ls b gy md ma l mb mc">// The function will print `data` after 1 second, then `data2` after another second and then 'success'<br/>test().then(res =&gt; console.log(res))</span></pre><p id="3582" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们想用生成器函数表达上面的例子，应该怎么写代码？</p><p id="6c92" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们可以这样写:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="9fc2" class="lx ly in ls b gy lz ma l mb mc">const getData = () =&gt; new Promise(resolve =&gt; setTimeout(() =&gt; resolve("data"), 1000))</span><span id="e08d" class="lx ly in ls b gy md ma l mb mc">function* testG() {<br/>  // await is translated as yield<br/>  const data = yield getData()<br/>  console.log('data: ', data);<br/>  const data2 = yield getData()<br/>  console.log('data2: ', data2);<br/>  return 'success'<br/>}</span></pre><p id="8e9b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">众所周知，生成器功能不会自动执行。每次调用它的下一个方法时，程序都在下一个产量处停止。</p><p id="273b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">有了这个特性，我们可以编写一个自动执行的函数，并让生成器函数完全实现异步函数。</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="d47e" class="lx ly in ls b gy lz ma l mb mc">function asyncToGenerator(fn){<br/>  // ...<br/>}<br/>  <br/>var test = asyncToGenerator(<br/>    function* testG() {<br/>      // await is translated as yield<br/>      const data = yield getData()<br/>      console.log('data: ', data);<br/>      const data2 = yield getData()<br/>      console.log('data2: ', data2);<br/>      return 'success'<br/>    }<br/>)</span><span id="962c" class="lx ly in ls b gy md ma l mb mc">test().then(res =&gt; console.log(res))</span></pre><p id="78d7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">嗯，我们还没有写asyncToGenerator函数，但是总体思路已经定了。AsyncToGenerator应该接受一个生成器函数并返回一个promise对象。这里的关键是函数使用yield来划分异步进程，那么这应该如何自动化呢？</p><p id="07cd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在写这个函数之前，我们模拟手动调用生成器函数，然后一步一步地走完这个过程，这有助于我们后面更好地思考。</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="6172" class="lx ly in ls b gy lz ma l mb mc">function* testG() {<br/>  const data = yield getData()<br/>  console.log('data: ', data);<br/>  const data2 = yield getData()<br/>  console.log('data2: ', data2);<br/>  return 'success'<br/>}</span></pre><p id="1323" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们首先调用<code class="fe lp lq lr ls b">testG</code>生成一个迭代器:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="0a74" class="lx ly in ls b gy lz ma l mb mc">// An iterator is returned<br/>var gen = testG()</span></pre><p id="8ebd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然后第一次执行<code class="fe lp lq lr ls b">next</code>:</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="d2f2" class="lx ly in ls b gy lz ma l mb mc">// After the first call `next`, the program stays at the first yield<br/>// The return promise object contains the data needed for `data`<br/>var dataPromise = gen.next()</span></pre><p id="a5be" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">返回一个承诺，是第一次执行<code class="fe lp lq lr ls b">getData()</code>返回的承诺。</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="bdfe" class="lx ly in ls b gy lz ma l mb mc">const data = yield getData()</span></pre><p id="2ecf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">但是注意:这段代码被分成左右两部分，对<code class="fe lp lq lr ls b">next</code>的第一次调用实际上只是停留在<code class="fe lp lq lr ls b">yield getData()</code>，这里<code class="fe lp lq lr ls b">data</code>的值没有确定。</p><p id="d0c4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么<code class="fe lp lq lr ls b">data</code>的值是什么时候确定的呢？在下一次调用<code class="fe lp lq lr ls b">next</code>时，传入的参数被接受为最后一次让步之前的值。</p><p id="1fc3" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">也就是当我们再次调用<code class="fe lp lq lr ls b">gen.next(‘a value to data’)</code>时，数据的值将被确定为<code class="fe lp lq lr ls b">‘a value to data’</code>。</p><pre class="kd ke kf kg gt lt ls lu lv aw lw bi"><span id="067e" class="lx ly in ls b gy lz ma l mb mc">gen.next('<!-- -->a value to data<!-- -->')</span><span id="0614" class="lx ly in ls b gy md ma l mb mc">// This is when the data is assigned<br/>const data = yield getData()</span><span id="762e" class="lx ly in ls b gy md ma l mb mc">console.log('data: ', data);</span><span id="5a0c" class="lx ly in ls b gy md ma l mb mc">// Then go to next yield<br/>const data2 = yield getData()</span></pre><p id="d9af" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是生成器函数理解的一个难点，但为了达到我们的目的，我们必须学习它。</p><p id="3359" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">利用这个特性，我们可以控制产出的过程，然后实现异步功能。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="bb54" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这种函数调用看起来像回调地狱，让async/await通过生成器函数实现。</p><p id="f88b" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这是我们最后的22行代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="42ea" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">那么我们来分析一下这段代码:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="me mf l"/></div></figure><p id="36eb" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi">`</p><h2 id="49a4" class="lx ly in bd mg mh mi dn mj mk ml dp mm lc mn mo mp lg mq mr ms lk mt mu mv mw bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="7209" class="pw-post-body-paragraph kt ku in kv b kw mx jo ky kz my jr lb lc mz le lf lg na li lj lk nb lm ln lo ig bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae ks" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kv io">AI in Plain English</strong></a><a class="ae ks" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kv io">UX in Plain English</strong></a><a class="ae ks" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kv io">Python in Plain English</strong></a><strong class="kv io"/>——谢谢，继续学习！</p><p id="d278" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ks" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kv io">submissions @ plain English . io</strong></a><strong class="kv io"/>，并附上您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>