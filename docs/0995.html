<html>
<head>
<title>Please stop using Classes in JavaScript and become a better developer</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">请停止在JavaScript中使用类，成为一个更好的开发人员</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/please-stop-using-classes-in-javascript-and-become-a-better-developer-a185c9fbede1?source=collection_archive---------0-----------------------#2020-01-12">https://javascript.plainenglish.io/please-stop-using-classes-in-javascript-and-become-a-better-developer-a185c9fbede1?source=collection_archive---------0-----------------------#2020-01-12</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/66dfbf7dfa9e0ca59725115e963f7cc2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*FfWF8PjBXoj6eWMN.jpg"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Image by Pexels from Pixabay</figcaption></figure><p id="8e79" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">多年来，面向对象编程是软件工程中事实上的标准。类、多态性、继承和封装的概念主导并革新了开发过程。但是所有的东西都有有效期，包括编程范例。在本文中，我将讨论为什么首先引入类，为什么在JavaScript中使用类是一个坏主意，以及有哪些替代方法。</p><p id="50e0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我不打算谈论为什么面向对象程序正在逐渐消失，但是你可以查看<a class="ae la" href="https://medium.com/better-programming/object-oriented-programming-the-trillion-dollar-disaster-92a4b666c7c7" rel="noopener">这篇伟大的文章</a>了解更多信息。</p><h1 id="5a6d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ES6之前的课程</h1><p id="f7d8" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">尽管class关键字是从ES6 (ECMAScript 2015)开始被添加到JavaScript中的，但是人们在更早的时候就使用了class。实现这一点的方法是构造函数和原型委托。为了向您确切地展示我的意思，我将在ES5和ES6环境中实现相同的类。想想继承了<code class="fe me mf mg mh b">Car</code>的类<code class="fe me mf mg mh b">Car</code>和<code class="fe me mf mg mh b">SportsCar</code>。两者都有<code class="fe me mf mg mh b">make</code>、<code class="fe me mf mg mh b">model</code>属性和<code class="fe me mf mg mh b">start</code>方法，但<code class="fe me mf mg mh b">SportsCar</code>也有<code class="fe me mf mg mh b">turbocharged</code>属性并超越了<code class="fe me mf mg mh b">start</code>方法:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="d1ef" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">正如你可能猜到的，函数<code class="fe me mf mg mh b">Car</code>(第2行)和<code class="fe me mf mg mh b">SportsCar</code>(第18行)是构造函数。使用<code class="fe me mf mg mh b">this</code>关键字定义属性，使用<code class="fe me mf mg mh b">new</code>创建对象本身。如果您不熟悉<code class="fe me mf mg mh b">prototype</code>，这是一个特殊的属性，每个JS对象都必须委托通用行为。例如，数组对象的原型具有您可能很熟悉的功能:<code class="fe me mf mg mh b">map</code>、<code class="fe me mf mg mh b">forEach</code>、<code class="fe me mf mg mh b">find</code>等。字符串原型具有<code class="fe me mf mg mh b">replace</code>、<code class="fe me mf mg mh b">substr</code>等功能。</p><p id="2a8c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在第33行创建Car对象后，您可以访问它的属性和方法。从第34行开始的呼叫会导致以下操作:</p><ol class=""><li id="6067" class="mo mp iq ke b kf kg kj kk kn mq kr mr kv ms kz mt mu mv mw bi translated">JS引擎用键<code class="fe me mf mg mh b">start</code>向<code class="fe me mf mg mh b">car</code>对象请求一个值。</li><li id="fbff" class="mo mp iq ke b kf mx kj my kn mz kr na kv nb kz mt mu mv mw bi translated">对象回答说它没有这样的值</li><li id="a5a9" class="mo mp iq ke b kf mx kj my kn mz kr na kv nb kz mt mu mv mw bi translated">JS引擎向<code class="fe me mf mg mh b">car.prototype</code>对象请求一个带有键<code class="fe me mf mg mh b">start</code>的值。</li><li id="c1e9" class="mo mp iq ke b kf mx kj my kn mz kr na kv nb kz mt mu mv mw bi translated"><code class="fe me mf mg mh b">car.prototype</code>返回<code class="fe me mf mg mh b">start</code>函数，JS引擎立即执行该函数。</li></ol><p id="2d4f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">访问make和model属性的方式类似，只是它们是直接在car对象上定义的，而不是在原型上定义的。</p><p id="5106" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">继承有点棘手。它在第24–25行处理。这里最重要的函数是<code class="fe me mf mg mh b">Object.create</code>函数。它接受一个对象并返回一个全新的对象，其原型被设置为作为参数传递的值。现在，如果JS引擎没有在<code class="fe me mf mg mh b">sportsCar</code>对象或<code class="fe me mf mg mh b">sportsCar.prototype</code>上找到值，它将查询<code class="fe me mf mg mh b">sportsCar.prototype.prototype</code>，这是<code class="fe me mf mg mh b">Car</code>对象的原型。</p><h1 id="d41b" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">ES6类别关键字</h1><p id="f217" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">随着2015年ES6的发布，期待已久的<code class="fe me mf mg mh b">class</code>关键词在JavaScript中到来了。这是按照社区的许多要求做的，因为人们对使用面向对象语言感到不舒服。但是他们忽略了重要的一点。</p><blockquote class="nc nd ne"><p id="73ac" class="kc kd nf ke b kf kg kh ki kj kk kl km ng ko kp kq nh ks kt ku ni kw kx ky kz ij bi translated">JavaScript不知道什么是类</p></blockquote><p id="eef7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">JavaScript不是面向对象的语言，它不是被设计成面向对象的语言，类的概念绝对不适用于它。虽然JS中的所有东西都是对象，但这些对象不同于Java或C#中的对象。在JS中，一个对象只是一个地图数据结构，带有一个稍微复杂的查找过程。就这样，真的。当我说一切都是对象时，我是认真的:甚至函数也是对象。您可以使用下面的代码片段来检查它:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="972b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">好吧，这些都很好，但是<code class="fe me mf mg mh b">class</code>关键字是如何工作的呢？很高兴你问了。你还记得之前的<code class="fe me mf mg mh b">Car</code>和<code class="fe me mf mg mh b">SportsCar</code>的例子吗？嗯，class关键字仅仅是语法上的糖衣。换句话说，类在概念上产生相同的代码，并且只用于美观和可读性的目的。正如我之前承诺的，这里有一个ES6中相同类的例子:</p><figure class="mi mj mk ml gt jr"><div class="bz fp l di"><div class="mm mn l"/></div></figure><p id="642c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这些示例是相同的，并且产生相同的结果。有趣的是，它们在幕后产生(几乎)相同的代码。我不会把它写在这里，但是如果你好奇，可以去<a class="ae la" href="https://babeljs.io/en/repl#?browsers=&amp;build=&amp;builtIns=false&amp;spec=false&amp;loose=false&amp;code_lz=MYGwhgzhAEDCYCdoG8BQ1rAPYDsIBcEBXYfLBACgFswBrAUwBpoqsATekAShXQ2nwALAJYQAdDQbQAvCzr0A3HwxDRE9pxksNIJRgC-fPgUT4KPNP0y4IWEPTEgsAcwoByAG4IsWKm6560IYYfGQAyoTCOK4WytZ4dg5OrgAG8EgAtNAAJMiq4pL0-tBZufnqHCD6KQF8hoaooJAwYQAO5PgQ6dD0AB749DhsMN2W8QTEpOTU8syslcz4RAgARljAgojO9GyxVhBErfSUhXM6tVblS6vrmwjbbFrXaxtbO4HB0Mb4pua8VtgEvZHC53AA1ABKAHkYVCALL-D6oBqoAD0qOgAEFSEQwCBoEQIGBttAEPQaFEYEJ6NAiVR6KgPIhMMzZDh6AB3OCIdwAOVERJwbmYbjCRBwOAAnojGogxCYEGYAtB0dAvD4qI0bIkQa5gHLCsrVfyoGAcKhGcyIO1FV1WdB2Vy2h07ZRRUQVogiMLoG4AEIQgBaPsIRHotWtLvS8p-ivMChVGMhsPhWqBSVB-oQYmetzeuwTqtD9CAA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=true&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=es2015&amp;prettier=true&amp;targets=&amp;version=7.8.0&amp;externalPlugins=" rel="noopener ugc nofollow" target="_blank">在线巴别塔翻译器</a>看看输出。</p><h1 id="36db" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">为什么不呢？</h1><p id="7228" class="pw-post-body-paragraph kc kd iq ke b kf lz kh ki kj ma kl km kn mb kp kq kr mc kt ku kv md kx ky kz ij bi translated">现在你应该了解JS中的<em class="nf">类</em>是什么，以及它们是如何工作的。现在，有了这些知识，我可以解释为什么在JS中使用类是一个坏主意。</p><ol class=""><li id="1012" class="mo mp iq ke b kf kg kj kk kn mq kr mr kv ms kz mt mu mv mw bi translated"><strong class="ke ir">装订问题</strong>。由于类构造函数与关键字<code class="fe me mf mg mh b">this</code>密切相关，这可能会引入潜在的绑定问题，尤其是当您试图将类方法作为回调传递给外部例程时(hello，React devs👋)</li><li id="6d89" class="mo mp iq ke b kf mx kj my kn mz kr na kv nb kz mt mu mv mw bi translated"><strong class="ke ir">性能问题</strong>。由于类的实现，它们在运行时很难优化。虽然我们目前享受着高性能的机器，但摩尔定律正在消失的事实可能会改变这一切。</li><li id="117b" class="mo mp iq ke b kf mx kj my kn mz kr na kv nb kz mt mu mv mw bi translated"><strong class="ke ir">私有变量</strong>。首先，私有变量是类的最大优势和主要原因之一，但在JS中是不存在的。</li><li id="fab8" class="mo mp iq ke b kf mx kj my kn mz kr na kv nb kz mt mu mv mw bi translated"><strong class="ke ir">严格的等级制度</strong>。类引入了直接的自顶向下的顺序，使得更改更难实现，这在大多数JS应用程序中是不可接受的。</li><li id="5d64" class="mo mp iq ke b kf mx kj my kn mz kr na kv nb kz mt mu mv mw bi translated"><a class="ae la" href="https://reactjs.org/docs/hooks-intro.html" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir">因为React团队告诉你不要</strong> </a>。虽然他们还没有明确反对基于类的组件，但他们很可能会在不久的将来这样做。</li></ol><p id="97ac" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">所有这些问题都可以通过JS对象和原型委托来缓解。JS提供了比类更多的功能，但是大多数开发人员对此视而不见。如果你想真正掌握JS，你需要拥抱它的哲学，远离教条式的阶级思维。</p></div></div>    
</body>
</html>