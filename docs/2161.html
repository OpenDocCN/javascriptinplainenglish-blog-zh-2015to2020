<html>
<head>
<title>The Code that Runs Your JavaScript Code</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">运行JavaScript代码的代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-code-that-runs-your-javascript-code-eec24d05dfde?source=collection_archive---------9-----------------------#2020-05-25">https://javascript.plainenglish.io/the-code-that-runs-your-javascript-code-eec24d05dfde?source=collection_archive---------9-----------------------#2020-05-25</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="3d14" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">什么是JavaScript运行时环境，作为一名web开发人员，您如何将它的知识应用到您的工作中？</h2></div><p id="4a8b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您多久考虑一次代码运行的环境，以及代码运行时可用的资源？理解“运行时”环境可以帮助我们作为JavaScript开发人员在编写代码时做出更好的选择。</p><p id="c5a2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当你在你选择的编辑器中打开一个脚本，你跳进你的终端并输入<code class="fe ky kz la lb b">node test.js</code>时，到底发生了什么来允许你的代码执行？运行时环境在一瞬间为您旋转起来，它主要由“V8引擎”和几个称为“JavaScript运行时”的附加结构定义。它应用了20年来世界上最优秀的工程师的集体智慧，找到绝对最有效的方法来运行您的微不足道的小脚本，最终在您的REPL循环中记录“hello world”。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi lc"><img src="../Images/57f1fb76f13c35619ef7e019e54d2826.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*UbiRmz-LsmVUmIK9.png"/></div></div></figure><h1 id="ed6c" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">同步执行(复杂性级别1)</h1><p id="6a4e" class="pw-post-body-paragraph kc kd in ke b kf mg jo kh ki mh jr kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">为了开始检查上面的图像，让我们首先看一个非常简单的例子，其中您的脚本只包含同步函数调用。在这种情况下，您的脚本将只与V8引擎的调用堆栈和堆接口。现在，您可以忽略图表右侧的所有信息。</p><p id="0c3a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">堆负责保存你在脚本中定义的函数和变量的状态，在下面的代码示例中我<em class="ml">将会忽略它</em>这样我就可以更好地关注异步编程和事件循环的话题。</p><p id="5926" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以让我们看看下面的脚本:</p><pre class="ld le lf lg gt mm lb mn mo aw mp bi"><span id="01e3" class="mq lp in lb b gy mr ms l mt mu">const bar = (arg) =&gt; { return arg }<br/>const foo = (arg) =&gt; { return bar(arg) }<br/>foo('function call')</span></pre><p id="a859" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行时要做的第一件事是将JS源代码分解成可执行的子程序块，称为堆栈帧。堆栈帧是CS中常用的一个概念。考虑堆栈框架的最简单方法如下:</p><blockquote class="mv mw mx"><p id="5376" class="kc kd ml ke b kf kg jo kh ki kj jr kk my km kn ko mz kq kr ks na ku kv kw kx ig bi translated">每个堆栈帧对应于一个尚未因返回而终止的函数或过程调用。对于每个函数调用，都会创建一个包含<code class="fe ky kz la lb b">function</code>的参数和局部变量的框架。<a class="ae nb" href="https://www.cs.cmu.edu/~adamchik/15-121/lectures/Stacks%20and%20Queues/Stacks%20and%20Queues.html" rel="noopener ugc nofollow" target="_blank">信用</a></p></blockquote><p id="cab3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的脚本将生成2个独立的堆栈帧，第一个包含foo的参数和局部变量。当foo调用bar时，用bar的参数和局部变量创建第二个框架。这里的局部变量包括函数栏。当bar返回时，堆栈帧从堆栈中弹出，foo帧将返回，最终清空堆栈。调用堆栈是一个LIFO数据结构，这意味着添加到堆栈中的最后一个框架将是第一个被执行的。</p><p id="4838" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">环境将堆栈帧一个接一个地输入V8引擎进行执行，V8引擎随后执行这些堆栈帧，或者将它们交给运行时可用的其他API。</p><h2 id="3ab8" class="mq lp in bd lq nc nd dn lu ne nf dp ly kl ng nh ma kp ni nj mc kt nk nl me nm bi translated">单线程执行</h2><p id="42d1" class="pw-post-body-paragraph kc kd in ke b kf mg jo kh ki mh jr kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">您可能已经听说过，在V8 JavaScript运行时环境中只有一个堆栈。这意味着，从根本上说，JS引擎一次只会运行一个堆栈帧。</p><p id="0b64" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当你展开你的程序时，你可以看到一个非常单一的堆栈跟踪，它实际上是当你展开你的代码时调用堆栈状态的冻结帧，在错误被捕获时调用堆栈的样子。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi nn"><img src="../Images/b4f2509a1217d4f7e130ef4e9649ff05.png" data-original-src="https://miro.medium.com/v2/resize:fit:1092/format:webp/1*4Tml_2xIbO_0O-Mfk4jxyA.png"/></div></figure><p id="8b4b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">术语“吹栈”是一个不同类型的异常的术语，当调用栈变得如此之大，以至于运行时给你这个消息(比如，如果你递归地调用一个函数)。</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div class="gh gi no"><img src="../Images/6194ffbf29de0deb0f1c5846e6b9bce8.png" data-original-src="https://miro.medium.com/v2/resize:fit:974/format:webp/1*jhxAsYa7STIwv-A3HJyxDw.png"/></div></figure><p id="5f15" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这使我们进入了下一个复杂层次，即运行时中允许“非阻塞IO”或编写代码以允许栈尽可能快地被清空或自由执行的范例。</p><h1 id="9fda" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">异步/非阻塞执行(复杂性级别2)</h1><p id="b532" class="pw-post-body-paragraph kc kd in ke b kf mg jo kh ki mh jr kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">当我们开始思考我们正在编写的JS代码时，很明显，我们的JS运行时用例比我上面给出的愚蠢的脚本例子要复杂得多。您可能有按钮的clickhandlers、在用户交互过程中向服务器动态运行的数据请求，或者执行一些处理器密集型任务，如文件IO。JS运行时处理这些更加频繁和一致的代码执行的方式是通过两个新的构造，即<a class="ae nb" href="https://www.youtube.com/watch?v=cCOL7MC4Pl0&amp;vl=en" rel="noopener ugc nofollow" target="_blank">事件循环</a>和事件队列。</p><p id="8c4a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">为了检查调用堆栈，让我们看下面的例子:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="bc6d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个脚本将遵循与前面的同步脚本示例不同的路径。它将利用浏览器运行时中的其他构造来帮助确保程序能够以“非阻塞”的方式运行，或者换句话说，释放堆栈以允许程序继续执行功能。在这种情况下，我们将采取以下路径来执行:</p><ol class=""><li id="53d1" class="nr ns in ke b kf kg ki kj kl nt kp nu kt nv kx nw nx ny nz bi translated">在任何东西移入堆栈之前，<code class="fe ky kz la lb b">immediateExecution</code>将被保存在堆中以备后用</li><li id="8cd0" class="nr ns in ke b kf oa ki ob kl oc kp od kt oe kx nw nx ny nz bi translated">函数<code class="fe ky kz la lb b">ajax</code>将被推到调用堆栈的顶部</li><li id="2bc6" class="nr ns in ke b kf oa ki ob kl oc kp od kt oe kx nw nx ny nz bi translated">然后函数<code class="fe ky kz la lb b">ajax</code>将执行，调用http Web API(本质上是一个由浏览器定义的函数——完整列表可以在这里找到)</li><li id="36e9" class="nr ns in ke b kf oa ki ob kl oc kp od kt oe kx nw nx ny nz bi translated">web API在回调队列中注册一个回调函数，当从<code class="fe ky kz la lb b"><a class="ae nb" href="https://example.com/api" rel="noopener ugc nofollow" target="_blank">https://example.com/api</a></code>返回数据时，该函数将运行。</li><li id="7978" class="nr ns in ke b kf oa ki ob kl oc kp od kt oe kx nw nx ny nz bi translated">然后从调用堆栈中移除该函数，清除堆栈以便执行其他重要的函数</li><li id="be1d" class="nr ns in ke b kf oa ki ob kl oc kp od kt oe kx nw nx ny nz bi translated">函数<code class="fe ky kz la lb b">immediateExecution</code>将被添加到调用堆栈中，并将运行，大约500毫秒后返回“1000000”</li><li id="29dc" class="nr ns in ke b kf oa ki ob kl oc kp od kt oe kx nw nx ny nz bi translated">回调队列中的HTTP请求API完成</li><li id="dbb7" class="nr ns in ke b kf oa ki ob kl oc kp od kt oe kx nw nx ny nz bi translated">事件循环将回调函数拉回调用堆栈</li><li id="5aa6" class="nr ns in ke b kf oa ki ob kl oc kp od kt oe kx nw nx ny nz bi translated">ajax调用中的匿名函数运行，控制台记录<code class="fe ky kz la lb b">response</code>变量</li></ol><p id="f557" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如上所述，Ajax函数和其他http请求被设计为异步运行。如果我们同步运行同一个脚本，那么我们会延迟immediateExecution的运行并阻塞主线程。进行以下编辑:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="np nq l"/></div><figcaption class="of og gj gh gi oh oi bd b be z dk">credit: <a class="ae nb" href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5" rel="noopener ugc nofollow" target="_blank">https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5</a></figcaption></figure><p id="e34d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">上面的代码告诉环境将AJAX请求保留在主线程上，这将暂停代码执行，直到500–1000毫秒后返回。只有这样，immediateExecution函数才能开始执行。</p><p id="28f2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们来看一个有趣的动态GIF示例，它来自Alexander Zlatkov的优秀文章<a class="ae nb" href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5" rel="noopener ugc nofollow" target="_blank">,用来帮助演示异步执行。</a></p><p id="0a81" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">给定以下代码块:</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="c1c6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">环境状态将经历以下16种状态:</p><figure class="ld le lf lg gt lh gh gi paragraph-image"><div role="button" tabindex="0" class="li lj di lk bf ll"><div class="gh gi oj"><img src="../Images/f076bb5f33e643034fe7ebb1a2709be2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PY36yZtlpP9Yy5uk.gif"/></div></div></figure><p id="9e3f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从这个例子中，您可以非常清楚地看到Web APIs和回调队列是如何协同工作来高效地在队列中移动代码的。当您向队列中添加更多回调时，有一个可预测的方法在单线程上执行它们。</p><p id="c41a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="ml">注意:Node.js提供了一个非常不同的运行时环境，尽管它也是由Google Chrome的V8 JS引擎支持的。Node.js不会为您提供DOM树、AJAX或其他Web API。然而，Node.js与这些API有类似的范例。Node.js APIs定义</em> <a class="ae nb" href="https://nodejs.org/docs/latest/api/" rel="noopener ugc nofollow" target="_blank"> <em class="ml">此处</em> </a> <em class="ml">。</em></p><h1 id="ab40" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">事件循环的逻辑(复杂性等级3)</h1><p id="4c47" class="pw-post-body-paragraph kc kd in ke b kf mg jo kh ki mh jr kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">我上面画的图片是环境的简化版本，特别是当它涉及到事件循环时，这是Web开发人员环境中最重要的组件之一。</p><p id="c71d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我在上面省略的主要组件是<strong class="ke io">渲染周期</strong>，它在堆栈上执行的堆栈帧之间定期运行，以重新绘制应用程序的UI，以及<strong class="ke io">微任务和宏任务</strong>之间的差异，它们由事件循环周期在稍微不同的时间注入到调用堆栈中。我希望在接下来的帖子中写下这些概念，但是如果你好奇，我已经链接了一些我最喜欢的关于这些主题的资源。</p><h1 id="0ebf" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">编写运行时环境感知的JavaScript</h1><p id="dd5f" class="pw-post-body-paragraph kc kd in ke b kf mg jo kh ki mh jr kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">编写针对JS运行时优化的代码没有单一的规则，我不认为任何有真正老板的人有时间钻研并完全优化他们的代码。当你写代码时，你能做的是记住下面的一些基本概念。</p><h2 id="88cf" class="mq lp in bd lq nc nd dn lu ne nf dp ly kl ng nh ma kp ni nj mc kt nk nl me nm bi translated">非阻塞IO</h2><p id="7aff" class="pw-post-body-paragraph kc kd in ke b kf mg jo kh ki mh jr kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">对于常规大小的操作，尽可能使用非阻塞函数和操作。这包括请求外部资源时的承诺或其他异步事件处理程序，如果您要处理频繁更新的连接，还包括套接字。制作动画时，要注意你的JS会<a class="ae nb" href="https://mobiforge.com/design-development/the-guide-to-non-blocking-code" rel="noopener ugc nofollow" target="_blank">阻挡你的动画的渲染</a>，所以使用<a class="ae nb" href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame" rel="noopener ugc nofollow" target="_blank">requestAnimationFrame()</a><strong class="ke io"/>方法。这个方法接受一个包含所有漂亮动画的回调作为参数，然后非常礼貌地请求窗口在下一次重画之前执行动画。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="np nq l"/></div></figure><p id="ee51" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">对于大型的CPU密集型进程，使用额外的web workers来生成可以执行操作的额外线程。工作线程仍然是一个实验性的特性，这意味着在生产环境中使用它们可能不是最好的主意。这里有一个定义web worker的代码示例，这里有一个关于如何构建web worker的<a class="ae nb" href="https://www.youtube.com/watch?v=pMK-jcOAYI8" rel="noopener ugc nofollow" target="_blank">简单解释</a>。</p><figure class="ld le lf lg gt lh"><div class="bz fp l di"><div class="np nq l"/></div></figure><h2 id="2ef0" class="mq lp in bd lq nc nd dn lu ne nf dp ly kl ng nh ma kp ni nj mc kt nk nl me nm bi translated">汇编</h2><ol class=""><li id="8ee4" class="nr ns in ke b kf mg ki mh kl ok kp ol kt om kx nw nx ny nz bi translated"><strong class="ke io">对象属性的顺序</strong>:总是以相同的顺序实例化你的对象属性，这样隐藏的类和随后优化的代码就可以被共享。</li><li id="5790" class="nr ns in ke b kf oa ki ob kl oc kp od kt oe kx nw nx ny nz bi translated"><strong class="ke io">动态属性</strong>:在实例化后给一个对象添加属性将会强制一个隐藏的类改变，并减慢任何为之前的隐藏类优化的方法。相反，在对象的构造函数中分配对象的所有属性。</li><li id="81b7" class="nr ns in ke b kf oa ki ob kl oc kp od kt oe kx nw nx ny nz bi translated"><strong class="ke io">方法</strong>:重复执行相同方法的代码比只执行一次不同方法的代码运行得更快(由于内联缓存)。</li><li id="217d" class="nr ns in ke b kf oa ki ob kl oc kp od kt oe kx nw nx ny nz bi translated"><strong class="ke io">数组:</strong>避免使用键不是递增数字的稀疏数组。不包含所有元素的稀疏数组是一个散列表<strong class="ke io">。这种数组中的元素访问起来更加昂贵。此外，尽量避免预分配大型数组。最好是边走边成长。最后，不要删除数组中的元素。它使键变得稀疏。</strong></li></ol><h1 id="cf57" class="lo lp in bd lq lr ls lt lu lv lw lx ly jt lz ju ma jw mb jx mc jz md ka me mf bi translated">来源</h1><p id="1947" class="pw-post-body-paragraph kc kd in ke b kf mg jo kh ki mh jr kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated"><strong class="ke io">关于JS运行时环境</strong></p><p id="d9b7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Alexander Zlatkov的《JavaScript如何工作:事件循环和异步编程的兴起+用async/await更好编码的5种方法》</p><p id="8ce1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae nb" href="https://medium.com/@olinations/the-javascript-runtime-environment-d58fa2e60dd0" rel="noopener">Javascript运行时环境…还有，你知道，Javascript是如何工作的</a>作者<a class="ae nb" href="https://medium.com/@olinations?source=post_page-----d58fa2e60dd0----------------------" rel="noopener">杰米·乌塔里洛</a></p><p id="6683" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">关于V8发动机</strong></p><p id="1474" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">JavaScript引擎——它们是怎么做到的？Franziska Hinkelmann</p><p id="34f0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae nb" href="https://www.youtube.com/watch?v=UJPdhx5zTaw&amp;t=1147s" rel="noopener ugc nofollow" target="_blank">用V8打破JavaScript速度限制</a>谷歌I/O 2012，丹尼尔·克利福德</p><p id="fa0c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">关于事件循环</strong></p><p id="ea07" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae nb" href="http://en.wikipedia.org/wiki/Event_loop" rel="noopener ugc nofollow" target="_blank">事件循环</a>，维基百科</p><p id="96f5" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae nb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" rel="noopener ugc nofollow" target="_blank">并发模型和事件循环</a>，Mozilla</p></div></div>    
</body>
</html>