<html>
<head>
<title>Deploying Multi-Environment React Apps with Tanzu Application Service</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">使用Tanzu应用服务部署多环境React应用</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/deploying-multi-environment-react-apps-with-tanzu-application-service-7e332416165?source=collection_archive---------14-----------------------#2020-12-30">https://javascript.plainenglish.io/deploying-multi-environment-react-apps-with-tanzu-application-service-7e332416165?source=collection_archive---------14-----------------------#2020-12-30</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/d57765344b0af212b1b780b6933c36c5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*uNVL-01MxqgE4o7c.png"/></div></div></figure><p id="cf2d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">许多<a class="ae kt" href="https://reactjs.org/docs/glossary.html#single-page-application" rel="noopener ugc nofollow" target="_blank"> SPA </a> React应用程序都是使用NPM <a class="ae kt" href="https://github.com/facebook/create-react-app" rel="noopener ugc nofollow" target="_blank"> Create React App </a> (CRA)包创建的。它创建的应用不需要构建配置，这对于许多用例来说已经足够了。简单的谷歌搜索会让你很好地了解这种方法的利弊。一些有趣的文章:<a class="ae kt" href="https://medium.com/@JamesDinnes/why-you-should-stop-using-creat-react-app-18410ce94e64" rel="noopener">一</a>、<a class="ae kt" href="https://codeburst.io/is-create-react-app-a-dead-end-5baae1568f89" rel="noopener" target="_blank">二</a>和<a class="ae kt" href="https://www.reddit.com/r/reactjs/comments/81gfl6/do_people_use_create_react_app_in_production/" rel="noopener ugc nofollow" target="_blank">三</a>。</p><p id="4dae" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">CRA的主要优势之一是它允许你以静态/缩小文件的形式轻松构建应用程序。一旦你有了一组静态文件，你就可以使用任何HTTP服务器为应用服务，例如apache，nginx，S3。</p><p id="9db9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我刚刚在上面评论的听起来很棒。然而，因为一切都是静态的，给应用程序添加动态可能是一个挑战。该模型假设任何动力都来自外部，通常是API。这在大多数情况下都能很好地工作，但是对于配置文件来说，听起来有点矫枉过正。</p><p id="1a59" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">面临的一个常见挑战是，您需要根据环境指定不同的后端基础URI。例如:<em class="ku"> BACKEND1_BASE_URL </em>可能是<a class="ae kt" href="https://mybackend-dev/api/v1" rel="noopener ugc nofollow" target="_blank">https://my back end-dev/API/v1</a>或<a class="ae kt" href="https://mybackend-dev/api/v1" rel="noopener ugc nofollow" target="_blank">https://my back end/API/v1</a></p><p id="bef2" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以使用<a class="ae kt" href="https://create-react-app.dev/docs/adding-custom-environment-variables/" rel="noopener ugc nofollow" target="_blank">自定义环境变量</a>克服上述挑战，并使用<a class="ae kt" href="https://docs.cloudfoundry.org/buildpacks/staticfile/index.html" rel="noopener ugc nofollow" target="_blank">静态构建包</a>将应用部署到<a class="ae kt" href="https://tanzu.vmware.com/application-service" rel="noopener ugc nofollow" target="_blank"> Tanzu应用服务</a> (TAS)，超级简单！看看下面的<a class="ae kt" href="https://github.com/camposer/react-app-to-tas/blob/master/static-build-and-deploy-example.sh" rel="noopener ugc nofollow" target="_blank"> bash片段</a>。</p><p id="66e3" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，注释方法的一个重要缺点是每次构建都需要维护/存储工件。您最终将面临每个环境不同版本的噩梦，这会显著增加您的库存管理复杂性。试想一下:<em class="ku"> myapp-dev-v1.0.zip </em>，<em class="ku"> myapp-sit-v1.0.zip </em>，<em class="ku"> myapp-uat-v1.0.zip </em>和<em class="ku"> myapp-prod-v1.0.zip </em>！</p><p id="deac" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">您还可以使用其他方法来避免版本管理的麻烦。有些与自定义主机名解析或代理中介(例如反向代理)有关。在这篇文章中，我想重点介绍一种代理中介方法，它依赖于每个环境的不同文件。</p><p id="35a5" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了更好地解释这种方法，我决定编写一个简单的React应用程序，并将其部署到TAS。为什么是TAS？因为我真的相信没有更简单的方法来部署/维护您的应用程序！您拥有所有的<a class="ae kt" href="https://www.cloudfoundry.org/why-cloud-foundry/" rel="noopener ugc nofollow" target="_blank"> Cloud Foundry </a> goodies以及Pivotal和VMware积累的应用程序开发知识。</p><h1 id="8373" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">方法</h1><p id="e5a2" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">你可以在这里找到app live <a class="ae kt" href="http://react-app-to-tas.cfapps.io/" rel="noopener ugc nofollow" target="_blank">，在这里</a>找到源代码<a class="ae kt" href="https://github.com/camposer/react-app-to-tas" rel="noopener ugc nofollow" target="_blank">。原谅CSS和UI品味差！我只想演示如何通过环境变量来改变配置文件。如果您在本地运行该应用程序，您会看到:<em class="ku">欢迎使用，Dev！如果你在TAS上运行它:<em class="ku">欢迎，Prod！</em>。</em></a></p><p id="9c4c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在详细解释了上述React应用程序中引入的所有更改后，最初使用<a class="ae kt" href="https://reactjs.org/docs/create-a-new-react-app.html" rel="noopener ugc nofollow" target="_blank"><em class="ku">npx create-React-App</em></a>创建</p><h1 id="02df" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">配置环境文件</h1><p id="be24" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">在你的index.html中声明一个<a class="ae kt" href="https://github.com/camposer/react-app-to-tas/blob/master/public/index.html#L19" rel="noopener ugc nofollow" target="_blank">新的配置文件:</a></p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="6977" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后添加用于在本地运行应用程序的配置文件(<a class="ae kt" href="https://github.com/camposer/react-app-to-tas/blob/master/public/config.js" rel="noopener ugc nofollow" target="_blank"> <em class="ku"> config.js </em> </a>)和用于不同环境的配置文件(例如<a class="ae kt" href="https://github.com/camposer/react-app-to-tas/blob/master/public/prod.js" rel="noopener ugc nofollow" target="_blank"> <em class="ku"> prod.js </em> </a>)。当您在本地运行应用程序(<em class="ku"> npm start </em>)时，它只使用<em class="ku"> config.js </em>文件。</p><h1 id="6fc0" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">配置NGINX</h1><p id="d6d3" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">我使用的是<a class="ae kt" href="https://docs.cloudfoundry.org/buildpacks/nginx/index.html" rel="noopener ugc nofollow" target="_blank"> NGINX构建包</a>而不是<a class="ae kt" href="https://docs.cloudfoundry.org/buildpacks/staticfile/index.html" rel="noopener ugc nofollow" target="_blank">静态构建包</a>，因为这种方法需要修改<em class="ku"> nginx.conf </em>文件。</p><p id="0aa9" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">你可以在这里找到完整的<em class="ku">nginx . conf</em><a class="ae kt" href="https://github.com/camposer/react-app-to-tas/blob/master/nginx.conf" rel="noopener ugc nofollow" target="_blank"/>，下面几行对这个解释特别重要:</p><figure class="ly lz ma mb gt jo"><div class="bz fp l di"><div class="mc md l"/></div></figure><p id="3d0c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">NGINX将根据环境变量<em class="ku"> CONFIG_FILE </em>的值提供配置文件，例如:<em class="ku"> prod.js </em>。参见<a class="ae kt" href="https://github.com/camposer/react-app-to-tas/blob/master/manifest.yml" rel="noopener ugc nofollow" target="_blank"> <em class="ku"> manifest.yml </em> </a></p><p id="806f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">为了部署这个应用程序，最简单的部分，如果你使用TAS，你可以运行:<em class="ku"> cf push -f manifest.yml </em></p><h1 id="93ab" class="kv kw in bd kx ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls bi translated">最后的话</h1><p id="7aba" class="pw-post-body-paragraph jv jw in jx b jy lt ka kb kc lu ke kf kg lv ki kj kk lw km kn ko lx kq kr ks ig bi translated">希望这个帖子有帮助！至少，我希望它能引发一些思考:-)</p><p id="f3ad" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一些好处:</p><ul class=""><li id="dbb8" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">消除每个环境中的多个工件。降低运营复杂性</li><li id="9739" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">尊重<a class="ae kt" href="https://en.wikipedia.org/wiki/Separation_of_concerns" rel="noopener ugc nofollow" target="_blank">关注点分离</a>原则。前端配置保持在前端。</li><li id="5911" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">消除获取应用配置的端点。</li></ul><p id="1e5a" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一些挑战:</p><ul class=""><li id="125f" class="me mf in jx b jy jz kc kd kg mg kk mh ko mi ks mj mk ml mm bi translated">您需要HTTP服务器配置！如果你只是想使用S3或类似的，那么这是不可行的。</li><li id="2499" class="me mf in jx b jy mn kc mo kg mp kk mq ko mr ks mj mk ml mm bi translated">本地配置的名为config的文件可能会造成混乱。</li></ul><p id="2ed7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">对于“要走的路”，我还是没有定论。我想这要看情况。在任何情况下，这种方法肯定可以在处理多种环境时保持应用程序的简单，特别是如果您需要创建版本并且不想在每个环境中生成多个文件。</p></div></div>    
</body>
</html>