<html>
<head>
<title>JavaScript Selection Sort</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript选择排序</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-selection-sort-1840cd043b52?source=collection_archive---------10-----------------------#2020-12-13">https://javascript.plainenglish.io/javascript-selection-sort-1840cd043b52?source=collection_archive---------10-----------------------#2020-12-13</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="df0b" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">我们来整理一下</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9bdec8162bf4056613075329eeeb5d3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*Uk_QTt40P-r0XCN_"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@kellysikkema?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kelly Sikkema</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="63cf" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">上周，我写了一篇关于冒泡排序的博客。继续我学习排序算法的旅程，让我们进行下一步，看看选择排序。</p><p id="7294" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">与比较相邻元素的冒泡排序不同，选择排序的工作方式是遍历数组，找到最小(或最大，取决于是按升序还是降序排序)的元素，并将其移动到数组的开头。从这里开始，它循环遍历除已经设置好的元素之外的所有元素，直到遍历完整个数组。</p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h1 id="cd8e" class="lw lx in bd ly lz ma mb mc md me mf mg jt mh ju mi jw mj jx mk jz ml ka mm mn bi translated">分步示例</h1><h2 id="d212" class="mo lx in bd ly mp mq dn mc mr ms dp mg lc mt mu mi lg mv mw mk lk mx my mm mz bi translated">预期结果</h2><p id="7554" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">升序排序<br/>输入:[4，2，5，1，3，6] <br/>输出:[1，2，3，4，5，6]</p><h2 id="b1ef" class="mo lx in bd ly mp mq dn mc mr ms dp mg lc mt mu mi lg mv mw mk lk mx my mm mz bi translated">第一次迭代</h2><p id="72cc" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">让我们遍历数组，找到最小值，并跟踪它的索引。我们从第一个元素(索引0)开始。</p><p id="0dd9" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">minIndex = 0 <br/> [ <strong class="kv io"> 4 </strong>，2，5，1，3，6]</p><p id="7969" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4大于2，所以现在minIndex = 1 <br/> [4，<strong class="kv io"> 2 </strong>，5，1，3，6]</p><p id="38ab" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2小于5，所以minIndex = 1 <br/> [4，<strong class="kv io"> 2 </strong>，5，1，3，6]</p><p id="9523" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2大于1，所以minIndex = 3 <br/> [4，2，5，<strong class="kv io"> 1 </strong>，3，6]</p><p id="3790" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1小于3，所以minIndex = 3 <br/> [4，2，5，<strong class="kv io"> 1 </strong>，3，6]</p><p id="6872" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">1小于6，所以minIndex = 3 <br/> [4，2，5，<strong class="kv io"> 1 </strong>，3，6]</p><p id="0942" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我们已经确定最小值在索引3处。我们将把索引为0的元素与最小索引处的元素进行交换。现在数组看起来是这样的:<br/> [ <strong class="kv io"> 1 </strong>，2，5，<strong class="kv io"> 4 </strong>，3，6]</p><h2 id="c3d0" class="mo lx in bd ly mp mq dn mc mr ms dp mg lc mt mu mi lg mv mw mk lk mx my mm mz bi translated">第二次迭代</h2><p id="33a8" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">因为我们已经在索引0处放置了最小的数字，所以我们从索引1开始迭代，以找到数组中第二个最小的数字。</p><p id="1875" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">minIndex = 1 <br/> [1，<strong class="kv io"> 2 </strong>，5，4，3，6]</p><p id="8533" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2 &lt; 5, minIndex = 1<br/> [1，<strong class="kv io"> 2 </strong>，5，4，3，6]</p><p id="f8b4" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2 &lt; 4, minIndex = 1<br/> [1，<strong class="kv io"> 2 </strong>，5，4，3，6]</p><p id="2326" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2 &lt; 3, minIndex = 1<br/> [1，<strong class="kv io"> 2 </strong>，5，4，3，6]</p><p id="bd24" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">2 &lt; 6, minIndex = 1<br/> [1，<strong class="kv io"> 2 </strong>，5，4，3，6]</p><p id="1916" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">minIndex从未更改，所以我们不需要执行交换。</p><h2 id="4077" class="mo lx in bd ly mp mq dn mc mr ms dp mg lc mt mu mi lg mv mw mk lk mx my mm mz bi translated">第三次迭代</h2><p id="41c7" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">从索引2开始。</p><p id="0521" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">minIndex = 2 <br/> [1，2，<strong class="kv io"> 5 </strong>，4，3，6]</p><p id="5312" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">5 &gt; 4，minIndex = 3 <br/> [1，2，5，<strong class="kv io"> 4 </strong>，3，6]</p><p id="7a94" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">4 &gt; 3，minIndex = 4 <br/> [1，2，5，4，<strong class="kv io"> 3 </strong>，6]</p><p id="7fa6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">3&lt; 6, minIndex = 4<br/>【1，2，5，4，<strong class="kv io"> 3 </strong>，6】</p><p id="9504" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">交换5和3，数组现在看起来是这样的:<br/>【1，2，<strong class="kv io"> 3 </strong>，4，<strong class="kv io"> 5 </strong>，6】</p><h2 id="e9a6" class="mo lx in bd ly mp mq dn mc mr ms dp mg lc mt mu mi lg mv mw mk lk mx my mm mz bi translated">最终迭代</h2><p id="e37e" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">即使我们的数组已经排序了，我们仍然要为索引3和4遍历数组2次(当我们到达索引5的最后一个元素时，<em class="nf">它必须是最大值</em>，所以我们不需要再次迭代)。</p><h1 id="445f" class="lw lx in bd ly lz ng mb mc md nh mf mg jt ni ju mi jw nj jx mk jz nk ka mm mn bi translated">密码</h1><p id="95ff" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">是写代码的时候了！</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="67aa" class="mo lx in nm b gy nq nr l ns nt">function selectionSort(arr){<br/>    for(let i = 0; i &lt; arr.length - 1; i++){<br/>        let minIndex = i;</span><span id="db5d" class="mo lx in nm b gy nu nr l ns nt">        for(let j = i + 1; j &lt; arr.length; j++){<br/>            if(arr[j] &lt; arr[minIndex]){<br/>                minIndex = j;<br/>            }<br/>        }</span><span id="a174" class="mo lx in nm b gy nu nr l ns nt">        if(i !== minIndex){<br/>            let temp = arr[i];<br/>            arr[i] = arr[minIndex];<br/>            arr[minIndex] = temp; <br/>        }<br/>    }</span><span id="6ecd" class="mo lx in nm b gy nu nr l ns nt">    return arr;<br/>};</span></pre><h2 id="4d19" class="mo lx in bd ly mp mq dn mc mr ms dp mg lc mt mu mi lg mv mw mk lk mx my mm mz bi translated">解释代码</h2><p id="3f4c" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">因为我们知道我们需要检查数组中的每个元素，所以我们设置了一个<code class="fe nv nw nx nm b">for</code>循环来运行数组的长度减1，因为当我们到达最后一个元素时，我们知道它已经排序了。每次迭代，<code class="fe nv nw nx nm b">minIndex</code>的起始值将是该索引处的数字。因此，对于第一次迭代，<code class="fe nv nw nx nm b">minIndex</code>将是0，对于第二次它将是1，就像我们的一步一步的例子。</p><p id="7a2f" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">从那里我们需要检查之后的所有元素<em class="nf">，这就是为什么我们的嵌套<code class="fe nv nw nx nm b">for</code>循环有从<code class="fe nv nw nx nm b">i + 1</code>开始的<code class="fe nv nw nx nm b">j</code>。当它遍历其余元素时，如果它们中的任何一个小于索引<code class="fe nv nw nx nm b">i</code>处的值，它将改变<code class="fe nv nw nx nm b">minIndex</code>来反映这一点。</em></p><p id="8ee7" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">一旦我们跳出嵌套的<code class="fe nv nw nx nm b">for</code>循环，回到第一个循环，我们检查<code class="fe nv nw nx nm b">minIndex</code>是否仍然等于<code class="fe nv nw nx nm b">i</code>。如果不相等，这意味着在嵌套循环中的某个点，我们发现一个值小于索引<code class="fe nv nw nx nm b">i</code>处的值，我们需要交换这些值。</p><p id="a15d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">类似于冒泡排序中的交换，我们声明一个名为<code class="fe nv nw nx nm b">temp</code>的变量来保存当前在索引<code class="fe nv nw nx nm b">i</code>处的内容，然后我们将索引<code class="fe nv nw nx nm b">i</code>处的值更改为最小值。之后，我们将原来位于索引<code class="fe nv nw nx nm b">i</code> ( <code class="fe nv nw nx nm b">temp</code>)的值分配给原来最小值所在的位置。有效地交换元素。</p><h1 id="27a0" class="lw lx in bd ly lz ng mb mc md nh mf mg jt ni ju mi jw nj jx mk jz nk ka mm mn bi translated">时间和空间复杂性</h1><h2 id="fffe" class="mo lx in bd ly mp mq dn mc mr ms dp mg lc mt mu mi lg mv mw mk lk mx my mm mz bi translated">时间复杂度</h2><p id="63c4" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">与冒泡排序不同，我们不必每次迭代都从数组的开头开始，因为每次迭代我们都将一个元素放在正确的位置。这意味着每次外<code class="fe nv nw nx nm b">for</code>循环迭代，内<code class="fe nv nw nx nm b">for</code>循环将少运行1次。</p><p id="8447" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着在我们的例子中，数组中有6个元素，</p><p id="4836" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在第一次迭代中，我们经历了5个元素。第二天我们经历了4次。第三天，我们经历了3。第四天我们经历了2。最后我们还剩1个。</p><p id="5387" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以5 + 4 + 3 + 2 + 1 = 15。</p><p id="536d" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">另一种思考方式是(6 *(6–1))/2 = 15。</p><p id="a826" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">所以根据我们的输入n * (n-1) * 1/2</p><p id="11a6" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，当从大O符号的角度考虑这一点时，我们将考虑是什么导致了最高的增长率，因此这简化为O(n)。最佳情况、最差情况和一般情况都是O(n ),因为不管数组是否已经排序，选择排序将继续对给定的输入运行相同的次数。</p><h2 id="4962" class="mo lx in bd ly mp mq dn mc mr ms dp mg lc mt mu mi lg mv mw mk lk mx my mm mz bi translated">空间复杂性</h2><p id="7830" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">就像冒泡排序一样，选择排序就地排序。这意味着该算法占用的内存空间不依赖于输入，空间复杂度为O(1)。换句话说，时间不变。</p><h1 id="41a4" class="lw lx in bd ly lz ng mb mc md nh mf mg jt ni ju mi jw nj jx mk jz nk ka mm mn bi translated">不稳定排序算法</h1><p id="c464" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">选择排序是一种不稳定的排序算法。让我们花点时间来谈谈这意味着什么。不稳定意味着数组中相同的两个值不一定会保持排序后的顺序。对于充满数字或字符串等原始数据类型的数组来说，这没有太大意义。</p><p id="7e30" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">然而，让我们考虑我们正在排序一个对象数组，代表学生。我们想按等级对它们进行排序，但是我们当前的数组是按字母顺序排序的。在按成绩排序的同时，我们也希望保持字母顺序。以便所有一年级的学生按字母顺序出现，然后所有二年级的学生按字母顺序出现，依此类推。</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="15b9" class="mo lx in nm b gy nq nr l ns nt">let studentArr = [{name: "Al Cooper" , grade: 4}, {name: "Bobby Tables" , grade: 4}, {name: "Gracie Hopper" , grade: 3}]</span></pre><p id="9308" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们将数组传递给选择排序，它会输出</p><pre class="kd ke kf kg gt nl nm nn no aw np bi"><span id="7705" class="mo lx in nm b gy nq nr l ns nt">[<!-- -->{name: "Gracie Hopper" , grade: 3}, {name: "Bobby Tables" , grade: 4}, {name: "Al Cooper" , grade: 4}<!-- -->]</span></pre><p id="5ea1" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">哦不！我们想让鲍比·表在阿尔·库珀之后出现。不幸的是，选择排序只会考虑等级，首先将格雷西移到列表的前面，将艾尔移到她的位置。从那里开始，它们按等级排序，因此算法不会再交换。也就是说，尽管Al和Bobby都是4年级的，但是他们的排列顺序和我们原来的不同。</p><h1 id="acd7" class="lw lx in bd ly lz ng mb mc md nh mf mg jt ni ju mi jw nj jx mk jz nk ka mm mn bi translated">总之…</h1><p id="45db" class="pw-post-body-paragraph kt ku in kv b kw na jo ky kz nb jr lb lc nc le lf lg nd li lj lk ne lm ln lo ig bi translated">选择排序是另一个简单的排序算法，你通常不会看到在现实世界中使用。这是因为像冒泡排序一样，它具有O(n)时间复杂度，并且不能很好地扩展到大型列表。它的好处是它在小列表上表现很好，并且它是常数时间。除此之外，其他一些排序算法，如堆排序，都是基于选择排序的。</p></div></div>    
</body>
</html>