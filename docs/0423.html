<html>
<head>
<title>Algorithms 101: Learn Recursion with Nesting Dolls in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:学习JavaScript中嵌套玩偶的递归</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-learn-recursion-with-nesting-dolls-javascript-a8c334fe65f6?source=collection_archive---------5-----------------------#2019-10-11">https://javascript.plainenglish.io/algorithms-101-learn-recursion-with-nesting-dolls-javascript-a8c334fe65f6?source=collection_archive---------5-----------------------#2019-10-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d672" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">Noob诉算法#12，递归的另一个例子</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/da0dbedc1efaaeb5d923e64c257c4b5b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nmuiKeZ6Xyx3EcB5c-Tkxw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">from nestingdolls.co</figcaption></figure><p id="b4fc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我的上一篇文章中，我用公主和豌豆的例子讲述了Ruby中的递归。如果您理解了这一点，并想尝试一个更复杂的例子，让我们看看JavaScript中的另一个例子。</p><p id="ec34" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">首先:递归是一个调用自身的函数。递归的一个经典用法是遍历文件树。</p><h1 id="83b6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">嵌套玩偶</h1><p id="06d2" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">打开文件树中的文件夹，以及这些文件夹中的文件夹，有点像打开嵌套玩偶。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mp mq l"/></div></figure><p id="3dc0" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">假设一个朋友给你一套套娃。在打开的最小的娃娃里面，你会发现两样东西中的一个:一颗钻石！)或者什么都没有。</p><p id="f538" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你将如何编写说明来确定你的套装是有钻石还是没有钻石？</p><h1 id="47ee" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">搜索步骤</h1><ol class=""><li id="c5fe" class="mr ms iq kx b ky mk lb ml le mt li mu lm mv lq mw mx my mz bi translated">打开娃娃。</li><li id="d97b" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">如果你找到了钻石，你的工作就完成了！</li><li id="58ac" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">如果你找到一个洋娃娃，打开它。</li><li id="d70d" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">如果你找到了钻石，你的工作就完成了！</li><li id="3243" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">如果你找到一个洋娃娃，打开它。</li><li id="3015" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">如果你找到了钻石，你的工作就完成了！</li><li id="d061" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">如果你找到一个洋娃娃…</li></ol><p id="b595" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这里有一个模式。让我们浓缩一下:</p><ol class=""><li id="402a" class="mr ms iq kx b ky kz lb lc le nf li ng lm nh lq mw mx my mz bi translated">打开娃娃</li><li id="8683" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">如果你找到了钻石，你的工作就完成了！跳过第3步。</li><li id="611e" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">如果你找到一个洋娃娃，从第一步开始。</li></ol><p id="2a9c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这是我们的嵌套玩偶在代码中的样子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ni"><img src="../Images/6761d634f9092b5efa9009dcc0b67343.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WGoePKKkCEfph2V14DbVZw.png"/></div></div></figure><p id="2900" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">外面的娃娃是<em class="nj">doll 1</em>；当你打开它，你会发现<em class="nj">美元2 </em>等。直到最后，你打开<em class="nj">美元，找到一颗钻石。</em></p><h1 id="3cb2" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">基础案例，急需的出口！</strong></h1><p id="4c2d" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">递归最重要的部分是基本情况——当满足条件时，函数停止调用自身。如果没有基本情况，递归函数就会无限循环下去。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="nk mq l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">recursive search with no base case = infinite loop!</figcaption></figure><p id="ff83" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">定义基本情况最简单的方法是:我什么时候应该停止寻找？</p><p id="94bd" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们的例子中，我们需要两个基本案例。如果出现以下情况，我们希望停止寻找:</p><ol class=""><li id="cc9c" class="mr ms iq kx b ky kz lb lc le nf li ng lm nh lq mw mx my mz bi translated">我们打开了所有的娃娃却没有找到钻石，或者</li><li id="b8ab" class="mr ms iq kx b ky na lb nb le nc li nd lm ne lq mw mx my mz bi translated">我们打开了所有的娃娃，找到了钻石。</li></ol><p id="005a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在代码中:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nl"><img src="../Images/0e9f2bb509238a91c983766048339ec9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TkKRpyZVmEL07naXtKNAcA.png"/></div></div></figure><p id="fc05" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第16-17行涵盖了我们打开所有娃娃却没有找到钻石的情况。(我们如何知道是否已经到达最后一个娃娃？因为最后一个娃娃要么什么都没有，要么是一颗钻石。如果我们找到一个娃娃，它一定是最后一个娃娃。)</p><p id="5a5a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第18–19行涵盖了我们打开一个非空娃娃并找到一颗钻石的情况。</p><h1 id="747b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">递归</h1><p id="37d1" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">现在让我们编写搜索说明。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nm"><img src="../Images/422dbd89d6f7c3dda77e71501b54ee51.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8-oUpaO6l4g7i1xcAlO5ow.png"/></div></div></figure><p id="41c9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们打开它。</p><p id="0c5f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">每次打开一个娃娃，我们都想知道——里面是不是还有一个娃娃(数组)？我们使用第21行来检查当前娃娃是否是一个数组。</p><p id="8a44" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果是这样，我们将那个娃娃(名为<em class="nj"> current) </em>的数组传递回函数中，并重新开始。</p><p id="3b22" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">重要:我们不只是再次调用函数；我们说我们想返回这个函数的结果。结果在基本情况下定义。如果我们没有在第22行的开头包含“return result ”,我们就不会返回任何东西。</p><p id="0eea" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看看整个函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/2c326e4b556963eb5576bb9f5b04eb81.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oqeu9MM82S_NRd8ai1qp5A.png"/></div></div></figure><p id="5324" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">第一次通过循环，我们检查以确保我们确实在看一些东西。我们看到的是<em class="nj"> doll1 </em>，这是一个长度为1的数组。</p><p id="5898" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以我们跳到第20行，遍历<em class="nj"> doll1 </em>的内容。我们找到<em class="nj"> doll2 </em>，把它传回来，检查它是否是空的，或者它的第一个项目是否是“钻石”。两者都不成立，所以我们回到第20行，迭代内容并找到<em class="nj"> doll3 </em>。诸如此类…</p><p id="0050" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">最后，我们到了最后一个娃娃，<em class="nj">娃娃5 </em>。当我们将它反馈到函数中时，它满足第16行的基本情况的条件。即<em class="nj"> doll5 </em>内的第一项是<em class="nj">钻石</em>！</p><p id="d596" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">所以我们返回<code class="fe no np nq nr b">result = “found!"</code>。现在有结果了，22号线终于有回报了！所以我们的函数结束了。</p><p id="b6f5" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">你可以<a class="ae lr" href="https://repl.it/@Joan_IndianaInd/LemonchiffonGranularSpellchecker" rel="noopener ugc nofollow" target="_blank">在repl.it上玩这个代码。</a>试着把<em class="nj"> doll5 </em>改成<em class="nj"> [] </em>看看没有方块的时候会发生什么。</p><h1 id="4e7f" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">需要更温和的递归介绍吗？</h1><p id="21fc" class="pw-post-body-paragraph kv kw iq kx b ky mk jr la lb ml ju ld le mm lg lh li mn lk ll lm mo lo lp lq ij bi translated">试试我之前关于递归的帖子，<a class="ae lr" href="https://medium.com/@joanrigdon/algorithms-101-princesses-peas-and-recursion-in-ruby-dffb44799d6e" rel="noopener"> <em class="nj">算法101，#11:公主，豌豆&amp;Ruby中的递归。</em>T24】</a></p><p id="c115" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://medium.com/javascript-in-plain-english/algorithms-101-pascals-triangle-in-javascript-9fbd9032871" rel="noopener"> <em class="nj">接下来:算法101，# 13:JavaScript中的帕斯卡三角</em> </a></p><p id="8535" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">版权所有琼·印第安纳·琳斯2019</p></div></div>    
</body>
</html>