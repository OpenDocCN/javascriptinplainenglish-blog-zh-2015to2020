<html>
<head>
<title>Four super useful techniques in vanilla JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">普通JavaScript中的四个超级有用的技术</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/four-super-useful-techniques-in-vanilla-js-896bab184574?source=collection_archive---------3-----------------------#2020-05-27">https://javascript.plainenglish.io/four-super-useful-techniques-in-vanilla-js-896bab184574?source=collection_archive---------3-----------------------#2020-05-27</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9824" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">复制到剪贴板，加速递归函数，获得文件扩展名和正确洗牌数组</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b424bcba20ddd192d8c6cd0e1e1026f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LeYBjLHr6kmYIoSx-aHdDA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Two monitors with code</figcaption></figure><h2 id="0814" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">索引</h2><ul class=""><li id="0afd" class="lr ls iq lt b lu lv lw lx le ly li lz lm ma mb mc md me mf bi translated">使用记忆化来加速递归函数(基准)</li><li id="f10c" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">复制到剪贴板</li><li id="9919" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">获取文件扩展名</li><li id="2b21" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb mc md me mf bi translated">打乱数组</li></ul><h2 id="31e6" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">使用记忆来加速递归函数</h2><p id="f3d2" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">内存化是一种优化技术，通过在函数初始执行后缓存函数返回，使长递归(或迭代)函数运行得更快。</p><p id="1a2c" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">我们创建一个缓存，如果输入之前已经计算过，我们在缓存中找到相应的值并返回它。如果输入没有被计算，我们计算它并把它插入缓存。</p><p id="ffdf" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">让我们来看一个计算一个数字的斐波纳契数列的例子:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="48b8" class="kv kw iq ne b gy ni nj l nk nl">let fib = n =&gt; {<br/>  return n &lt;= 1 ? n : fib(n - 1) + fib(n - 2);<br/>}</span><span id="738c" class="kv kw iq ne b gy nm nj l nk nl">fib( 15 );</span></pre><p id="2edc" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">它可以工作，但是效率非常低，而且需要大量重复的计算工作。</p><p id="cc4b" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">我们可以使用缓存映射来存储之前计算的值，并加快整体执行速度:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="0f6f" class="kv kw iq ne b gy ni nj l nk nl">let  cacheMap = new Map();</span><span id="98a5" class="kv kw iq ne b gy nm nj l nk nl">let fib = n =&gt; {</span><span id="7d27" class="kv kw iq ne b gy nm nj l nk nl">    //1.<br/>    if ( cacheMap.has( n ) ) {<br/>        return cacheMap.get( n );<br/>    }</span><span id="9207" class="kv kw iq ne b gy nm nj l nk nl">    //2.<br/>    let result = n &lt;= 1 ? n : fib( n - 1 ) + fib( n - 2 );</span><span id="12e7" class="kv kw iq ne b gy nm nj l nk nl">    //3.<br/>    cacheMap.set( n, result );</span><span id="c667" class="kv kw iq ne b gy nm nj l nk nl">return result;<br/>}</span><span id="a3d2" class="kv kw iq ne b gy nm nj l nk nl">fib( 15 );</span></pre><ol class=""><li id="3428" class="lr ls iq lt b lu my lw mz le nn li no lm np mb nq md me mf bi translated">如果结果在缓存中，则从缓存中获取。</li><li id="34be" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb nq md me mf bi translated">计算新的结果。</li><li id="7e02" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb nq md me mf bi translated">将结果保存在缓存中。</li></ol><p id="56a8" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated"><em class="nr">注意，缓存版本正在缓存</em>斐波那契函数调用的结果值，<em class="nr">如果结果已经在缓存中，这将显著加快计算速度。</em></p><p id="f01d" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">您可以在<a class="ae ns" href="https://jsperf.com/" rel="noopener ugc nofollow" target="_blank"> jsperf </a>中运行和测试不同的解决方案。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/cac9c5535c3301a1e48dd3a0b9056277.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0v-aNqGl3clliwTYeyRBKg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of no cached version vs. the cached version</figcaption></figure><p id="e487" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">缓存版本每秒执行638，262次操作，占8.02%，而非内存版本每秒执行60，492次操作，占7.13%。</p><p id="12aa" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">同样，我们可以定义一个高阶函数<a class="ae ns" href="https://en.wikipedia.org/wiki/Higher-order_function" rel="noopener ugc nofollow" target="_blank">,它接受一个函数作为它的参数，并返回它自己的记忆版本。</a></p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="30b5" class="kv kw iq ne b gy ni nj l nk nl">function fib(n) {<br/> return n &lt;= 1 ? n : fib(n - 1) + fib(n - 2);<br/>}</span><span id="9cf7" class="kv kw iq ne b gy nm nj l nk nl">function memoize(fn) {<br/>    var cache = {};<br/>    return function(x) {<br/>        return x in cache ? cache[x] : cache[x] = fn.apply(this,   <br/>        arguments);<br/>    };<br/>}</span><span id="a09e" class="kv kw iq ne b gy nm nj l nk nl">// redefine factorial to be its memoized version<br/>fib = memoize(fib);</span><span id="0370" class="kv kw iq ne b gy nm nj l nk nl">fib( 15 );</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/fb61101055056db225ee9a2e8f6df41a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7dKWFMSslvFKFXQa12DeJw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Result of no cached version vs. the cached version</figcaption></figure><p id="bb66" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">内存化版本每秒执行242，282次操作，占2.51%，而非内存化版本每秒执行59040次操作，占9.54%。</p><p id="9987" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated"><em class="nr">注意，结果不仅取决于算法，还取决于机器的状态。</em></p><p id="f07e" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">记忆化有很多优点，如果计算函数的返回值需要一些时间，那么用简单的查找代替它可以节省大量时间。我们还可以避免许多递归调用，因为计算值意味着进入递归调用的。</p><p id="f328" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">通常，如果我们对多次计算相同的值感兴趣，我们应该使用记忆化。</p><h2 id="6acd" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">复制到剪贴板</h2><p id="d3f0" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">在下面的例子中，我创建了一个普通的“复制到剪贴板”按钮。这是实现复制到剪贴板功能的最简单的方法，但是不好的是我们必须添加一个文本区域来选择要复制到剪贴板的文本。</p><p id="cb89" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated"><em class="nr">你可以在类似</em><a class="ae ns" href="https://jsbin.com/?html,output" rel="noopener ugc nofollow" target="_blank"><em class="nr">JS Bin</em></a><em class="nr">这样的在线编辑器中尝试下面的代码，或者将其保存在. html文件中，用chrome这样的浏览器打开。</em></p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="08a9" class="kv kw iq ne b gy ni nj l nk nl">&lt;!DOCTYPE html&gt;<br/>&lt;html&gt;</span><span id="8d32" class="kv kw iq ne b gy nm nj l nk nl">&lt;body&gt;<br/>&lt;h1&gt;Write something:&lt;/h1&gt;</span><span id="12f7" class="kv kw iq ne b gy nm nj l nk nl">&lt;textarea id="textareaId" rows="4" cols="50"&gt;&lt;/textarea&gt;<br/>&lt;/br&gt;</span><span id="6cf6" class="kv kw iq ne b gy nm nj l nk nl">&lt;button type="button" onclick="copyToClipboard();"&gt;Copy to clipboard&lt;/button&gt;</span><span id="68f4" class="kv kw iq ne b gy nm nj l nk nl">&lt;p&gt;Paste here the clipboard content to verify that it works:&lt;/p&gt; <br/>&lt;p&gt;(but you can paste the content wherever you wants)&lt;/p&gt;</span><span id="d8e0" class="kv kw iq ne b gy nm nj l nk nl">&lt;textarea id="textarea2Id" rows="10" cols="50"&gt;&lt;/textarea&gt;<br/>  <br/>&lt;script&gt;<br/>  const <strong class="ne ir">copyToClipboard</strong> = () =&gt; {<br/>     //1.<br/>     document.querySelector('#textareaId').select();<br/>     //2.<br/>     document.execCommand('copy');<br/>  }; <br/>&lt;/script&gt;<br/>  <br/>&lt;/body&gt;<br/>&lt;/html&gt;</span></pre><ol class=""><li id="8385" class="lr ls iq lt b lu my lw mz le nn li no lm np mb nq md me mf bi translated">使用HTMLInputElement.select()选择<textarea>元素的内容。</textarea></li><li id="d3f1" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb nq md me mf bi translated">使用Document.execCommand('copy ')将<textarea>的内容复制到剪贴板。</textarea></li></ol><h2 id="8cf9" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">获取文件扩展名</h2><p id="6127" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">有时你需要获得一个文件的扩展名，这里有一个简单的方法，使用slice和lastIndexOf方法:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="a025" class="kv kw iq ne b gy ni nj l nk nl">let file1 = "file1.doc";<br/>let file2 = "file2.txt";<br/>let file3 = "file3";<br/>let file4 = "file4.a.b.jpg";<br/>let file5 = "/home/tmp/file4.a.b.jpg";</span><span id="2e18" class="kv kw iq ne b gy nm nj l nk nl">const getExt = (path) =&gt; {<br/>   //1.<br/>   let root = path.split(/[\\/]/).pop();<br/>   //2.<br/>   let pos  = root.lastIndexOf('.');<br/>   //3.<br/>   let extension = (root === '' || pos &lt; 1) ? '' :<br/>   //4.<br/>   root.slice(pos + 1);<br/>return extension;<br/>}</span><span id="afab" class="kv kw iq ne b gy nm nj l nk nl">console.log(getExt(file1)); <br/>//xsl</span><span id="b07b" class="kv kw iq ne b gy nm nj l nk nl">console.log(getExt(file2));<br/>//txt</span><span id="fe08" class="kv kw iq ne b gy nm nj l nk nl">console.log(getExt(file3));<br/>//''</span><span id="64f2" class="kv kw iq ne b gy nm nj l nk nl">console.log(getExt(file4));<br/>//jpg</span><span id="afa2" class="kv kw iq ne b gy nm nj l nk nl">console.log(getExt(file5));<br/>//jpg</span></pre><ol class=""><li id="bcf7" class="lr ls iq lt b lu my lw mz le nn li no lm np mb nq md me mf bi translated">从完整路径中提取文件名(如果传递了完整路径)。</li><li id="90c2" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb nq md me mf bi translated">获取“.”的索引</li><li id="67cd" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb nq md me mf bi translated">如果文件名为空或“.”找不到(-1)或先出现(0)。</li><li id="a73e" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb nq md me mf bi translated">从pos+1扩展名中提取文件名，忽略“.”</li></ol><h2 id="906a" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">打乱数组</h2><p id="04cd" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">打乱一组值是计算中最古老的问题之一，我们有不同的方法来解决它。在这里，我们将看到在javascript中实现这一点的两种最常见的方法。</p><p id="a5d5" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">第一种解决方案:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="2422" class="kv kw iq ne b gy ni nj l nk nl">array.sort(function (a, b) { return 0.5 — Math.random() })</span></pre><p id="bfb2" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">如果你传递给sort的函数是“比较函数”,并且它小于0，元素“a”优先；否则，元素“b”优先。0.5 Math.random()将给出大约50%负数和50%正数的随机数。</p><p id="b26e" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">乍一看，这似乎是一个有效的解决方案。该代码使用javascript的sort函数和一个0.5到-0.5之间的自定义比较器。这种排序算法有各种各样的问题。一个是排列的可能性不一样，因为array.sort()更喜欢一些数字。</p><p id="bbee" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">更好的解决方案是使用费希尔-耶茨洗牌法:</p><p id="8b77" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated"><em class="nr"/><a class="ae ns" href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle" rel="noopener ugc nofollow" target="_blank"><em class="nr">费希尔-亚特</em> </a> <em class="nr"> s shuffle是一种生成有限序列随机排列的算法。它打乱了每种排列都具有同等可能性的序列。</em></p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="9bf1" class="kv kw iq ne b gy ni nj l nk nl">const shuffle = (array) =&gt; {<br/>  let currentIndex = array.length;<br/>  let tmpValue;<br/>  let randomIndex;<br/>  let i = currentIndex-1;</span><span id="6ad0" class="kv kw iq ne b gy nm nj l nk nl">  //1<br/>  while (0 !== currentIndex) {</span><span id="81cd" class="kv kw iq ne b gy nm nj l nk nl">    //2<br/>    randomIndex = Math.floor(Math.random() * currentIndex);<br/>    currentIndex = i--;</span><span id="b8ee" class="kv kw iq ne b gy nm nj l nk nl">    //3<br/>    tmpValue = array[currentIndex];<br/>    array[currentIndex] = array[randomIndex];<br/>    array[randomIndex] = tmpValue;<br/>  }</span><span id="05e7" class="kv kw iq ne b gy nm nj l nk nl">return array;<br/>}</span></pre><ol class=""><li id="5e86" class="lr ls iq lt b lu my lw mz le nn li no lm np mb nq md me mf bi translated">如果我们有要洗牌的元素，重复这个步骤。</li><li id="2a8f" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb nq md me mf bi translated">选择剩余的元素。</li><li id="5c5c" class="lr ls iq lt b lu mg lw mh le mi li mj lm mk mb nq md me mf bi translated">用当前元素替换它。</li></ol><p id="092d" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">示例:</p><pre class="kg kh ki kj gt nd ne nf ng aw nh bi"><span id="1e09" class="kv kw iq ne b gy ni nj l nk nl">//Example:<br/>let arr = [1,2,3,4,5,9,8,7,6];</span><span id="1904" class="kv kw iq ne b gy nm nj l nk nl">console.log(shuffle(arr));<br/>//[4, 1, 3, 6, 7, 9, 2, 8, 5]</span><span id="f8fe" class="kv kw iq ne b gy nm nj l nk nl">console.log(shuffle(arr));<br/>//[2, 7, 4, 6, 5, 1, 3, 8, 9]</span><span id="5f71" class="kv kw iq ne b gy nm nj l nk nl">...</span></pre><p id="476e" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated"><em class="nr">请注意，所有纯软件算法都是伪随机的，除非它们与硬件相连以生成真正随机的种子。</em></p><h2 id="1e99" class="kv kw iq bd kx ky kz dn la lb lc dp ld le lf lg lh li lj lk ll lm ln lo lp lq bi translated">结论</h2><p id="8fd6" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">在本文中，我谈到了开发应用程序时可能出现的需求，以及我们如何以最佳方式直接解决这些需求。如果这对你有帮助，那就值得写下来。</p><p id="f370" class="pw-post-body-paragraph ml mm iq lt b lu my jr mn lw mz ju mo le na mq mr li nb mt mu lm nc mw mx mb ij bi translated">感谢您花时间阅读我的文章！</p><h1 id="c92e" class="nv kw iq bd kx nw nx ny la nz oa ob ld jw oc jx lh jz od ka ll kc oe kd lp of bi translated"><strong class="ak">简明英语笔记</strong></h1><p id="a1b1" class="pw-post-body-paragraph ml mm iq lt b lu lv jr mn lw lx ju mo le mp mq mr li ms mt mu lm mv mw mx mb ij bi translated">你知道我们有四份出版物和一个YouTube频道吗？你可以在我们的主页<a class="ae ns" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="lt ir">plain English . io</strong></a>找到所有这些内容——关注我们的出版物并<a class="ae ns" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="lt ir">订阅我们的YouTube频道</strong> </a> <strong class="lt ir">来表达你的爱吧！</strong></p></div></div>    
</body>
</html>