<html>
<head>
<title>9 Ways To Optimize Node.js Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">优化Node.js应用程序的9种方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/9-ways-to-optimize-node-js-applications-2d1444b02985?source=collection_archive---------4-----------------------#2020-12-30">https://javascript.plainenglish.io/9-ways-to-optimize-node-js-applications-2d1444b02985?source=collection_archive---------4-----------------------#2020-12-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="4958" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">构建更好的优化Node.js应用程序</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/135f379f297989cd371b681e456c6ba7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*QC9oYFCMji-PPN3z.png"/></div></div></figure><h1 id="474b" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">1.使用异步函数区分优先级。</h1><p id="f1f9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Node.js最好的部分是所有的异步函数执行一个<strong class="ll ir">非阻塞I/O来避免CPU空闲。</strong>对于运行大量I/o的应用程序，仅使用<strong class="ll ir"><em class="mf"/></strong>异步函数将使服务器的性能大大提高。因为现在服务器将能够同时处理多个请求，而其中一个请求正在执行I/O。</p><p id="5582" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">例如:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ml"><img src="../Images/289bb1f858a326ebcf6070943f6e4f1d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U7VZb7ybX-wvo10otUJWqA.png"/></div></div></figure><h1 id="4c8e" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">2.将Ngnix用于静态服务器。</h1><p id="bce7" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">这个选择背后的简单原因就是<strong class="ll ir"> <em class="mf">节点</em> </strong>。js只是在处理数据方面表现更好，而不是服务静态文件，所以用<strong class="ll ir"> Nginx </strong>或<strong class="ll ir"> Apache </strong>代替它。它们有很多配置，可以通过有用的缓存方法来提供静态文件。</p><blockquote class="mm"><p id="3f73" class="mn mo iq bd mp mq mr ms mt mu mv me dk translated"><strong class="ak">仅将节点服务器用于处理数据。</strong></p></blockquote><h1 id="a422" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw mw jx ld jz mx ka lf kc my kd lh li bi translated">3.使用集群模块进行并行处理。</h1><p id="0cb2" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">集群模块原生于<strong class="ll ir"> <em class="mf">节点</em> </strong>。js为应用程序创建了许多进程，包括主集群，它作为负载平衡器在所有从集群中分配请求。</p><blockquote class="mm"><p id="a1a5" class="mn mo iq bd mp mq mr ms mt mu mv me dk translated">通过使用所有CPU核心并行工作来优化服务器。</p></blockquote><h1 id="6786" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw mw jx ld jz mx ka lf kc my kd lh li bi translated">4.使用最新但稳定的版本。</h1><p id="9ac9" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">由于<strong class="ll ir"> JavaScript V8运行时引擎</strong>的改进，最新稳定版本的<strong class="ll ir"> Node.js </strong>对于制作稳定和优化的应用程序是必不可少的。</p><h1 id="0a4c" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">5.串联JavaScript。</h1><p id="0a45" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">Web应用程序可以通过将多个<strong class="ll ir"> JS </strong>文件连接成一个文件来加速，当您的浏览器使用<strong class="ll ir"> <em class="mf"> &lt;脚本&gt; </em> </strong>元素时，页面渲染会被阻止，直到获取并执行脚本(除非应用了异步属性)。</p><p id="854b" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">如果你的页面包含8个JavaScript文件，浏览器将发出8个HTTP请求来获取这些文件，这样就可以优化整体性能。</p><h1 id="4f37" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">6.使用标准V8功能。</h1><p id="76cb" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">并不是所有的浏览器都支持常见的操作比如<strong class="ll ir"> <em class="mf"> map，reduce &amp; forEach，</em> </strong>为了克服这个问题我们可以在前端使用一些客户端库。但是在<strong class="ll ir"> Node.js </strong>的情况下，我们知道<strong class="ll ir"> <em class="mf"> Google的V8 JavaScript </em> </strong>引擎支持哪些操作，这样我们就可以使用内置函数在服务器端操作集合。</p><h1 id="92d8" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">7.不要在会话中存储太多。</h1><p id="17e3" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">例如，在一个典型的<strong class="ll ir"> Express </strong> web应用程序中，会话数据默认存储在内存中，当我们在会话中存储太多数据时，它会使服务器不堪重负，因此为了保持简单，您可以切换到其他类型的存储来保存会话数据，或者尝试最小化会话中存储的数据。</p><h1 id="48fc" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated"><strong class="ak"> 8。客户端渲染。</strong></h1><p id="df2a" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">有了客户端的<strong class="ll ir"> MVC/MVV </strong>框架，比如<strong class="ll ir"> <em class="mf"> Angular、Meteor、</em> </strong>等，构建单页面应用是非常容易的。不是在服务器端进行渲染，而是公开一个API，将<strong class="ll ir"> JSON </strong>响应发送到客户端&amp;从服务器发送JSON可以节省<strong class="ll ir"> <em class="mf">带宽</em> </strong>以提高速度，因为我们不是在每个请求中都发送布局标记。</p><h1 id="664d" class="kr ks iq bd kt ku kv kw kx ky kz la lb jw lc jx ld jz le ka lf kc lg kd lh li bi translated">9.将WebSockets用于效果服务器。</h1><p id="f7e0" class="pw-post-body-paragraph lj lk iq ll b lm ln jr lo lp lq ju lr ls lt lu lv lw lx ly lz ma mb mc md me ij bi translated">使用<strong class="ll ir"> <em class="mf"> HTTP </em> </strong>请求模型是web应用程序常见的传统方法，但是<strong class="ll ir"> <em class="mf"> WebSockets </em> </strong>是web应用程序中HTTP通信的替代方法。在客户端和服务器之间提供一个长期的双向通信通道。如果信道保持开放，提供非常持久的连接，那么双方可以在任何时间以低延迟开始发送数据。</p><p id="af03" class="pw-post-body-paragraph lj lk iq ll b lm mg jr lo lp mh ju lr ls mi lu lv lw mj ly lz ma mk mc md me ij bi translated">同时保持大量的连接需要低成本的高质量架构，这就是WebSockets的作用。</p></div></div>    
</body>
</html>