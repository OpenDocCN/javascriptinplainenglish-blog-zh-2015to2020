<html>
<head>
<title>Node.js Tips — Config Files, Validating Strings, Multiple Streams, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示—配置文件、验证字符串、多个流等等</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-config-files-validating-strings-multiple-streams-1d064f49fbc0?source=collection_archive---------5-----------------------#2020-07-15">https://javascript.plainenglish.io/node-js-tips-config-files-validating-strings-multiple-streams-1d064f49fbc0?source=collection_archive---------5-----------------------#2020-07-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/94da1a63e5f0f21c7565c1d55d4e9ea1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*61cqGMydmQ5jU7cN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@zmefc?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Zé Ferrari Careto</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="1d5f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="9330" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js的验证库</h1><p id="1d45" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了验证Node应用程序中的数据，我们可以使用一个库来简化我们的工作。</p><p id="9ae0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以使用<code class="fe me mf mg mh b">validator</code>包。</p><p id="195e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过书写来使用它”</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bb13" class="mq lc iq mh b gy mr ms l mt mu">const check = require('validator').check;<br/>const sanitize = require('validator').sanitize;</span><span id="99b9" class="mq lc iq mh b gy mv ms l mt mu">check('test@email.com').len(6, 64).isEmail();<br/>check('abc').isInt();</span><span id="c4f2" class="mq lc iq mh b gy mv ms l mt mu">const int = sanitize('0123').toInt();<br/>const bool = sanitize('true').toBoolean();</span></pre><p id="45f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用<code class="fe me mf mg mh b">len</code>方法检查电子邮件的长度是否在6和64之间。</p><p id="f6e2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">isEmail</code>方法来检查它是否是一封电子邮件。</p><p id="a56d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">check</code>用验证器方法检查字符串。</p><p id="b451" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">sanitize</code>清理字符串。</p><p id="2420" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">isInt</code>检查整数。</p><p id="db5d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果它无效，那么就会抛出一个异常。</p><p id="acb5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">将字符串转换成整数。</p><p id="9d69" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">toBoolean</code>将字符串转换成布尔值。</p><h1 id="c288" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将相同的可读流通过管道传输到多个可写目标</h1><p id="2c24" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将相同的可读流通过管道传输到多个可写目标。</p><p id="ca43" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="adea" class="mq lc iq mh b gy mr ms l mt mu">const spawn = require('child_process').spawn;<br/>const PassThrough = require('stream').PassThrough;</span><span id="cbf2" class="mq lc iq mh b gy mv ms l mt mu">const a = spawn('ls');<br/>const b = new PassThrough();<br/>const c = new PassThrough();</span><span id="fb38" class="mq lc iq mh b gy mv ms l mt mu">a.stdout.pipe(b);<br/>a.stdout.pipe(c);</span><span id="98b7" class="mq lc iq mh b gy mv ms l mt mu">let output = '';</span><span id="6cb3" class="mq lc iq mh b gy mv ms l mt mu">b.on('data', (chunk) =&gt; {<br/>  output += chunk.length;<br/>});</span><span id="d13f" class="mq lc iq mh b gy mv ms l mt mu">b.on('end', () =&gt; {<br/>  console.log(count);<br/>  c.pipe(process.stdout);<br/>});</span></pre><p id="0ea6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过管道将使用<code class="fe me mf mg mh b">spawn</code>方法运行的<code class="fe me mf mg mh b">ls</code> shell命令的输出传输给<code class="fe me mf mg mh b">PassThrough</code>实例。</p><p id="f8c0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们获得了属性<code class="fe me mf mg mh b">stdout</code>，这是一个可读的流，并对其调用<code class="fe me mf mg mh b">pipe</code>以将其传输到我们用<code class="fe me mf mg mh b">PassThrough</code>构造函数创建的可写流。</p><p id="a8ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我们通过向<code class="fe me mf mg mh b">data</code>和<code class="fe me mf mg mh b">end</code>方法添加监听器来监听流。</p><h1 id="5441" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">。rc配置文件</h1><p id="c58c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">任何人都可以制作<code class="fe me mf mg mh b">.rc</code>文件来创建自己的配置文件。</p><p id="bdc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以创建一个包含JSON的<code class="fe me mf mg mh b">.rc</code>文件。</p><p id="cce2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ada1" class="mq lc iq mh b gy mr ms l mt mu">const fs = require('fs');<br/>fs.readFile('./.barrc', 'utf8', (err, data) =&gt; {<br/>  if (err) {<br/>    return console.error(err);<br/>  }<br/>  console.log(JSON.parse(data));<br/>})</span></pre><p id="70e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">readFile</code>来读取文件，然后我们可以解析存储在其中的JSON。</p><p id="fc94" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它还可以保存YAML或任何其他标准文本格式。</p><h1 id="a8b0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">确定一个字符串是否是MongoDB ObjectID</h1><p id="e09f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">ObjectId.isValid</code>方法来确定一个字符串是否是MongoDB对象ID。</p><p id="3adb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bf14" class="mq lc iq mh b gy mr ms l mt mu">const ObjectId = require('mongoose').Types.ObjectId;<br/>ObjectId.isValid('4738');</span></pre><p id="8f73" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它检查一个字符串是否是12个字符长的字符串，或者它的格式是否正确。</p><h1 id="6e80" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">在MongoDB和Mongoose中执行全文搜索</h1><p id="50ae" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过创建索引在MongoDB中执行全文搜索。</p><p id="3d71" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以用<code class="fe me mf mg mh b">find</code>的方法来搜索我们想要的字段。</p><p id="b7a5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d937" class="mq lc iq mh b gy mr ms l mt mu">const schema = new Schema({<br/>  name: String,<br/>  email: String,<br/>  address: {<br/>    street: String,<br/>  }<br/>});<br/>schema.index({name: 'text', 'address.street': 'text'});</span></pre><p id="d03a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过编写以下内容将所有字段包含在索引中:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6949" class="mq lc iq mh b gy mr ms l mt mu">schema.index({'$**': 'text'});</span></pre><p id="9d1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以通过书写来称呼<code class="fe me mf mg mh b">find</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="784f" class="mq lc iq mh b gy mr ms l mt mu">Person.find({ $text: { $search: search }})<br/>  .skip(20)<br/>  .limit(20)<br/>  .exec((err, docs) =&gt; { <br/>    //... <br/>  });</span></pre><h1 id="f953" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用console.log更新一行，而不是创建一个新行</h1><p id="0585" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以清除现有的行，然后用<code class="fe me mf mg mh b">process</code>模块写入新的行。</p><p id="2a92" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="eb18" class="mq lc iq mh b gy mr ms l mt mu">process.stdout.write("Hello, World");<br/>process.stdout.clearLine();<br/>process.stdout.cursorTo(0);<br/>process.stdout.write("\n");</span></pre><p id="9e11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们用一些文本调用了<code class="fe me mf mg mh b">write</code>来在屏幕上显示它。</p><p id="7972" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们打电话给<code class="fe me mf mg mh b">clearLine</code>来清理线路。</p><p id="da9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用0调用<code class="fe me mf mg mh b">cursorTo</code>将光标移回左侧。</p><p id="d77c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们在屏幕上写下行尾字符。</p><h1 id="d9e0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用Node.js将对象写入文件</h1><p id="be70" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在Node app中把对象写入文件，我们可以用<code class="fe me mf mg mh b">writeFileSync</code>来写。</p><p id="f49a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下内容来编写数组:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="fb3f" class="mq lc iq mh b gy mr ms l mt mu">fs.writeFileSync('./data.json', arr.join(',') , 'utf-8');</span></pre><p id="df98" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">join</code>将条目组合成一个字符串。</p><p id="0617" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe me mf mg mh b">writeFileSync</code>会将字符串写入<code class="fe me mf mg mh b">data.json</code>。</p><p id="2f74" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">要将一个对象的内容写入一个文件，我们可以使用<code class="fe me mf mg mh b">util.inspect</code>将其转换成一个格式化的字符串。</p><p id="92b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们把它写入一个文件。</p><p id="6d9e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9b03" class="mq lc iq mh b gy mr ms l mt mu">const util = require('util');<br/>fs.writeFileSync('./data.json', util.inspect(obj) , 'utf-8');</span></pre><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/7ede52ece907920a4589640c7180279d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OQjRqiiY2_CRB0Z-"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@taylorkopel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Taylor Kopel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c319" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="62cf" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以把一个对象写入一个文件。</p><p id="0230" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们使用一个库，验证字符串是很容易的。</p><p id="36b6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以将可读流通过管道传输到多个写流中。</p><p id="5c42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以用我们想要的任何格式制作我们自己的<code class="fe me mf mg mh b">.rc</code>配置文件。</p><h2 id="0194" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="9f3c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>