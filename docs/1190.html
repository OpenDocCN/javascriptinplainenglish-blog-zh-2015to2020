<html>
<head>
<title>The Beauty of TypeScript for Scalable Serverless Applications</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">可伸缩无服务器应用程序的TypeScript之美</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-beauty-of-typescript-for-scalable-serverless-applications-b2ffbf811a2a?source=collection_archive---------4-----------------------#2020-02-10">https://javascript.plainenglish.io/the-beauty-of-typescript-for-scalable-serverless-applications-b2ffbf811a2a?source=collection_archive---------4-----------------------#2020-02-10</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4662" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">无服务器是这个街区的新成员。这似乎是所有可伸缩性问题的神奇解决方案，同时保持低成本。当我们进入这个领域时，我们很快意识到开发和维护大型应用程序可能不像看起来那么简单。实际上，要把它做好是相当困难的。在这篇文章中，我们将探索使用TypeScript接口来设置跨无服务器资源的契约。</p><h2 id="413f" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">脱钩太棒了！直到它不再…</h2><p id="6add" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">无服务器架构的一个关键概念是让小的功能块相互分离——就像彼此完全分离一样。每一部分都将以不同的速率扩展，从而提供最佳的使用/成本平衡。例如，在一个电子商务web应用程序中，一个负责身份验证的Lambda可能比另一个负责处理信用卡交易的Lambda被调用更多次。</p><p id="a691" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">自然，这些功能块需要通过同步或异步通道(如队列、步骤函数、通知等)相互通信，来回发送数据。人们可以很快看到，随着应用程序的增长，各部分之间的连接数量以指数速度增长。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi lj"><img src="../Images/f5bab5833063393689914c2abbabca48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1258/format:webp/1*_dxy1yrffeDveC7deA0zVA.png"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">A theoretical example of a serverless app with too many interconnections</figcaption></figure><p id="c089" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">如果您的基础架构像这样混乱，那么很容易做出无意的突破性更改，因为很难跟踪什么调用什么。对Lambda的输入格式做一个简单的更改，如果一些调用者没有相应地更新，可能会导致整个系统瘫痪。</p><h2 id="ede3" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated">TypeScript和这一切有什么关系？</h2><blockquote class="lv lw lx"><p id="0616" class="jn jo ly jp b jq jr js jt ju jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj kk ij bi translated">2019年，JavaScript驱动了全球约66%的AWS Lambdas(<a class="ae mc" href="https://thenewstack.io/what-aws-lambdas-performance-stats-reveal/" rel="noopener ugc nofollow" target="_blank">stats</a>)。</p></blockquote><p id="a7ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">TypeScript提供了一种独特的机制来声明易于跨多个代码库应用、扩展和共享的接口和类型。使用TypeScript将减少开发时间，并几乎消除通信格式错误，因为您将确切地知道发送什么以及从Lambda函数中期望什么，即使它是由另一个团队创建的。通过采用“基础设施即代码”的方法满怀信心地维护您的应用程序，在这种方法中，无服务器资源被视为具有定义的输入和输出的另一段代码。</p><p id="120a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">有很多方法可以利用TypeScript，在这篇文章中，我们将探讨几种方法。</p><h1 id="9762" class="md km iq bd kn me mf mg kq mh mi mj kt mk ml mm kw mn mo mp kz mq mr ms lc mt bi translated">请求/响应模式</h1><p id="a548" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">这是最基本的模式，当您有一个Lambda需要某个输入、执行一些处理并输出结果时，这种模式非常有用。这个虽然简单，但是可以预防很多头疼的问题。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi mu"><img src="../Images/84110726179ddfd8f494d8276969dd3e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1056/format:webp/1*Rfy9XMsxgaKLXM0Lynwj4g.png"/></div></figure><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mv mw l"/></div><figcaption class="lr ls gj gh gi lt lu bd b be z dk">Lambda using Request/Response Interfaces with TypeScript</figcaption></figure><p id="8713" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在，当调用这个函数时，您知道它需要一个形状为<code class="fe mx my mz na b">GetGreetingRequest</code>的对象，并且返回的对象将具有由<code class="fe mx my mz na b">GetGreetingResponse</code>定义的属性。注意，这两个接口都是导出的，所以我们可以在调用Lambda:</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="c645" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里我们已经完成了最基本的循环。消费者使用接口来确保输入和输出是预期的。如果后来Lambda随着它的接口一起改变了，那么这段代码就不会编译，从而阻止我们使用过时的格式。</p><h2 id="26ca" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">请求/响应的优点:</strong></h2><ul class=""><li id="f67a" class="nb nc iq jp b jq le ju lf jy nd kc ne kg nf kk ng nh ni nj bi translated">提供类型检查和自动完成</li><li id="c789" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">这很容易实现</li></ul><h2 id="f0d1" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">请求/响应的缺点:</strong></h2><ul class=""><li id="654b" class="nb nc iq jp b jq le ju lf jy nd kc ne kg nf kk ng nh ni nj bi translated">它没有运行时验证</li><li id="12a9" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">部队断言与<code class="fe mx my mz na b">Payload as string</code></li><li id="f057" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">业务逻辑与数据表示混合<code class="fe mx my mz na b">JSON.stringify</code>和<code class="fe mx my mz na b">JSON.parse</code></li></ul><h1 id="3918" class="md km iq bd kn me mf mg kq mh mi mj kt mk ml mm kw mn mo mp kz mq mr ms lc mt bi translated">DTO模式</h1><p id="c6db" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">dto或数据传输对象已经存在了一段时间，但在现代无服务器世界中，它们尤其重要。它们对于跨资源传递数据很有用，例如，lambda调用其他lambda，或者将消息分派到SQS队列以便稍后处理。</p><blockquote class="lv lw lx"><p id="7dcc" class="jn jo ly jp b jq jr js jt ju jv jw jx lz jz ka kb ma kd ke kf mb kh ki kj kk ij bi translated">数据传输对象的主要目的是通过从发送方和接收方提取打包和解包数据的逻辑，提供可靠传输数据的机制。</p></blockquote><p id="3678" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在下面的例子中，我们将使用两个lambdas。这个想法是，第一个lambda发送一个带有用户信息的<code class="fe mx my mz na b">UserDto</code>，第二个lambda将响应一个包含消息的<code class="fe mx my mz na b">GreetingDto</code>。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi np"><img src="../Images/ffd015931fc31ad8c97dbe6a82d0ebdc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*Cz32uNL4Ma2Lsko7f42atA.png"/></div></figure><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="1aef" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">发送DTO: </strong></p><p id="8402" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">仔细看看<code class="fe mx my mz na b">userDto</code>。它是<code class="fe mx my mz na b">UserDto</code>的一个实例，包含用户的所有属性。最重要的是，它有一个<code class="fe mx my mz na b">serialize</code>方法，抽象出传输数据的逻辑。</p><p id="97d3" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><strong class="jp ir">接收DTO: </strong></p><p id="ac2b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">一旦Greeter lambda被调用，它就会接收一个对象，但是我们并不知道它是什么类型。有可能是用不正确的输入调用的。因此，我们需要在运行时验证它是否真的与<code class="fe mx my mz na b">UserDto</code>兼容。幸运的是，我们的类有一个静态方法<code class="fe mx my mz na b">from</code>来验证它并返回一个实例。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="6c92" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在欢迎端，我们获取事件，通过一行代码，我们验证并获取用户实例。同样为了额外的安全，它将返回类型声明为<code class="fe mx my mz na b">Promise&lt;GreetingDto&gt;</code></p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><p id="f31c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这里，AWS处理返回的<code class="fe mx my mz na b">GreetingDto</code>实例，并返回一个带有属性的对象。请注意，没有必要用字符串表示返回。</p><figure class="lk ll lm ln gt lo"><div class="bz fp l di"><div class="mv mw l"/></div></figure><h2 id="1b83" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">dto优势:</strong></h2><ul class=""><li id="56ce" class="nb nc iq jp b jq le ju lf jy nd kc ne kg nf kk ng nh ni nj bi translated">在运行时验证输入并提供类型检查</li><li id="4c05" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">抽象数据传输逻辑并使其可重用</li><li id="0e15" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">简化与其他系统的通信</li></ul><h2 id="6993" class="kl km iq bd kn ko kp dn kq kr ks dp kt jy ku kv kw kc kx ky kz kg la lb lc ld bi translated"><strong class="ak">dto的缺点:</strong></h2><ul class=""><li id="f27d" class="nb nc iq jp b jq le ju lf jy nd kc ne kg nf kk ng nh ni nj bi translated">引入复杂性</li><li id="7334" class="nb nc iq jp b jq nk ju nl jy nm kc nn kg no kk ng nh ni nj bi translated">对于复杂的对象模式，像<code class="fe mx my mz na b">joi</code>或<code class="fe mx my mz na b">yup</code>这样的验证包可能是有用的</li></ul><h1 id="2202" class="md km iq bd kn me mf mg kq mh mi mj kt mk ml mm kw mn mo mp kz mq mr ms lc mt bi translated">跨团队和项目同步</h1><p id="1bc2" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">关于TypeScript，我最喜欢的特性之一是能够自己导出类型声明。当有多个团队在一个组织中工作时，这种与NPM包的结合尤其强大。</p><p id="63af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">通过拥有一个集中的存储库，每个团队都可以将这些包包含在他们的项目中，以可预测的方式发送和接收数据。如果使用请求/响应模式，您将只需要导出TypeScript接口，但是如果您想更进一步，您还可以提供d to的实现以及用于TS和JS的类型声明。</p><figure class="lk ll lm ln gt lo gh gi paragraph-image"><div class="gh gi nq"><img src="../Images/9da81b2a0a1cddfdad467fa984502edf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1102/format:webp/1*bLO3YMywfje31_jhXfDY5g.png"/></div></figure><h1 id="31bb" class="md km iq bd kn me mf mg kq mh mi mj kt mk ml mm kw mn mo mp kz mq mr ms lc mt bi translated">超越兰姆达斯</h1><p id="eb19" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">上述模式对其他无服务器资源也很有用，比如SQS、Step Functions、DynamoDB和新添加的CDK。所有这些资源都受益于一个可以可靠传递的可预测对象结构。例如，SQS可以用一个消息数组来调用Lambdas，并且每个消息都可以进行类型检查。</p><h1 id="4043" class="md km iq bd kn me mf mg kq mh mi mj kt mk ml mm kw mn mo mp kz mq mr ms lc mt bi translated">结论</h1><p id="6be9" class="pw-post-body-paragraph jn jo iq jp b jq le js jt ju lf jw jx jy lg ka kb kc lh ke kf kg li ki kj kk ij bi translated">随着无服务器功能和其他资源越来越流行，很难跟踪变化并确保一切正常工作。TypeScript为类型检查提供了强大的功能，可以通过多种方式进行分发和应用。这是一个强大的工具，可能是无服务器应用程序成功的关键。</p></div></div>    
</body>
</html>