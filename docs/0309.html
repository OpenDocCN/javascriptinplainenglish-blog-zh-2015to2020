<html>
<head>
<title>Algorithms 101: Climbing stairs in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">算法101:用JavaScript爬楼梯</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/algorithms-101-climbing-stairs-in-javascript-c8dec14cb2f6?source=collection_archive---------2-----------------------#2019-09-16">https://javascript.plainenglish.io/algorithms-101-climbing-stairs-in-javascript-c8dec14cb2f6?source=collection_archive---------2-----------------------#2019-09-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="c7d6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">Noob v. LeetCode，第4集，重新学习斐波那契数列</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi kl"><img src="../Images/72cbd469d27289201eb084a32fbcd7a3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*fm_J9vyOD8oeas_O.jpg"/></div></div></figure><p id="38dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每天早上11点，我都会和我熨斗组的一些人聚在一起研究算法。<a class="ae kx" href="https://leetcode.com/problems/climbing-stairs/" rel="noopener ugc nofollow" target="_blank">今天的字谜来自LeetCode: </a></p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi ky"><img src="../Images/c44a99b8324cce8a97eceaf09a6ad66e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AOkuzslHX5eAl7AndhPd1A.png"/></div></div></figure><p id="e26a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你必须从某个地方开始。我的第一个方法是这样的:根据例子，每两步有两种可能的组合，每三步有三种可能的组合。</p><p id="3f0a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但这并不完全正确，因为一个组合总是一步一个脚印。所以也许模式应该是:</p><pre class="km kn ko kp gt kz la lb lc aw ld bi"><span id="cb32" class="le lf iq la b gy lg lh l li lj">//if divisible by 2, maxCombos = pairs + 1?<br/>//if divisible by 3, maxCombos = triples x 2 + 1?</span></pre><p id="be70" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们花了一段时间尝试各种不同的算法。它们不起作用。</p><p id="77ff" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后我们做了第一步:写出楼梯总数为1、2、3、4、5时的输入= &gt;输出模式。这相对容易做到，因为当我们的代码通过了n = 2的测试时，它将在n=3时失败；当我们将它固定为n = 3时，它会在n = 4或n=5时失败，每次，LeetCode都会给出预期的输出。</p><p id="3177" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">模式:</p><pre class="km kn ko kp gt kz la lb lc aw ld bi"><span id="7ea3" class="le lf iq la b gy lg lh l li lj">number of stairs : max combos<br/>1:1<br/>2:2<br/>3:3<br/>4:5<br/>5:8</span></pre><p id="ebb1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们试图从如何从1到2，如何从3到2等方面来理解这种模式，换句话说，只看前一个元素就能看到下一个元素。</p><p id="73a6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">但是，正如我们在逆向工程一些其他解决方案后被提醒的那样，这是经典的<a class="ae kx" href="https://en.wikipedia.org/wiki/Fibonacci_number" rel="noopener ugc nofollow" target="_blank">斐波那契数列</a>，从0和1开始，将最后两个元素相加得到下一个元素，然后继续下去。</p><p id="ec54" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">因为0 + 1 = 1，所以模式中的下一个数字是1；因为1 + 1 = 2，所以下一个数是2，以此类推:</p><p id="de16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><code class="fe lk ll lm la b">0,1,1,2,3,5,8,13 ...</code></p><p id="7f88" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">斐波那契模式存在于自然界的许多螺旋元素中，从鹦鹉螺壳的大小到向日葵从中心到外部种子数量的增加。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi ln"><img src="../Images/69b89a04caa4948a257709e3a58c78d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/0*1KDjRkVRCbswTgkM.jpg"/></div></figure><p id="fb3c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们发现我们正在处理斐波纳契数列，这使得我们更容易理解我们发现的一个解决方案:</p><pre class="km kn ko kp gt kz la lb lc aw ld bi"><span id="c872" class="le lf iq la b gy lg lh l li lj">var climbStairs = function(n) {<br/>   const ary =[1,1];<br/>   if(n&gt;1){<br/>        for(let i = 2; i &lt;= n ; i++){<br/>           ary[i] = ary[i-1] + ary[i-2];<br/>       }<br/>   };<br/>   return ary.pop()<br/>}</span></pre><p id="77c6" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在第2行，我们设置一个数组等于斐波纳契数列的前两个数字(在0之后)。</p><p id="8921" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们从说明中知道，爬楼梯的次数永远是正整数(大于0)。如果<code class="fe lk ll lm la b">n</code>是1，我们不进入循环，我们使用<code class="fe lk ll lm la b">ary.pop()</code>返回数组的最后一个元素，也就是1。太好了。现在两个怎么样，等等？</p><p id="b292" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的<em class="lo"> for </em>循环中，我们的目标是向数组中添加一个新元素，它等于前面两个元素的总和。</p><p id="f899" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是算法的工作原理</p><pre class="km kn ko kp gt kz la lb lc aw ld bi"><span id="39f6" class="le lf iq la b gy lg lh l li lj">for(let i = 2; i &lt;= n ; i++){<br/>           ary[i] = ary[i-1] + ary[i-2];<br/>           <br/>           //when i = 2<br/>           // ary[2] = ary[2-1] + ary[2-2]<br/>           //=&gt; ary[2] = ary[1] + ary[0]<br/>           //=&gt; ie new element = sum of previous two elements<br/>           // ary = [1,1,2]</span><span id="0cd9" class="le lf iq la b gy lp lh l li lj">           //when i - 3 <br/>           //ary[3] = ary[3-1] + ary[3-2]<br/>           //=&gt; ary[3] = ary[2] + ary[1]<br/>           // ary = [1,1,2,3]</span><span id="d9c0" class="le lf iq la b gy lp lh l li lj">           //etc</span><span id="d025" class="le lf iq la b gy lp lh l li lj">       }</span></pre><p id="5f00" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当<code class="fe lk ll lm la b"><em class="lo">i = n</em></code>时，循环停止。此时，数组中的最后一个元素是组合的最大数量，所以我们用ary.pop()返回这个数字。</p><p id="1ed4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们组中的一个人注意到，当我们返回ary[ary.length — 1]而不是ary.pop()时，数组运行得稍微快一些。</p><p id="7caf" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们的优化解决方案:</p><pre class="km kn ko kp gt kz la lb lc aw ld bi"><span id="0795" class="le lf iq la b gy lg lh l li lj">var climbStairs = function(n) {<br/> const ary =[1,1];<br/> if(n&gt;1){<br/> for(let i = 2; i &lt;= n ; i++){<br/> ary[i] = ary[i-1] + ary[i-2];<br/> }<br/> };<br/> return ary[ary.length — 1]<br/>}</span></pre><p id="113c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">运行良好！</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div role="button" tabindex="0" class="kr ks di kt bf ku"><div class="gh gi lq"><img src="../Images/d73577ea3137587a5f0218d780827328.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3woh4QylnAfDSy3B1sEbKw.png"/></div></div></figure><p id="024b" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><em class="lo">接下来:</em> <a class="ae kx" href="https://medium.com/javascript-in-plain-english/algorithms-101-goat-latin-in-javascript-d388cc29dc73" rel="noopener"> <em class="lo">算法101 #5、JavaScript中的山羊拉丁文</em> </a></p><p id="a839" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated"><a class="ae kx" href="https://medium.com/@joanrigdon/algorithms-101-next-greatest-element-493e224f82b5" rel="noopener"> <em class="lo">以防你错过:算法101 # 3:Javascript中下一个最伟大的元素</em> </a></p><p id="b2d0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">版权所有琼·印第安纳·琳斯2019</p></div></div>    
</body>
</html>