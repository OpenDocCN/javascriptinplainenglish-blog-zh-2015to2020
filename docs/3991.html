<html>
<head>
<title>How to emulate a “Constructor” in React Functional Component with Custom Hooks</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在带有自定义钩子的反应功能组件中模拟“构造函数”</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/use-constructor-in-react-functional-component-with-custom-hooks-e0770e92b840?source=collection_archive---------2-----------------------#2020-11-09">https://javascript.plainenglish.io/use-constructor-in-react-functional-component-with-custom-hooks-e0770e92b840?source=collection_archive---------2-----------------------#2020-11-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="248d" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">“反应”中的功能组件缺少构造函数的概念</p><h2 id="e5d6" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">但是什么是构造函数呢？</h2><p id="919b" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated"><em class="lg">在</em> <a class="ae lh" href="https://en.wikipedia.org/wiki/Class-based_programming" rel="noopener ugc nofollow" target="_blank"> <em class="lg">类基础上的</em> </a> <em class="lg"> </em> <a class="ae lh" href="https://en.wikipedia.org/wiki/Object-oriented_programming" rel="noopener ugc nofollow" target="_blank"> <em class="lg">面向对象编程的</em> </a> <em class="lg">中，有一个</em> <strong class="jm io"> <em class="lg">构造函数</em> </strong> <em class="lg">(简称:</em> <strong class="jm io"> <em class="lg">函数</em> </strong> <em class="lg">)是一种特殊类型的</em> <a class="ae lh" href="https://en.wikipedia.org/wiki/Subroutine" rel="noopener ugc nofollow" target="_blank"> <em class="lg">子程序</em><em class="lg">称为</em> </a><a class="ae lh" href="https://en.wikipedia.org/wiki/Object_creation" rel="noopener ugc nofollow" target="_blank">它为使用准备新的对象，经常接受构造者用来设置所需的 </a><a class="ae lh" href="https://en.wikipedia.org/wiki/Member_variable" rel="noopener ugc nofollow" target="_blank"> <em class="lg">成员变量</em> </a> <em class="lg">的<em class="lg">参数</em>  <em class="lg">。~ </em> <a class="ae lh" href="https://en.wikipedia.org/wiki/Constructor_(object-oriented_programming)" rel="noopener ugc nofollow" target="_blank"> <em class="lg">维基链接</em> </a></em></p><p id="5c11" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">因此，简单地说，使用构造函数，我们初始化了组件的状态，有人可能会说<a class="ae lh" href="https://reactjs.org/docs/hooks-faq.html#how-do-lifecycle-methods-correspond-to-hooks" rel="noopener ugc nofollow" target="_blank">“函数组件不需要构造函数。您可以在</a><a class="ae lh" href="https://reactjs.org/docs/hooks-reference.html#usestate" rel="noopener ugc nofollow" target="_blank"> useState </a>调用中初始化状态。</p><p id="1e58" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">这里的问题是函数组件是…函数。只要你打电话给他们，他们就会跑。就这样。这意味着我们没有生命周期，这也意味着我们没有地方可以用在组件第一次呈现之前只运行一次的代码来初始化我们的组件。</p><h2 id="cbaa" class="ki kj in bd kk kl km dn kn ko kp dp kq jv kr ks kt jz ku kv kw kd kx ky kz la bi translated">这个问题的真实例子。</h2><p id="e85b" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">在下面的例子中，我们有一个带有内部形式的模态。<strong class="jm io"> <em class="lg">性能字段有一个确认</em> </strong>，即与规程同步的<strong class="jm io"> <em class="lg">。由于这个表单是用于编辑和创建的，我们需要知道用什么验证来初始化这个表单。为了实现这一点，我们通过props将验证从父组件传递到组件，并用钩子处理验证</em></strong></p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi li"><img src="../Images/4977bc833e6ed5cf5d75cc72bfad2af4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fZoRPEAxKUQpl5H5HYVW4w.png"/></div></div></figure><p id="fffb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们还希望仅在组件初始化时设置字段值<strong class="jm io">。</strong></p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi lu"><img src="../Images/52c6baf6bdb8f392426f232cd4991ba1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q2O0hyWwzCMrdDOt0MNJ9w.png"/></div></div></figure><p id="e02c" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们的问题是，每次我们调用<strong class="jm io"> <em class="lg"> onFocusPerformance()，</em> </strong>时，由于<strong class="jm io"><em class="lg">setPerformanceValidation()，</em> </strong> <em class="lg">导致重新运行红框内的代码块并再次重置表单中的值，所以状态会发生变化。</em></p><h1 id="4f63" class="lv kj in bd kk lw lx ly kn lz ma mb kq mc md me kt mf mg mh kw mi mj mk kz ml bi translated">解决方案</h1><p id="f8b3" class="pw-post-body-paragraph jk jl in jm b jn lb jp jq jr lc jt ju jv ld jx jy jz le kb kc kd lf kf kg kh ig bi translated">我们可以以编程方式创建一个函数，该函数将在组件每次运行时被调用，但将基于一个标志执行其内部代码。<br/> <em class="lg">这实际上是如何实现单例的。我们想要些东西。如果存在，带来现有的，如果没有创建一个新的</em>。大概是这样的:</p><pre class="lj lk ll lm gt mm mn mo mp aw mq bi"><span id="8b7a" class="ki kj in mn b gy mr ms l mt mu">const OurFunctionalComponent = () =&gt; {<br/> const [constructorHasRun, setConstructorHasRun] = useState(false);</span><span id="6dfa" class="ki kj in mn b gy mv ms l mt mu"> <strong class="mn io"><em class="lg">const constructor = () =&gt; {<br/>   if (constructorHasRun) return;<br/>   // Some code...<br/>   setConstructorHasRun(true);<br/> };</em></strong></span><span id="3971" class="ki kj in mn b gy mv ms l mt mu"> constructor(); // called on each re-render<br/> <!-- -->...<br/>}<br/></span></pre><p id="87e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我们现在还可以，但是实现并不是越干净越好。我们需要在我们需要的每个组件上编码这个逻辑。我们可以通过使用自定义钩子来避免它。</p><p id="4771" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">通过将我们的逻辑移入一个自定义钩子，我们可以拥有一个更干净的“构造器”。</p><figure class="lj lk ll lm gt ln gh gi paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><div class="gh gi mw"><img src="../Images/15842900065c71989eac57826ba52b3d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mQoWlMp9utpKFSPaGv0rCg.png"/></div></div></figure><p id="12bb" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lg">注意:要获得构造函数的行为——请记住——我们需要在函数</em>  <em class="lg"> </em> <strong class="jm io"> <em class="lg">之上调用它</em> <strong class="jm io"> <em class="lg">,以便在所有函数</em> </strong> <em class="lg">之前运行它。</em></strong></p><p id="cec1" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更新1:有一些评论指出使用<strong class="jm io"> useEffects </strong>而不是这种方法。</p><p id="1115" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> useEffect </strong>钩子不满足<em class="lg">构造函数的所有</em>条件。</p><p id="d0cd" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lg">use effect运行一次，且在该组件的整个生命周期内只运行一次。我们对此没意见。我们得到了我们要求的一部分。</em></p><p id="bb71" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><em class="lg">问题是</em>它在组件渲染后运行。当然，这也是我们所期待的，因为这在Hooks文档中有明确的说明:“<a class="ae lh" href="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener ugc nofollow" target="_blank">默认情况下，效果会在每次渲染完成后运行。</a></p><p id="2af6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">更新2:正如本帖<em class="lg">中的一个评论所提到的，“你正在进入一个可能导致内存泄漏的领域，或者在React的未来版本中代码变得脆弱。”。即使这篇文章的目的不是提出useEffect()(😅显然)，我</em>做了一些实验，我设法改变了实现。现在我用useEffect()代替了我的自定义useConstructor钩子<strong class="jm io">。</strong></p><div class="lj lk ll lm gt ab cb"><figure class="mx ln my mz na nb nc paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><img src="../Images/656bfc85996992b4431df85ed92f4321.png" data-original-src="https://miro.medium.com/v2/resize:fit:1084/format:webp/1*iN_UnIMaBSnmWu9pLeiIfw.png"/></div></figure><figure class="mx ln nd mz na nb nc paragraph-image"><div role="button" tabindex="0" class="lo lp di lq bf lr"><img src="../Images/4e8391c577a9375ef966d867e12b9fff.png" data-original-src="https://miro.medium.com/v2/resize:fit:918/format:webp/1*NASsAawVpnWtE_85AP64AQ.png"/></div></figure></div><p id="211a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">我最初的场景很复杂，我不得不重构更多的代码，以便在我的组件上实现预期的行为。所以，我没有改动这篇文章的其余部分，我添加了上面更改过的代码，以便于每个人进行比较。</p></div></div>    
</body>
</html>