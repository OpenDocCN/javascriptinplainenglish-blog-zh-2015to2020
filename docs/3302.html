<html>
<head>
<title>How to Configure Single Page Routing with Svelte and Express.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用Svelte和Express.js配置单页路由</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-configure-page-routing-with-svelte-and-express-js-ab5a4e0ad12f?source=collection_archive---------3-----------------------#2020-09-17">https://javascript.plainenglish.io/how-to-configure-page-routing-with-svelte-and-express-js-ab5a4e0ad12f?source=collection_archive---------3-----------------------#2020-09-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0466" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何在使用客户端路由和热重新加载时避免“找不到页面”错误</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/d96d7489bfce88c5fcad9a6cb60151b1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*R9fvbJw4qlQ8AYmt"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@fairfilter?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Oliver Roos</a> on <a class="ae kv" href="https://unsplash.com/s/photos/fork-in-the-road?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="592e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">本教程适用于任何创建单页面应用程序并想知道如何在服务器端正确配置路由的人。它将使用Svelte作为框架，但这里的技术将适用于任何使用客户端路由的应用程序。</p><p id="7dd0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">问题</strong></p><p id="0b78" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像<code class="fe ls lt lu lv b">svelte-routing</code>这样的客户端路由解决方案工作得很好，但是如果你在使用它们时试图刷新页面，它们就会崩溃，这意味着不可能使用热重载。这是因为所有的路由逻辑都是在客户机上执行的，当您最初加载一个页面时，比如说<code class="fe ls lt lu lv b">localhost:5000/home</code>，客户机代码还没有加载。这意味着你的浏览器将试图在<code class="fe ls lt lu lv b">localhost:5000</code>找到文件<code class="fe ls lt lu lv b">home.html</code>，但它不会在那里，因为它是一个单页应用。它只有<code class="fe ls lt lu lv b">index.html</code>。</p><p id="b170" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lw"><img src="../Images/dfbb18100473d0f742e182bff5da37e8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*guE6vRrFW8uKmNqO.png"/></div></div></figure><p id="273f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码创建了一个简单的应用程序，并使用<code class="fe ls lt lu lv b">svelte-routing</code>作为路由解决方案。然后，它为<code class="fe ls lt lu lv b">Home</code>组件创建一个<code class="fe ls lt lu lv b">Route</code>和一个导航链接。<code class="fe ls lt lu lv b">Home</code>组件只返回一个<code class="fe ls lt lu lv b">p</code>标签，上面写着‘你好，这是主页’。</p><p id="8b1d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我加载这个应用程序时，我看到了根页面。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi lx"><img src="../Images/27502e395d5ad4fe0895e9298a02c4b5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1212/format:webp/0*XWE5CLAN8U6K1n2r.png"/></div></figure><p id="85f4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我点击<code class="fe ls lt lu lv b">Home</code>时，我被转到主页。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ly"><img src="../Images/f3cc141055bf7332fd50fadeb0f75c0c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1020/format:webp/0*Ne8lpmqpQYSjmzbr.png"/></div></figure><p id="db73" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我试图直接导航到<code class="fe ls lt lu lv b">localhost:5000/home</code>或刷新页面时，问题出现了。如果我这样做，我会看到一个空白页，或一个找不到的错误。</p><p id="6c98" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">解决方案</strong></p><p id="ff1c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了解决这个问题，我们需要一种方法来拦截对<code class="fe ls lt lu lv b">localhost:5000</code>的HTTP调用，然后将它们全部重定向回<code class="fe ls lt lu lv b">index.html</code>。当我们这样做时，服务器将返回根页面，它将加载我们所有的代码，然后路由将开始运行并显示主页。</p><p id="d214" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过创建一个express服务器来服务我们的应用程序来做到这一点，让我们开始吧。</p><p id="af81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">首先，通过运行<code class="fe ls lt lu lv b">npm i express</code>安装express，然后在项目的根目录下创建一个文件<code class="fe ls lt lu lv b">server.js</code>。添加以下样板文件来创建服务器。</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="4851" class="md me iq lv b gy mf mg l mh mi">var express = require('express')<br/>var app = express()</span><span id="8f6f" class="md me iq lv b gy mj mg l mh mi">app.listen(3000, () =&gt; {<br/>  console.log("App listening on port 3000")<br/>})</span></pre><p id="b0bb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，我们需要做两件事。我们需要配置一个静态目录，它将告诉express在哪里可以找到我们的html &amp; js文件。然后我们需要拦截所有的http呼叫并把它们路由回index.html。</p><p id="0d04" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">Svelte的静态目录将是<code class="fe ls lt lu lv b">public</code>目录，因为所有构建的文件都放在那里。这是标准的，所以对其他框架来说可能也是一样的，但是显然要确保检查。</p><p id="38a3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">要在express中定义静态文件夹，我们需要:</p><p id="1775" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe ls lt lu lv b">app.use(express.static('public'))</code></p><p id="68c4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以把这个加到<code class="fe ls lt lu lv b">server.js</code></p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="4747" class="md me iq lv b gy mf mg l mh mi">var express = require('express')<br/>var app = express()</span><span id="b2e9" class="md me iq lv b gy mj mg l mh mi">app.use(express.static('public'))</span><span id="3441" class="md me iq lv b gy mj mg l mh mi">app.listen(3000, () =&gt; {<br/>  console.log("App listening on port 3000")<br/>})</span></pre><p id="b855" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在，如果您使用<code class="fe ls lt lu lv b">node server.js</code>运行您的服务器，您应该会看到您的应用程序被加载到浏览器中。然而，我们仍然没有解决这个问题。</p><p id="3e82" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们需要重写所有对<code class="fe ls lt lu lv b">index.html</code>的http调用。这很简单，如下所示。</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="eda9" class="md me iq lv b gy mf mg l mh mi">app.get('*', (req, res) =&gt; {<br/>  res.sendFile(__dirname + "/public/index.html")<br/>})</span></pre><p id="2386" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">星号字符拦截所有调用，然后我们告诉服务器从公共文件夹返回<code class="fe ls lt lu lv b">index.html</code>文件。我们使用<code class="fe ls lt lu lv b">__dirname</code>来获得完全合格的路径。</p><p id="f19d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您现在运行您的服务器，您应该能够直接导航到<code class="fe ls lt lu lv b">localhost:5000/home</code>。不过，还有一个问题。</p><p id="4013" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">热重装</strong></p><p id="dabb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样做的一个好处是它可以热重装。然而，现在我们没有使用Svelte的<code class="fe ls lt lu lv b">npm run dev</code>来运行我们的应用程序，我们没有从中受益。目前，我们需要停止服务器，编译应用程序，并再次重启它，使热重装工作。这是一个痛苦的手动操作，但我们可以相对容易地将其自动化。</p><p id="2b15" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">有一个很好的小npm包叫做<code class="fe ls lt lu lv b">concurrently</code>。我们过程的最后一步是用<code class="fe ls lt lu lv b">npm i concurrently</code>安装它，然后在我们的<code class="fe ls lt lu lv b">package.json</code>中创建一个脚本来运行我们的服务器和我们的热重装。下面是它看起来很苗条的样子(对于其他框架几乎是一样的)。</p><pre class="kg kh ki kj gt lz lv ma mb aw mc bi"><span id="e51e" class="md me iq lv b gy mf mg l mh mi">"scripts": {<br/>   "build": "rollup -c",<br/>   "dev": "rollup -c -w",<br/>   "start": "sirv public",<br/>   "serve": "concurrently \"node server.js\" \"npm run dev\" "<br/> },</span></pre><p id="ba4c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们的<code class="fe ls lt lu lv b">serve</code>命令将运行服务器和<code class="fe ls lt lu lv b">dev</code>命令。因为dev命令会在每次保存时重新创建<code class="fe ls lt lu lv b">public</code>文件夹，并且我们的服务器会在每次请求时读取该文件夹，所以我们总能获得最新的应用程序代码。</p></div><div class="ab cl mk ml hu mm" role="separator"><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp mq"/><span class="mn bw bk mo mp"/></div><div class="ij ik il im in"><p id="8e52" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">就是这样。简单的过程，但如果你不知道你在找什么，那就很烦人了。感谢阅读。</p></div></div>    
</body>
</html>