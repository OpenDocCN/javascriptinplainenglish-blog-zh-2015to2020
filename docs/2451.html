<html>
<head>
<title>Converting Callback-based Functions to Promises in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将基于回调的函数转换为JavaScript中的承诺</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/converting-callback-based-functions-to-promises-in-javascript-ab22f55a24e?source=collection_archive---------2-----------------------#2020-06-25">https://javascript.plainenglish.io/converting-callback-based-functions-to-promises-in-javascript-ab22f55a24e?source=collection_archive---------2-----------------------#2020-06-25</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/7b51530f50d3dbb89052c87b17fe82d2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LuJJJjKrbCTeYMJhxHUNRQ.png"/></div></div></figure><div class=""/><div class=""><h2 id="22ab" class="pw-subtitle-paragraph jy ja jb bd b jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp dk translated">使用基于回调的库时避免回调地狱</h2></div><p id="b277" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">使用Promises，您可以编写更整洁、更可读的代码，但仍然有许多包是用回调函数编写的，因此您可能仍然会遇到回调地狱。如果你可以得到同样的功能，但不是接受回调，它会返回一个承诺呢？</p><p id="f8b2" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">下面是一个简单的HTTP服务器，它服务于一个静态网站。此web服务器的工作原理如下</p><ul class=""><li id="63b9" class="lm ln jb ks b kt ku kw kx kz lo ld lp lh lq ll lr ls lt lu bi translated">接收HTTP请求</li><li id="8880" class="lm ln jb ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">检查网站目录中的请求路径(<em class="ma">例如，如果请求是test.com/about/main.html，它会在网站目录</em>中查找about/main.html)</li><li id="dd5d" class="lm ln jb ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">如果路径是目录，则返回该目录中的<code class="fe mb mc md me b">index.html</code>文件</li><li id="5a97" class="lm ln jb ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">如果该路径是文件的路径，则返回该文件</li><li id="7e5b" class="lm ln jb ks b kt lv kw lw kz lx ld ly lh lz ll lr ls lt lu bi translated">如果路径不存在，它将返回一个<code class="fe mb mc md me b">404.html</code>文件。</li></ul><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="0699" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">两个功能<code class="fe mb mc md me b">fs.lstat</code> &amp; <code class="fe mb mc md me b">fs.readFile</code>均使用回调返回响应。这是一个非常基本的示例，与实际项目毫无可比性，但它已经下降了两个回调级别。在一个产品项目中，回调或我们所说的回调地狱会很容易达到7-8层。</p><p id="59bb" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">为了避免这种情况<code class="fe mb mc md me b">Promise</code>被引入了JavaScript。但由于这些函数是用回调实现的，很像今天可用的大多数包，所以我们仍然面临这个问题。</p><p id="863c" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated"><em class="ma">由于我们不能真正更改这些函数的实现，我们可以编写一个包装函数，它将使我们能够将任何基于回调的函数更改为基于promise的函数。</em></p><h1 id="dcdd" class="ml mm jb bd mn mo mp mq mr ms mt mu mv kh mw ki mx kk my kl mz kn na ko nb nc bi translated">这个功能将如何运作？</h1><p id="20f9" class="pw-post-body-paragraph kq kr jb ks b kt nd kc kv kw ne kf ky kz nf lb lc ld ng lf lg lh nh lj lk ll ij bi translated">姑且称之为<code class="fe mb mc md me b">promisify</code>。以下是<code class="fe mb mc md me b">promisify</code>必须填写的要求</p><p id="5902" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">应该接受基于回调的函数并返回一个新函数，而新函数应该返回一个Promise。</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="dcf9" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">当原始函数调用回调而没有错误时，承诺应该解决，而当出现错误时，承诺应该拒绝。</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="a066" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在我们都有了所有必须的部分。现在我们只需要用这个回调来调用原始函数(<code class="fe mb mc md me b">func</code>)。</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="5395" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">这将采用任何接受回调的函数，并将返回一个返回承诺的新函数。</p><p id="1c29" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">现在我们可以通过<code class="fe mb mc md me b">promisifying</code><code class="fe mb mc md me b">fs.lstat</code>&amp;<code class="fe mb mc md me b">fs.readFile</code>函数来重写我们的HTTP服务器了。</p><figure class="mf mg mh mi gt is"><div class="bz fp l di"><div class="mj mk l"/></div></figure><p id="57fa" class="pw-post-body-paragraph kq kr jb ks b kt ku kc kv kw kx kf ky kz la lb lc ld le lf lg lh li lj lk ll ij bi translated">它不仅避免了回调地狱，而且还允许您使用高级<code class="fe mb mc md me b">Promise</code>特性并标准化整个代码库，而与底层库和包的实现无关。Node.js在实用程序中提供了<code class="fe mb mc md me b">promisify</code>，但对于客户端的JavaScript却不是这样。</p></div></div>    
</body>
</html>