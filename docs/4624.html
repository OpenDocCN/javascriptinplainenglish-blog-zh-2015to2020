<html>
<head>
<title>How to Write a Custom React Hook</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何编写自定义的React挂钩</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-write-a-custom-react-hook-6a8315f351f6?source=collection_archive---------2-----------------------#2020-12-26">https://javascript.plainenglish.io/how-to-write-a-custom-react-hook-6a8315f351f6?source=collection_archive---------2-----------------------#2020-12-26</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="5920" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">关于如何将组件逻辑提取到可重用钩子中的一课。</h2></div><p id="9177" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">React钩子，在<a class="ae ky" href="https://reactjs.org/blog/2019/02/06/react-v16.8.0.html" rel="noopener ugc nofollow" target="_blank"> React v16.8 </a>中发布，改变了开发者编写代码的方式。默认情况下，React让我们可以访问一组<a class="ae ky" href="https://reactjs.org/docs/hooks-reference.html" rel="noopener ugc nofollow" target="_blank">强大的基础钩子</a>，比如<code class="fe kz la lb lc b">useState</code>、<code class="fe kz la lb lc b">useEffect</code>、<code class="fe kz la lb lc b">useReducer</code>等等，但是我们也可以构建自己的定制钩子来抽象复杂的状态逻辑。</p><figure class="le lf lg lh gt li gh gi paragraph-image"><div role="button" tabindex="0" class="lj lk di ll bf lm"><div class="gh gi ld"><img src="../Images/08d533300b9b5a24bce32e5bbb56a1a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*0eNGjv7MF0SBayRp"/></div></div><figcaption class="lp lq gj gh gi lr ls bd b be z dk">Photo by <a class="ae ky" href="https://unsplash.com/@v2osk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">v2osk</a> on <a class="ae ky" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="2324" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">等等，什么是定制挂钩？</h1><p id="4e35" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">在编写React应用程序时，您肯定会发现自己在多个组件中使用相同的重复或冗余的状态逻辑。通过定制钩子，我们可以将这种逻辑提取到一个函数中，使我们的代码更干净，更具可重用性。</p><p id="1517" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">自定义钩子只是包含其他钩子的函数，并且包含一个公共的有状态逻辑，可以在多个组件中重用。这些功能的前缀是<code class="fe kz la lb lc b">use</code>。自定义钩子意味着更少的击键和代码。</p><p id="3130" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在您编写自己的定制钩子之前，请记住开源社区已经发布了成千上万个钩子，所以很有可能有人已经编写了您需要的逻辑并在线发布了。</p><p id="0408" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">然而，这与我们无关，本文将关注如何编写定制钩子，而不是您是否应该编写它们。让我们直接进入第一个例子。</p><h1 id="bb99" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">使用位置</h1><p id="1c81" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">让我们来看看这个计数器组件，它在本地存储中存储其当前的<code class="fe kz la lb lc b">count</code>值:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="8fab" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里，我们使用<code class="fe kz la lb lc b">useState</code>和<code class="fe kz la lb lc b">useEffect</code>将本地状态同步到本地存储。现在，如果我们想在多个组件之间复制这个逻辑，该怎么办呢？我们将创建一个新的定制钩子来处理这个逻辑，而不是复制和粘贴代码。</p><p id="83d8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><code class="fe kz la lb lc b">useLocalStorageState</code>接受两个参数，键和默认值。在第一次初始化时，我们从本地存储器获取<code class="fe kz la lb lc b">count</code>(如果它存在)并将其设置为state，否则我们使用默认值。然后，我们使用<code class="fe kz la lb lc b">useEffect</code>钩子来保持我们的本地存储与本地状态同步，并将我们的<code class="fe kz la lb lc b">state</code>和<code class="fe kz la lb lc b">setState</code>函数作为数组返回。注意我们是如何使用<code class="fe kz la lb lc b">JSON.stringify</code>和<code class="fe kz la lb lc b">JSON.parse</code>字符串化和解析localStorage中的值的，这意味着我们也可以用这个钩子存储对象！</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="e1af" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们可以在任何我们想要的组件上重用这个<code class="fe kz la lb lc b">useLocalStorageState</code>钩子！</p><h1 id="d162" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">使用阵列</h1><p id="b393" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">注意，我们并不总是必须从自定义钩子返回一个数组。在这个例子中，我们将构建一个定制的<code class="fe kz la lb lc b">useArray</code>钩子，它允许我们更容易地管理数组状态。</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="f265" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这个钩子非常直观。我们返回一个对象，该对象带有一组数组状态的修饰符，这使得我们可以轻松地操作数组。我们接受一个初始数组作为钩子参数，然后提供<code class="fe kz la lb lc b">add</code>、<code class="fe kz la lb lc b">clear</code>、<code class="fe kz la lb lc b">removeById</code>和<code class="fe kz la lb lc b">removeIndex</code>作为通常的<code class="fe kz la lb lc b">value</code>和<code class="fe kz la lb lc b">setValue</code>操作之外的附加函数。</p><p id="dae9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看如何在组件中实现这个钩子:</p><figure class="le lf lg lh gt li"><div class="bz fp l di"><div class="mq mr l"/></div></figure><p id="6f1d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">看看我们是如何通过使用一个定制的钩子来大大减少我们在这个组件中需要的无关逻辑的数量的吧？相当不可思议。</p><h1 id="ceb7" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">我们必须以<code class="fe kz la lb lc b">use</code>开始我们的定制钩子吗？</h1><p id="ebf7" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">严格来说不是，但实际上是。根据<a class="ae ky" href="https://reactjs.org/docs/hooks-custom.html" rel="noopener ugc nofollow" target="_blank">反应文件</a>:<em class="ms">请执行。这个惯例非常重要。如果没有它，我们将无法自动检查是否违反了钩子</em>  <em class="ms">的</em> <a class="ae ky" href="https://reactjs.org/docs/hooks-rules.html" rel="noopener ugc nofollow" target="_blank"> <em class="ms">规则，因为我们无法判断某个函数内部是否包含对钩子的调用。”</em></a></p><h1 id="2265" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">自定义挂钩不共享状态</h1><p id="f5db" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">自定义钩子的每个实例都有自己的状态，所以不幸的是，默认情况下，您不能与自定义钩子共享状态。然而，如果你将一个定制钩子与一个全局状态库如<a class="ae ky" href="https://redux.js.org/" rel="noopener ugc nofollow" target="_blank"> Redux </a>或<a class="ae ky" href="http://recoiljs.org/" rel="noopener ugc nofollow" target="_blank">反冲</a>配对，你可以构建与全局状态交互的定制钩子！</p><h1 id="83af" class="lt lu in bd lv lw lx ly lz ma mb mc md jt me ju mf jw mg jx mh jz mi ka mj mk bi translated">结论</h1><p id="e418" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">React定制钩子对于编写更干净、更易维护、更简洁的代码来说非常强大。我们看了几个很好的定制钩子的例子，<code class="fe kz la lb lc b">usLocalStorageState</code>和<code class="fe kz la lb lc b">useArray</code>，以及我们如何使用它们来降低代码复杂度和增加可重用性。有一些你用过或做过的很棒的定制反应钩吗？我很想看看他们，欢迎在下面评论！</p><h2 id="778d" class="mt lu in bd lv mu mv dn lz mw mx dp md kl my mz mf kp na nb mh kt nc nd mj ne bi translated">保持联络</h2><p id="8f63" class="pw-post-body-paragraph kc kd in ke b kf ml jo kh ki mm jr kk kl mn kn ko kp mo kr ks kt mp kv kw kx ig bi translated">有很多内容，我很感谢你读我的。我是加州大学伯克利分校MET项目的本科生，也是一名年轻的企业家。我写软件开发、创业和失败(这是我非常擅长的)。你可以在这里<a class="ae ky" href="https://newsletter.cometcode.io/" rel="noopener ugc nofollow" target="_blank">注册我的时事通讯</a>或者在我的<a class="ae ky" href="https://www.caelinsutch.com/" rel="noopener ugc nofollow" target="_blank">网站</a>查看我正在做的事情。</p><p id="9d07" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">请随时联系我，在Linkedin<a class="ae ky" href="https://www.linkedin.com/in/caelinsutch" rel="noopener ugc nofollow" target="_blank">或Twitter</a><a class="ae ky" href="https://twitter.com/caelin_sutch" rel="noopener ugc nofollow" target="_blank">上联系我，我喜欢听到阅读我文章的人的声音:)</a></p></div></div>    
</body>
</html>