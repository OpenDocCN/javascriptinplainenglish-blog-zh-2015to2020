<html>
<head>
<title>More Rxjs Operators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">更多Rxjs运算符</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/more-rxjs-operators-d2e485bc91e4?source=collection_archive---------3-----------------------#2020-02-09">https://javascript.plainenglish.io/more-rxjs-operators-d2e485bc91e4?source=collection_archive---------3-----------------------#2020-02-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/56786dca29dd4167321a424e8b252ee4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*vtk-B__YCrBviGtn"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@hakonbrakon?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Håkon Helberg</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5e30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Rxjs是一个用于进行反应式编程的库。创建操作符对于从各种数据源生成供观察者订阅的数据非常有用。</p><p id="95f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些连接创建操作符，将来自多个可观察对象的数据组合成一个可观察对象。我们将看看<code class="fe lb lc ld le b">merge</code>、<code class="fe lb lc ld le b">race</code>和<code class="fe lb lc ld le b">zip</code>连接创建操作符，以及<code class="fe lb lc ld le b">buffer</code>和<code class="fe lb lc ld le b">bufferCount</code>转换操作符。</p><h1 id="0b58" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">连接创建运算符</h1><p id="c382" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">这些运算符将多个观察器发出的值组合成一个值。</p><h2 id="b390" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">合并</h2><p id="baee" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">merge</code>操作符获取多个可观察值，并同时从每个给定的输入可观察值中发出所有值。</p><p id="df2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它接受一个观察值数组或一个逗号分隔的观察值列表作为参数。</p><p id="3fe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="aebc" class="mi lg iq le b gy nc nd l ne nf">import { merge, of } from "rxjs";</span><span id="f46e" class="mi lg iq le b gy ng nd l ne nf">const observable1 = of(1, 2, 3);<br/>const observable2 = of(4, 5, 6);<br/>const combined = merge(observable1, observable2);<br/>combined.subscribe(x =&gt; console.log(x));</span></pre><p id="77a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一个例子是组合多个定时观察值，如下所示:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="a323" class="mi lg iq le b gy nc nd l ne nf">import { merge, interval } from "rxjs";</span><span id="8c1c" class="mi lg iq le b gy ng nd l ne nf">const observable1 = interval(1000);<br/>const observable2 = interval(2000);<br/>const combined = merge(observable1, observable2);<br/>combined.subscribe(x =&gt; console.log(x));</span></pre><p id="81eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们会看到第一个<code class="fe lb lc ld le b">observable1</code>会先发出一个值，然后是<code class="fe lb lc ld le b">observable2</code>。然后<code class="fe lb lc ld le b">observable1</code>会继续每秒发出数值，<code class="fe lb lc ld le b">observable2 </code>会每2秒发出数值。</p><h2 id="624c" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">人种</h2><p id="1cf9" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">race</code>操作符接受多个观察值，并返回从参数中发出一个项目的观察值。</p><p id="545b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它以逗号分隔的可观察列表作为参数。</p><p id="d121" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="785f" class="mi lg iq le b gy nc nd l ne nf">import { race, of } from "rxjs";</span><span id="09b8" class="mi lg iq le b gy ng nd l ne nf">const observable1 = of(1, 2, 3);<br/>const observable2 = of(4, 5, 6);<br/>const combined = race(observable1, observable2);<br/>combined.subscribe(x =&gt; console.log(x));</span></pre><p id="ae7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们有<code class="fe lb lc ld le b">observable1</code>，在<code class="fe lb lc ld le b">observable2</code>之前发出数据。我们应该得到输出:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="2080" class="mi lg iq le b gy nc nd l ne nf">1<br/>2<br/>3</span></pre><p id="4152" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为<code class="fe lb lc ld le b">observable</code>先发出数值。</p><h2 id="dd4a" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">活力</h2><p id="9838" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">zip</code>运算符组合多个可观察值并返回一个可观察值，其值是根据每个输入可观察值的顺序计算出来的。</p><p id="edf0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它以一系列可观察的事物作为参数。我们可以如下使用它:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="c8ec" class="mi lg iq le b gy nc nd l ne nf">import { zip, of } from "rxjs";</span><span id="5f78" class="mi lg iq le b gy ng nd l ne nf">const observable1 = of(1, 2, 3);<br/>const observable2 = of(4, 5, 6);<br/>const combined = zip(observable1, observable2);<br/>combined.subscribe(x =&gt; console.log(x));</span></pre><p id="6c9f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到以下结果:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="de34" class="mi lg iq le b gy nc nd l ne nf">[1, 4]<br/>[2, 5]<br/>[3, 6]</span></pre><p id="37d0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以将它们映射到对象，如下所示，以使一个可观察值更容易与另一个区分开来。</p><p id="77e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为此，我们可以编写以下代码:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="ab25" class="mi lg iq le b gy nc nd l ne nf">import { zip, of } from "rxjs";<br/>import { map } from "rxjs/operators";</span><span id="e3e3" class="mi lg iq le b gy ng nd l ne nf">const age$ = of(1, 2, 3);<br/>const name$ = of("John", "Mary", "Jane");<br/>const combined = zip(age$, name$);<br/>combined<br/>  .pipe(map(([age, name]) =&gt; ({ age, name })))<br/>  .subscribe(x =&gt; console.log(x));</span></pre><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nh"><img src="../Images/95a8a8c4db6fc2cfed96cb2ff71a2e72.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dOiUj-YS94Atz8A0"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@baptiststandaert?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Baptist Standaert</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="c264" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">变换运算符</h1><h2 id="d326" class="mi lg iq bd lh mj mk dn ll ml mm dp lp ko mn mo lt ks mp mq lx kw mr ms mb mt bi translated">缓冲器</h2><p id="e7cc" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">buffer</code>操作器缓冲源可观测值，直到<code class="fe lb lc ld le b">closingNotifier </code>发出。</p><p id="4ac8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它需要一个参数，即<code class="fe lb lc ld le b">closingNotifier</code>。它是一个可观测值，表示输出可观测值上要发出的缓冲信号。</p><p id="c15b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="b479" class="mi lg iq le b gy nc nd l ne nf">import { fromEvent, timer } from "rxjs";<br/>import { buffer } from "rxjs/operators";</span><span id="9d46" class="mi lg iq le b gy ng nd l ne nf">const observable = timer(1000, 1000);<br/>const clicks = fromEvent(document, "click");<br/>const buffered = observable.pipe(buffer(clicks));<br/>buffered.subscribe(x =&gt; console.log(x));</span></pre><p id="bbc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们有一个由<code class="fe lb lc ld le b">timer</code>操作符创建的可观察对象，它在等待1秒钟后每秒钟发出一个数字。然后，我们将结果输入到<code class="fe lb lc ld le b">clicks</code> Observable中，当文档被点击时，这个Observable就会发出。</p><p id="3f12" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这意味着当我们点击页面时，由<code class="fe lb lc ld le b">buffer</code>操作符缓冲的发出的数据将发出被缓冲的数据。同时，这意味着当我们点击我们的文档时，我们将得到任何东西，从一个空数组到一个在点击之间发出的值数组。</p><h1 id="3954" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">缓冲计数</h1><p id="9536" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">bufferCount</code>与<code class="fe lb lc ld le b">buffer</code>略有不同，它会缓冲数据，直到大小达到最大值<code class="fe lb lc ld le b">bufferSize</code>。</p><p id="3215" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有两个参数，一个是<code class="fe lb lc ld le b">bufferSize</code>，它是缓冲的最大大小，另一个是<code class="fe lb lc ld le b">startBufferEvery</code>参数，它是一个可选参数，表示启动一个新缓冲区的时间间隔。</p><p id="3974" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my le mz na aw nb bi"><span id="e6d6" class="mi lg iq le b gy nc nd l ne nf">import { fromEvent } from "rxjs";<br/>import { bufferCount } from "rxjs/operators";<br/>const clicks = fromEvent(document, "click");<br/>const buffered = clicks.pipe(bufferCount(10));<br/>buffered.subscribe(x =&gt; console.log(x));</span></pre><p id="59ca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将在我们点击10次后发出缓冲到数组中的<code class="fe lb lc ld le b">MouseEvent</code>对象，因为这是我们10个<code class="fe lb lc ld le b">MouseEvent</code>对象被原始可观察对象发出的时候。</p><p id="a59f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们所看到的，连接创建操作符让我们能够以多种方式组合Observables发出的数据。我们可以选择最先发出的，我们可以将所有发出的数据合并成一个，我们可以同时得到它们。</p><p id="45e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们可以缓冲Observable发出的数据，并在缓冲了给定的量或者触发事件将发出缓冲区中的数据时发出它们。</p></div></div>    
</body>
</html>