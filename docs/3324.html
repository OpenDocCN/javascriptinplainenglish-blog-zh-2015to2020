<html>
<head>
<title>Handle User Login and Authenticated Requests in Node.js with JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用JWT处理Node.js中的用户登录和认证请求</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-jwt-user-login-and-making-an-authenticated-request-9acf9e3d7559?source=collection_archive---------0-----------------------#2020-09-19">https://javascript.plainenglish.io/node-js-jwt-user-login-and-making-an-authenticated-request-9acf9e3d7559?source=collection_archive---------0-----------------------#2020-09-19</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/b86f39f2a1d6c602686daaf4cb6f42ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Z0R-JwPmTxMJLsqlmZ_uEw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Cover Image</figcaption></figure><p id="167a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">大家好。这个博客将是我之前博客的延续。查看我以前的博客来理解这个演示的流程。</p><div class="la lb gp gr lc ld"><a href="https://medium.com/@sjlouji10/node-js-api-user-registration-with-jwt-b6b74fe599e9" rel="noopener follow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd ir gy z fp li fr fs lj fu fw ip bi translated">节点JS —向JWT注册API用户</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">JWT是在双方之间安全传输数据的开放标准。它与认证系统一起使用，以…</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">medium.com</p></div></div><div class="lm l"><div class="ln l lo lp lq lm lr jw ld"/></div></div></a></div><p id="9a2a" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在这篇博客中，我将解释如何用节点js和JWT创建一个登录API视图。所以让我们开始吧。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="173f" class="lz ma iq bd mb mc md dn me mf mg dp mh kn mi mj mk kr ml mm mn kv mo mp mq mr bi translated"><strong class="ak">目录</strong></h2><ol class=""><li id="9d66" class="ms mt iq ke b kf mu kj mv kn mw kr mx kv my kz mz na nb nc bi translated"><a class="ae nd" href="#6da0" rel="noopener ugc nofollow">初始设置</a></li><li id="b96e" class="ms mt iq ke b kf ne kj nf kn ng kr nh kv ni kz mz na nb nc bi translated"><a class="ae nd" href="#ec33" rel="noopener ugc nofollow">用户登录并生成JWT令牌</a></li><li id="cba8" class="ms mt iq ke b kf ne kj nf kn ng kr nh kv ni kz mz na nb nc bi translated"><a class="ae nd" href="#c887" rel="noopener ugc nofollow">验证模式</a></li><li id="3ee2" class="ms mt iq ke b kf ne kj nf kn ng kr nh kv ni kz mz na nb nc bi translated"><a class="ae nd" href="#81f9" rel="noopener ugc nofollow">发出认证请求</a></li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h2 id="6da0" class="lz ma iq bd mb mc md dn me mf mg dp mh kn mi mj mk kr ml mm mn kv mo mp mq mr bi translated"><strong class="ak"> 1。初始设置</strong></h2><p id="5838" class="pw-post-body-paragraph kc kd iq ke b kf mu kh ki kj mv kl km kn nj kp kq kr nk kt ku kv nl kx ky kz ij bi translated">在这一部分，我只是总结了我们在之前的博客中所做的事情。</p><p id="648f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最初，我们创建了一个服务器，并用mongoose实例将它连接到MongoDB数据库。然后我们创建了四个名为<code class="fe nm nn no np b">Models, Middleware, Controller, Routes.</code>的文件夹</p><p id="4d6c" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">index.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="48b9" class="lz ma iq np b gy ny nz l oa ob">const express = require('express')<br/>const bodyparser = require('body-parser');<br/>const mongoose = require('mongoose')<br/>const router = require('./Routes/auth.route')<br/>var app = express()</span><span id="09d1" class="lz ma iq np b gy oc nz l oa ob">//Routes<br/>app.use(bodyparser.json())<br/>app.get('/', function(req,res){<br/>res.send('Hello world')<br/>})<br/>app.use('/account/api',router)</span><span id="54c6" class="lz ma iq np b gy oc nz l oa ob">//MongoDb connection<br/>mongoose.connect('mongodb://localhost/test', {useNewUrlParser: true});<br/>mongoose.connection.once('open',function(){<br/>  console.log('Database connected Successfully');<br/>}).on('error',function(err){<br/>  console.log('Error', err);<br/>})</span><span id="cc27" class="lz ma iq np b gy oc nz l oa ob">//Server<br/>app.listen('8000',function(req,res){<br/>  console.log('Serve is up and running at the port 8000')<br/>})</span></pre><p id="49c5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建服务器后，我们创建了一个名为<code class="fe nm nn no np b">auth.route</code>的路由文件来处理所有的认证请求。</p><p id="e1a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">Routes/auth.route.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="987b" class="lz ma iq np b gy ny nz l oa ob">const router = require('express').Router()<br/>const signup = require('../Controller/auth.controller')<br/>const {validateUser} = require('../Middleware/validation');</span><span id="be94" class="lz ma iq np b gy oc nz l oa ob">router.post('/signup',validateUser,signup.signup)</span><span id="285c" class="lz ma iq np b gy oc nz l oa ob">module.exports = router</span></pre><p id="cb62" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">然后，我们创建了一个带有属性name、email、password的用户模式。</p><p id="7680" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">Models/user.model.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="e455" class="lz ma iq np b gy ny nz l oa ob">const mongoose = require('mongoose')</span><span id="c944" class="lz ma iq np b gy oc nz l oa ob">const userSchema = new mongoose.Schema({<br/>  name: {<br/>    type: String,<br/>    required: true,<br/>    max: 200,<br/>  },</span><span id="b468" class="lz ma iq np b gy oc nz l oa ob">  email: {<br/>    type: String,<br/>    required: true,<br/>    unique: true,<br/>  },</span><span id="e626" class="lz ma iq np b gy oc nz l oa ob">  password: {<br/>    type: String,<br/>    required: true,<br/>    min: 5<br/>  },<br/> },{timestamps: true}<br/>)</span><span id="ea6b" class="lz ma iq np b gy oc nz l oa ob">module.exports = mongoose.model('User',userSchema)</span></pre><p id="e7e8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在创建模型文件之后，我们创建了一个auth控制器，并编写了注册逻辑。</p><p id="c70d" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">Controller/auth.controller.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="1473" class="lz ma iq np b gy ny nz l oa ob">const User = require('../Models/user.model')<br/>const bycrypt = require('bcryptjs')<br/>const jwt = require("jsonwebtoken");</span><span id="1121" class="lz ma iq np b gy oc nz l oa ob">async function signup(req,res,next) {</span><span id="d025" class="lz ma iq np b gy oc nz l oa ob">  const salt = await bycrypt.genSalt(10);<br/>  hashpassword = await bycrypt.hash(req.body.password, salt)</span><span id="b1fe" class="lz ma iq np b gy oc nz l oa ob">  const emailExist = await User.findOne({email: req.body.email})</span><span id="4df8" class="lz ma iq np b gy oc nz l oa ob">  if(emailExist){<br/>    res.status(400).json({"error":'Email already Exist'})<br/>  }</span><span id="08a1" class="lz ma iq np b gy oc nz l oa ob">  const user =  new User({<br/>    name: req.body.name,<br/>    email: req.body.email,<br/>    password: hashpassword<br/>  })<br/>  try{<br/>    const userSignup = await user.save()<br/>    const payload = {<br/>      user: {<br/>        id: userSignup.id<br/>      }<br/>    };<br/>    jwt.sign(payload,"anystring",{expiresIn: 10000},function(err, token){<br/>      if(err){<br/>        res.send(err)<br/>      }<br/>      res.status(200).json({<br/>        token,<br/>        userSignup<br/>      })<br/>    })<br/>  }<br/>  catch(err){<br/>    res.status(400).json({'error':err}) <br/>  }<br/>}</span><span id="bc7f" class="lz ma iq np b gy oc nz l oa ob">module.exports = {<br/>  signup,<br/>  login,<br/>}</span></pre><p id="0399" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，我们创建了一个验证中间件来验证我们的注册请求。</p><p id="d830" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">Middleware/validation.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="4675" class="lz ma iq np b gy ny nz l oa ob">const {check, validationResult} = require('express-validator');exports.validateUser = [<br/>  check('name')<br/>    .trim()<br/>    .escape()<br/>    .not()<br/>    .isEmpty()<br/>    .withMessage('User name can not be empty!')<br/>    .bail()<br/>    .isLength({min: 3})<br/>    .withMessage('Minimum 3 characters required!')<br/>    .bail(),  check('email')<br/>    .trim()<br/>    .normalizeEmail()<br/>    .not()<br/>    .isEmpty()<br/>    .withMessage('Invalid email address!')<br/>    .bail(),  check('password')<br/>    .not()<br/>    .isEmpty()<br/>    .withMessage('Password cannot be empty')<br/>    .isLength({min: 6})<br/>    .withMessage('Password must be more that 6 charecters'),  <br/>(req, res, next) =&gt; {<br/>    const errors = validationResult(req);<br/>    if (!errors.isEmpty())<br/>      return res.status(422).json({errors: errors.array()});<br/>    next();<br/>  },<br/>];</span></pre><p id="cb4b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我们的项目文件看起来如下。</p><figure class="nq nr ns nt gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/85a0c8192d586f69995df63172752f1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*eSxl6S98BjC7_T_JRdwsPw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Project Structure</figcaption></figure><h2 id="ec33" class="lz ma iq bd mb mc md dn me mf mg dp mh kn mi mj mk kr ml mm mn kv mo mp mq mr bi translated">2.<strong class="ak">用户登录</strong></h2><p id="492c" class="pw-post-body-paragraph kc kd iq ke b kf mu kh ki kj mv kl km kn nj kp kq kr nk kt ku kv nl kx ky kz ij bi translated">现在让我们开始创建登录功能。首先，我在<code class="fe nm nn no np b">auth.controller</code>文件中创建了一个名为login的异步函数。在函数内部，我只是检查用户提供的电子邮件是否存在。如果是这样，我将用户给出的密码与数据库中存储的密码进行比较。最后，我将生成一个JWT令牌，并将其发送给用户，就像我们在注册部分所做的那样。</p><p id="ea41" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">Controller/auth.controller.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="667c" class="lz ma iq np b gy ny nz l oa ob">//Login Controller<br/>async function login(req,res,next){<br/>  const emailExist = await User.findOne({email: req.body.email})<br/>  if(!emailExist){<br/>    res.status(400).json({error:"Email not Found"})<br/>  }</span><span id="d66c" class="lz ma iq np b gy oc nz l oa ob">  const checkpassword = await bycrypt.compare(req.body.password,   emailExist.password)<br/>  if(!checkpassword){<br/>    res.status(400).json({error:"Password mismatch"})<br/>  }<br/><strong class="np ir">  const token = jwt.sign({id: emailExist.id},'anystring')<br/>  res.header('auth-token',token).json({'Token':token})</strong><br/>}</span><span id="288c" class="lz ma iq np b gy oc nz l oa ob">module.exports = {<br/>  signup,<br/><strong class="np ir">  login,<br/></strong>}</span></pre><p id="1b58" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">执行完所有这些操作后，只需调用auth路由器中的登录控制器。</p><p id="e0e6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">Routes/auth.route.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="6168" class="lz ma iq np b gy ny nz l oa ob">const login = require('../Controller/auth.controller')</span><span id="7639" class="lz ma iq np b gy oc nz l oa ob"><strong class="np ir">router.post('/login',login.login)</strong></span></pre><p id="2b5e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在导航到<a class="ae nd" href="http://localhost:8000/account/api/login" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/account/API/log in</a>，使用用户凭证发出post请求。您将收到一个令牌，您可以用它向服务器发出经过身份验证的请求。</p><figure class="nq nr ns nt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/494f9f340a00b9d1ae3b2fc887064b2e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6D7tHPHEvA0P_Vc1RJ4p2A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">User Login</figcaption></figure><h2 id="c887" class="lz ma iq bd mb mc md dn me mf mg dp mh kn mi mj mk kr ml mm mn kv mo mp mq mr bi translated">3.<strong class="ak">验证模式</strong></h2><p id="2f53" class="pw-post-body-paragraph kc kd iq ke b kf mu kh ki kj mv kl km kn nj kp kq kr nk kt ku kv nl kx ky kz ij bi translated">现在让我们创建一个验证函数来验证我们的请求。为此，我使用了<code class="fe nm nn no np b">express-validator</code>。</p><p id="7ac7" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">Middleware/loginvalidation.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="be71" class="lz ma iq np b gy ny nz l oa ob">const {check, validationResult} = require('express-validator');</span><span id="f00a" class="lz ma iq np b gy oc nz l oa ob">exports.loginValidation = [<br/>  check('email')<br/>    .trim()<br/>    .normalizeEmail()<br/>    .not()<br/>    .isEmpty()<br/>    .withMessage('Invalid email address!')<br/>    .bail(),</span><span id="e553" class="lz ma iq np b gy oc nz l oa ob">  check('password')<br/>    .not()<br/>    .isEmpty()<br/>    .withMessage('Password cannot be empty')<br/>    .isLength({min: 6})<br/>    .withMessage('Password must be more that 6 charecters'),</span><span id="c58a" class="lz ma iq np b gy oc nz l oa ob">(req, res, next) =&gt; {<br/>  const errors = validationResult(req);<br/>  if (!errors.isEmpty())<br/>    return res.status(422).json({errors: errors.array()});<br/>  next();<br/>  },<br/>];</span></pre><p id="4d09" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">Routes/auth.route.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="6ca2" class="lz ma iq np b gy ny nz l oa ob">router.post('/login',<strong class="np ir">loginValidation</strong>,login.login)</span></pre><p id="76ea" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在用一些错误的完整数据向登录路由发出post请求。验证中间件将验证您的函数，如果发现错误，将返回错误。</p><figure class="nq nr ns nt gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/526be3f559d018a71f53c22b0727fb49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*wNG7P4QSQOxA84cVxzvgsg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Login Validation</figcaption></figure><h2 id="81f9" class="lz ma iq bd mb mc md dn me mf mg dp mh kn mi mj mk kr ml mm mn kv mo mp mq mr bi translated">4.<strong class="ak">发出认证请求</strong></h2><p id="ef43" class="pw-post-body-paragraph kc kd iq ke b kf mu kh ki kj mv kl km kn nj kp kq kr nk kt ku kv nl kx ky kz ij bi translated">到目前为止，我们已经用JWT创建了一个登录和注册API。现在，让我们以一种只有登录用户才能访问的方式来保护我们的路由。</p><p id="a423" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为此，我在<code class="fe nm nn no np b">Middleware</code>文件夹中创建了一个名为<code class="fe nm nn no np b">auth.js</code>的中间件。该函数只是从客户端接收auth令牌，并验证auth令牌是否有效。如果有效，它将允许用户访问该路线。如果是现在，则返回令牌无效。</p><p id="3b36" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">Middleware/auth.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="1493" class="lz ma iq np b gy ny nz l oa ob">const jwt = require("jsonwebtoken");</span><span id="6ef8" class="lz ma iq np b gy oc nz l oa ob">module.exports = function(req, res, next) {<br/>  const token = req.header("auth-token");<br/>  if (!token) return res.status(401).json({ message: "Authentication Failed" });<br/><strong class="np ir">    try {<br/>      const val = jwt.verify(token, "anystring");<br/>      req.user = val;<br/>      next();<br/>    } catch (e) {<br/>      console.error(e);<br/>      res.status(500).send({ message: "Token Invalid" });<br/>    }</strong><br/>};</span></pre><p id="c91b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将身份验证中间件集成到我们的路由中非常简单。只是将中间件作为一个参数传递给路由器。</p><p id="bac9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">Routes/auth.route.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="7037" class="lz ma iq np b gy ny nz l oa ob">const auth = require('../Middleware/auth')</span><span id="99bb" class="lz ma iq np b gy oc nz l oa ob">router.get('/user',<strong class="np ir">auth</strong>, getCurrentUser.getCurrentUser)</span></pre><p id="caa9" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">下面我正在创建一个返回用户详细信息的控制器。如果提供的令牌是有效的，此功能将起作用，即控制器将只对登录的用户可用。</p><p id="d294" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe nm nn no np b">Controller/auth.controller.js</code></p><pre class="nq nr ns nt gt nu np nv nw aw nx bi"><span id="c147" class="lz ma iq np b gy ny nz l oa ob">async function getCurrentUser(req,res){<br/><strong class="np ir">  try {<br/>    const user = await User.findById(req.user._id);<br/>    res.json(user);<br/>  } catch (e) {<br/>    res.send({ message: "Error in Fetching user" });<br/>  }</strong><br/>}</span><span id="9ed2" class="lz ma iq np b gy oc nz l oa ob">module.exports = {<br/>  signup,<br/>  login,<br/>  getCurrentUser,<br/>}</span></pre><p id="4104" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">导航到<a class="ae nd" href="http://localhost:8000/account/api/user" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/account/API/user</a>并发出一个不带令牌的GET请求。这个请求将以一个错误结束。对JWT令牌进行同样的操作，这将返回您的用户详细信息。</p><div class="nq nr ns nt gt ab cb"><figure class="og jr oh oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/bacf8bea8fe481d7f4b59ee1f6441978.png" data-original-src="https://miro.medium.com/v2/resize:fit:976/format:webp/1*tidf-_PkoPfjR5NR-MfXmw.png"/></div></figure><figure class="og jr om oi oj ok ol paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><img src="../Images/adccfe95d2bab8328171922e6bbfeaf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1026/format:webp/1*e0x-06Jfia0HTtaCcbinOQ.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk on di oo op">Authenticated request</figcaption></figure></div><p id="84c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请访问我以前的博客，在那里我解释了如何用Node js和JWT创建用户注册。</p><p id="2402" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如有任何疑问，请随时联系我。电子邮件:sjlouji10@gmail.com。领英:<a class="ae nd" href="https://www.linkedin.com/in/sjlouji/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/sjlouji/</a></p><p id="1859" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我的GitHub上的完整代码:</p><div class="la lb gp gr lc ld"><a href="https://github.com/sjlouji/Node-js-JWT-auth---Medium" rel="noopener  ugc nofollow" target="_blank"><div class="le ab fo"><div class="lf ab lg cl cj lh"><h2 class="bd ir gy z fp li fr fs lj fu fw ip bi translated">sjlouji/Node-js-JWT-授权-介质</h2><div class="lk l"><h3 class="bd b gy z fp li fr fs lj fu fw dk translated">节点和快递JS - JWT认证。通过在…上创建帐户，为sjlouji/Node-js-JWT-auth-Medium开发做出贡献</h3></div><div class="ll l"><p class="bd b dl z fp li fr fs lj fu fw dk translated">github.com</p></div></div><div class="lm l"><div class="oq l lo lp lq lm lr jw ld"/></div></div></a></div><p id="9558" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">编码快乐！</p></div></div>    
</body>
</html>