<html>
<head>
<title>How to use Generators in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript中使用生成器</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-use-generators-in-javascript-5ac691a917c?source=collection_archive---------7-----------------------#2020-07-16">https://javascript.plainenglish.io/how-to-use-generators-in-javascript-5ac691a917c?source=collection_archive---------7-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="0e15" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">了解如何在JavaScript中使用生成器关键字</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/1e633551f96d5f3b097a4c5ced6b57f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*PcVV-Stq79lbp4y8tYcdqA.jpeg"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by Caspar Camille Rubin on Unsplash</figcaption></figure><p id="eb77" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">今天，我们将了解JavaScript中生成器的功能。对于经常使用JavaScript进行开发的开发人员来说，这个概念是未知的。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="7385" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">发电机</h1><p id="00b1" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">生成器是一种不同于普通函数的函数。它有独特的功能被激发和重新进入，它的变量在重新进入中被保留。</p><p id="ae37" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">有了JavaScript中的ES6，我们知道了箭头函数、运算符等基本功能..，让我们深入了解生成器的概念，看看它是如何工作的。如果我们可以执行一个常规的函数，解释器会重复执行代码，直到函数结束。这被称为从运行到完成的模型。</p><p id="5c79" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一个例子，</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="f4ab" class="na lz iq mw b gy nb nc l nd ne">function regularFunction() {<br/>    console.log("I'm a regular function")<br/>    console.log("Surprise surprice")<br/>    console.log("This is the end")<br/>}<br/><br/>regularFunction()<br/><br/>-----------------<br/>Output<br/>-----------------<br/>I'm a regular function<br/>Surprise surprice<br/>This is the end</span></pre><p id="8f06" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如您在上面的代码中所看到的，这是一个常规的函数，它会重复执行，直到到达末尾或返回一个值。如果我们想在某个时候停止这个功能并继续。我们如何做到这一点？这就是发电机的特性。</p><h1 id="c515" class="ly lz iq bd ma mb nf md me mf ng mh mi jw nh jx mk jz ni ka mm kc nj kd mo mp bi translated">第一发生器功能</h1><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="8c11" class="na lz iq mw b gy nb nc l nd ne">function* generatorFunction() {<br/>    yield "This is the first return"<br/>    console.log("First log!")<br/>    yield "This is the second return"<br/>    console.log("Second log!")<br/>    return "Done!"<br/>}</span></pre><p id="9b2e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在执行上述函数之前，您必须了解什么是函数？它的语法以及如何将它们声明为生成器。除此之外，你还遇到了屈服这个词。所以你也会知道产量的作用。收益不算什么，但它将暂停执行，并将所有函数保存在其状态中，然后从我们暂停的地方继续。</p><p id="b0f9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一个例子，</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="e1e0" class="na lz iq mw b gy nb nc l nd ne">generatorFunction()<br/><br/>-----------------<br/>Output<br/>-----------------<br/>generatorFunction {&lt;suspended&gt;} {<br/>    __proto__: Generator<br/>    [[GeneratorLocation]]: VM272:1<br/>    [[GeneratorStatus]]: "suspended"<br/>    [[GeneratorFunction]]: ƒ* generatorFunction()<br/>    [[GeneratorReceiver]]: Window<br/>    [[Scopes]]: Scopes[3]<br/>}</span></pre><p id="8ebc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">从上面的例子中，如果我们调用一个生成器函数，它不会被自动触发。相反，它返回一个迭代器对象。该对象定义当调用方法<strong class="kx ir"> next() </strong>时，生成器函数体被执行，直到它返回第一个表达式。让我们看看它是如何工作的。</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="9c63" class="na lz iq mw b gy nb nc l nd ne">const myGenerator = generatorFunction()<br/>myGenerator.next()<br/><br/>-----------------<br/>Output<br/>-----------------<br/>{value: "This is the first return", done: false}</span></pre><p id="14c6" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">正如我们之前看到的，生成器将重复执行，直到第一个yield语句返回一个对象。生成的对象包含一个<strong class="kx ir">值</strong>属性和一个<strong class="kx ir"> done </strong>属性。</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="93f3" class="na lz iq mw b gy nb nc l nd ne">{ value: ..., done: ... }</span></pre><p id="1bcc" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir">价值</strong> -它是一种财产，等于我们付出多少的价值。</p><p id="7e7d" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><strong class="kx ir"> Done </strong> -这是一个具有布尔值的属性，只有当生成器函数返回一个值时，该属性值才设置为真。</p><p id="270b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们再次调用<strong class="kx ir"> next() </strong>函数。</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="6d80" class="na lz iq mw b gy nb nc l nd ne">myGenerator.next()<br/><br/>-----------------<br/>Output<br/>-----------------<br/>First log!<br/>{value: "This is the second return", done: false}</span></pre><p id="d945" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此时，我们可以在<strong class="kx ir">控制台看到，日志</strong>生成器主体被执行并返回<strong class="kx ir">第一个日志</strong>！然后第二个物体屈服了。让我们继续同样的过程。</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="bdf7" class="na lz iq mw b gy nb nc l nd ne">myGenerator.next()<br/><br/>-----------------<br/>Output<br/>-----------------<br/>Second log!<br/>{value: "Done!", done: true}</span></pre><p id="0594" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在第二条<strong class="kx ir"> console.log </strong>语句被执行，我们得到一个新的返回对象，但是这次<strong class="kx ir"> done </strong>属性被执行并设置为true。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="008c" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">产生迭代器</h1><p id="e22a" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">在我们深入探讨这个问题之前，还有一个函数叫做<strong class="kx ir"> yield* </strong>。它定义了它将允许我们通过创建一个新的函数来迭代一个数组。让我们试试，</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="804b" class="na lz iq mw b gy nb nc l nd ne">function* yieldArray(arr) {<br/>    yield arr<br/>}<br/><br/>const myArrayGenerator1 = yieldArray([1, 2, 3])<br/>myArrayGenerator1.next()<br/><br/>-----------------<br/>Output<br/>-----------------<br/>{value: Array(3), done: false}</span></pre><p id="b91c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是我们不能得到我们所期望的，我们希望得到数组中的每个元素。所以让我们尝试一些更有趣的。</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="5a77" class="na lz iq mw b gy nb nc l nd ne">function* yieldArray(arr) {<br/>    for (element of arr) {<br/>        yield element<br/>    }<br/>}<br/><br/>const myArrayGenerator2 = yieldArray([1, 2, 3])<br/>myArrayGenerator2.next()<br/>myArrayGenerator2.next()<br/>myArrayGenerator2.next()<br/><br/>-----------------<br/>Output<br/>-----------------<br/>{value: 1, done: false}<br/>{value: 2, done: false}<br/>{value: 3, done: false}</span></pre><p id="71a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在我们得到了它，但我们仍然可以做得更好。让我们再试一次。</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="ada7" class="na lz iq mw b gy nb nc l nd ne">function* yieldArray(arr) {<br/>    yield* arr<br/>}<br/><br/>const myArrayGenerator3 = yieldArray([1, 2, 3])<br/>myArrayGenerator3.next()<br/>myArrayGenerator3.next()<br/>myArrayGenerator3.next()<br/><br/>-----------------<br/>Output<br/>-----------------<br/>{value: 1, done: false}<br/>{value: 2, done: false}<br/>{value: 3, done: false}</span></pre><p id="fb75" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">太棒了。通过使用<strong class="kx ir"> yield* </strong>表达式，我们可以迭代操作数并产生数组中的每个值并返回给它。我们可以将这个策略应用到其他生成器、数组、字符串等。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="5039" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">发电机的重要性</h1><p id="0033" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">重要的是，它们的计算速度非常慢，这是因为在我们调用<strong class="kx ir"> next() </strong>方法后，该值将被返回，只有在我们调用它时才会被计算。这为解决多个场景提供了更好的性能。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="e1b2" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">生成无限序列</h1><p id="3afe" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我们可以使用生成器生成无限数量的序列。让我们用质数来做这个。在这种情况下，我使条件<strong class="kx ir"> i &gt; =10 </strong>从循环中退出。否则会永远迭代下去。</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="5198" class="na lz iq mw b gy nb nc l nd ne">function* infiniteSequence() {<br/>    let num = 0<br/>    while (true) {<br/>        yield num<br/>        num += 1<br/>    }<br/>}<br/><br/>for(i of infiniteSequence()) {<br/>    if (i &gt;= 10) {<br/>        break<br/>    }<br/>    console.log(i)<br/>}<br/><br/>-----------------<br/>Output<br/>-----------------<br/>0<br/>1<br/>2<br/>3<br/>4<br/>5<br/>6<br/>7<br/>8<br/>9</span></pre><h1 id="4ba6" class="ly lz iq bd ma mb nf md me mf ng mh mi jw nh jx mk jz ni ka mm kc nj kd mo mp bi translated">实现迭代器</h1><p id="301b" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">为了实现iterable，首先您必须使用<strong class="kx ir"> next() </strong>方法手动创建一个对象，并将其保存到状态中。</p><p id="2494" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们用一个例子来说明，我们想要的输出是<strong class="kx ir"> I </strong>，<strong class="kx ir">是</strong>，<strong class="kx ir">可迭代的。</strong>不使用发电机进行此项操作。</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="c5e7" class="na lz iq mw b gy nb nc l nd ne">const iterableObj = {<br/>  [Symbol.iterator]() {<br/>    let step = 0;<br/>    return {<br/>      next() {<br/>        step++;<br/>        if (step === 1) {<br/>          return { value: 'I', done: false};<br/>        } else if (step === 2) {<br/>          return { value: 'am', done: false};<br/>        } else if (step === 3) {<br/>          return { value: 'iterable.', done: false};<br/>        }<br/>        return { value: '', done: true };<br/>      }<br/>    }<br/>  },<br/>}<br/>for (const val of iterableObj) {<br/>  console.log(val);<br/>}<br/><br/>-----------------<br/>Output<br/>-----------------<br/>I<br/>am<br/>iterable.</span></pre><p id="c44f" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">使用发电机也可以做到这一点。</p><pre class="kg kh ki kj gt mv mw mx my aw mz bi"><span id="b3ea" class="na lz iq mw b gy nb nc l nd ne">function* iterableObj() {<br/>    yield 'I'<br/>    yield 'am'<br/>    yield 'iterable.'<br/>}<br/><br/>for (const val of iterableObj()) {<br/>  console.log(val);<br/>}<br/><br/>-----------------<br/>Output<br/>-----------------<br/>I<br/>am<br/>iterable.</span></pre></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="8673" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">限制</h1><p id="de20" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我们只能访问生成器对象一次。一旦用尽，你就不能再迭代了。如果你想这样做，你必须创建一个新的生成器对象。</p><p id="7f88" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些对象不允许随机访问实例、数组。如果你想得到它，你必须调用所有的<strong class="kx ir"> next() </strong>函数手动进入你得到想要的输出。</p></div><div class="ab cl lr ls hu lt" role="separator"><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw lx"/><span class="lu bw bk lv lw"/></div><div class="ij ik il im in"><h1 id="aa6d" class="ly lz iq bd ma mb mc md me mf mg mh mi jw mj jx mk jz ml ka mm kc mn kd mo mp bi translated">结论</h1><p id="3212" class="pw-post-body-paragraph kv kw iq kx b ky mq jr la lb mr ju ld le ms lg lh li mt lk ll lm mu lo lp lq ij bi translated">我希望你喜欢，现在你将知道JavaScript中的生成器的功能。您可以在您的项目中实现这个概念。</p><p id="067a" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">感谢阅读！</p></div></div>    
</body>
</html>