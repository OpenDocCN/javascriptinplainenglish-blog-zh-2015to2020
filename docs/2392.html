<html>
<head>
<title>How to Handle a Series of Transactions in Node.js using Event Emitter</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用事件发射器处理Node.js中的一系列事务</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-handle-a-series-of-transactions-in-node-js-using-event-emitter-128cc7de24c2?source=collection_archive---------3-----------------------#2020-06-20">https://javascript.plainenglish.io/how-to-handle-a-series-of-transactions-in-node-js-using-event-emitter-128cc7de24c2?source=collection_archive---------3-----------------------#2020-06-20</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f302" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">你可以自己应用的实用指南</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/fc8c0f89303c8c9114d425164587d3c2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*cUOknyEHrQ6wGqynmp__Eg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Picture from <a class="ae ks" href="https://www.pexels.com/photo/grayscale-photo-of-computer-laptop-near-white-notebook-and-ceramic-mug-on-table-169573/" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><h1 id="fe8c" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">1.什么是一系列交易？</h1><p id="33c4" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我们经常处理一类涉及一组顺序执行的事务的事务。我们称之为一系列的交易。</p><p id="0a8c" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">下面以<strong class="ln io"> <em class="mm">网购</em> </strong>为例。当购物交易发生时，通常采取以下步骤:</p><ol class=""><li id="3001" class="mn mo in ln b lo mh lr mi lu mp ly mq mc mr mg ms mt mu mv bi translated"><strong class="ln io">将订单和详细信息保存到应用数据库</strong>。数据库可以是任何类型，例如<em class="mm"> MySQL </em>、<em class="mm"> PostgreSQL </em>、<em class="mm"> MongoDB </em>或其他。订单详细信息可能包括以下信息:<em class="mm">创建订单的客户、商品、订购数量和交货地址</em>。</li><li id="42bd" class="mn mo in ln b lo mw lr mx lu my ly mz mc na mg ms mt mu mv bi translated"><strong class="ln io">通知客户订单确认</strong>。应用程序向客户发送订单确认，例如通过电子邮件。</li><li id="00d5" class="mn mo in ln b lo mw lr mx lu my ly mz mc na mg ms mt mu mv bi translated"><strong class="ln io">向第三方运输商预订交货单。</strong>应用程序向第三方运输商预订交货单，以安排将订单运送到客户的地址。</li><li id="81b4" class="mn mo in ln b lo mw lr mx lu my ly mz mc na mg ms mt mu mv bi translated"><strong class="ln io">等等等等。</strong></li></ol><p id="5925" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">根据业务需求，我们可能会有更多的后续交易列表。但是现在，让我们假设这三个步骤是我们网上购物过程中需要的所有步骤。现在，让我们进入下一节，看看Node.js的情况如何。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h1 id="7ab6" class="kt ku in bd kv kw ni ky kz la nj lc ld jt nk ju lf jw nl jx lh jz nm ka lj lk bi translated">2.Node.js中的实现(传统方法)</h1><p id="ea06" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">我们从使用Node.js处理在线购物案例的传统方法开始。</p><p id="895f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">首先，为我们的Node.js API服务器创建一个空文件夹<code class="fe nn no np nq b">api</code>，并在这里克隆源代码<a class="ae ks" href="https://github.com/nadinugraha/events" rel="noopener ugc nofollow" target="_blank"/>。请注意，代码是骨架格式。这将使它们保持简单，因为您以后可能想要修改它们。应用程序结构如下:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div class="gh gi nr"><img src="../Images/d26bf5062105b3e00bbe6fb2728cbd97.png" data-original-src="https://miro.medium.com/v2/resize:fit:540/format:webp/1*9FFu6qSgUohYPC0wu6-91Q.jpeg"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Application structure</figcaption></figure><ol class=""><li id="1217" class="mn mo in ln b lo mh lr mi lu mp ly mq mc mr mg ms mt mu mv bi translated"><code class="fe nn no np nq b">data</code>文件夹包含<code class="fe nn no np nq b">order.js</code>文件，我们在其中定义客户订单的JSON结构。</li><li id="de74" class="mn mo in ln b lo mw lr mx lu my ly mz mc na mg ms mt mu mv bi translated"><code class="fe nn no np nq b">helper</code>文件夹包含我们在<code class="fe nn no np nq b">emitter.js</code>文件中定义的事件发射器。<strong class="ln io">注意:</strong>由于我们是用传统方法开发的，我们可以暂时忽略这个库。我们将在下一节稍后使用它。</li><li id="a3ad" class="mn mo in ln b lo mw lr mx lu my ly mz mc na mg ms mt mu mv bi translated"><code class="fe nn no np nq b">handlers</code>文件夹是我们为其他事务创建处理库的地方。到目前为止，我们有三个负责人:</li></ol><ul class=""><li id="4151" class="mn mo in ln b lo mh lr mi lu mp ly mq mc mr mg ns mt mu mv bi translated"><code class="fe nn no np nq b">customers.js</code>:通知客户的处理程序。</li><li id="f2ec" class="mn mo in ln b lo mw lr mx lu my ly mz mc na mg ns mt mu mv bi translated"><code class="fe nn no np nq b">transporters.js</code>:登记发货单的处理程序。</li><li id="7615" class="mn mo in ln b lo mw lr mx lu my ly mz mc na mg ns mt mu mv bi translated"><code class="fe nn no np nq b">suppliers.js</code>:在物品库存水平低的情况下订购物品的处理程序。</li></ul><p id="7b69" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在<code class="fe nn no np nq b">api</code>文件夹中，使用<strong class="ln io">命令提示符</strong>或<strong class="ln io">终端</strong>键入以下内容:</p><pre class="kd ke kf kg gt nt nq nu nv aw nw bi"><span id="2bd7" class="nx ku in nq b gy ny nz l oa ob">npm install</span></pre><p id="bf9f" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">它会将所有需要的依赖项安装到<code class="fe nn no np nq b">node_modules</code>文件夹中。</p><p id="f6bf" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">现在，让我们来看看<code class="fe nn no np nq b">server.js</code>，其中我们定义了一个名为<code class="fe nn no np nq b">createorderwithoutevent</code>的API函数</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">File: server.js</figcaption></figure><p id="4ca9" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">如果我们看看上面的<code class="fe nn no np nq b">createorderwithoutevent</code>函数，我们会注意到，在该函数将订单保存到数据库中之后，它调用了另外两个后续事务:</p><ol class=""><li id="6272" class="mn mo in ln b lo mh lr mi lu mp ly mq mc mr mg ms mt mu mv bi translated"><code class="fe nn no np nq b">customers.notifyCustomer</code>:发送<code class="fe nn no np nq b">./handlers/customers.js</code>中定义的订单确认邮件的功能。</li><li id="9bf7" class="mn mo in ln b lo mw lr mx lu my ly mz mc na mg ms mt mu mv bi translated"><code class="fe nn no np nq b">transpoters.bookForDelivery</code>:向<code class="fe nn no np nq b">./handlers/transporters.js</code>中定义的第三方运输商登记交货订单的功能。</li></ol><p id="e93b" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">让我们假设这两个事务连接到外部API服务。一般这是我们在处理一系列交易时习惯采用的方式。这没有错。</p><p id="994d" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">但是，如果业务需求发生变化，要求我们在订单流程之后再进行一次交易，该怎么办呢？假设卖方不维护其库存，因此当客户订单到达时，他需要向供应商创建采购申请。因此，我们需要创建一个新函数——<code class="fe nn no np nq b">suppliers.requestForStock</code>——，并将其放入<code class="fe nn no np nq b">createorderwithoutevent</code>函数中，如下所示:</p><pre class="kd ke kf kg gt nt nq nu nv aw nw bi"><span id="98cd" class="nx ku in nq b gy ny nz l oa ob">app.post('/createorderwithoutevent', function(req,res){<br/>   const { trxorder } = req.body;<br/>   <br/>   <em class="mm">//a new order is saved to any database e.g: mySQL, mongodb, etc.</em><br/>   orders.push(trxorder);<br/>   console.log(JSON.stringify(orders));<br/>   <br/>   <em class="mm">//these are subsequent transactions following the order saving</em><br/>   customers.notifyCustomer(trxorder.orderid);<br/>   <strong class="nq io">suppliers.requestForStock(trxorder.orderid);</strong><br/>   transporters.bookForDelivery(trxorder.orderid);<br/>   <br/>   <em class="mm">//order transaction is successfully processed</em><br/>   return res.status(200).json({"message" : "ok"});<br/>});</span></pre><p id="cef8" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">如果我们在代码中有其他功能，而业务的变化告诉我们也要将<code class="fe nn no np nq b">requestForStock</code>应用于这些功能，该怎么办？因此，我们需要逐个修改函数。<strong class="ln io">在一定程度上，当受影响的函数数量很多时，情况会变得更加复杂。</strong>我们将在下一节使用事件发射器学习更好的方法。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h1 id="5052" class="kt ku in bd kv kw ni ky kz la nj lc ld jt nk ju lf jw nl jx lh jz nm ka lj lk bi translated">3.处理一系列事务的事件发射器</h1><p id="1eb5" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><code class="fe nn no np nq b">eventEmitter</code>是Node.js中的一个模块，实现Node.js中对象之间的交互，其工作原理如下:</p><ol class=""><li id="3719" class="mn mo in ln b lo mh lr mi lu mp ly mq mc mr mg ms mt mu mv bi translated">首先，我们定义一个<code class="fe nn no np nq b">eventEmitter</code>对象。</li><li id="5f92" class="mn mo in ln b lo mw lr mx lu my ly mz mc na mg ms mt mu mv bi translated">接下来，我们将监听器函数注册到由<code class="fe nn no np nq b">eventEmitter</code>对象定义的命名事件中。</li><li id="b6ac" class="mn mo in ln b lo mw lr mx lu my ly mz mc na mg ms mt mu mv bi translated">最后，<code class="fe nn no np nq b">eventEmitter</code>对象发出命名事件，这些事件导致注册的侦听器被执行。</li></ol><p id="4029" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">关于Node.js的<code class="fe nn no np nq b">eventEmitter</code>更多细节在<a class="ae ks" href="https://nodejs.org/api/events.html#events_class_eventemitter" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="3e27" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">现在，让我们回到我们的网购案例。要使用<code class="fe nn no np nq b">eventEmitter</code>，我们需要在一个名为<em class="mm">助手</em>的新文件夹中创建一个新的助手文件——<code class="fe nn no np nq b">emitter.js</code>。</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="oc od l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">File: emitter.js</figcaption></figure><p id="8b73" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">在<code class="fe nn no np nq b">emitter.js</code>中，我们注册了所有命名的事件和当命名的事件发生时应该运行的所有监听器函数。让我们看看上面的代码。每次创建订单— <code class="fe nn no np nq b">order_created</code>，我们都会<em class="mm">通知客户，从供应商处购买一些库存物品，并预订交付给运输商</em>。这些活动是通过向<code class="fe nn no np nq b">order_created</code>事件注册监听器函数<code class="fe nn no np nq b">customers.notifyCustomer</code>、<code class="fe nn no np nq b">suppliers.requestForStock</code>和<code class="fe nn no np nq b">transporters.bookForDelivery</code>来完成的。</p><p id="2ccc" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">最后，让我们修改<code class="fe nn no np nq b">server.js</code>并创建一个名为<code class="fe nn no np nq b">createorderwithevent</code>的新函数来修补我们之前的函数<code class="fe nn no np nq b">createorderwithoutevent</code>，如下所示:</p><pre class="kd ke kf kg gt nt nq nu nv aw nw bi"><span id="f404" class="nx ku in nq b gy ny nz l oa ob">const express = require('express');<br/>const app = express();<br/>const bodyParser = require('body-parser');</span><span id="fb97" class="nx ku in nq b gy oe nz l oa ob"><em class="mm">//declare our emitter object</em><strong class="nq io"><br/>const emitter = require('./helper/emitter');</strong><br/>const orders = require('./data/orders');<br/>const customers = require('./handlers/customers');<br/>const suppliers = require('./handlers/suppliers');<br/>const transporters = require('./handlers/transporters');</span><span id="6896" class="nx ku in nq b gy oe nz l oa ob">app.use(bodyParser.json());</span><span id="3b3a" class="nx ku in nq b gy oe nz l oa ob">.....</span><span id="83a8" class="nx ku in nq b gy oe nz l oa ob"><em class="mm">//same as previous</em></span><span id="3843" class="nx ku in nq b gy oe nz l oa ob">.....</span><span id="f933" class="nx ku in nq b gy oe nz l oa ob">app.post(<strong class="nq io">'/createorderwithevent'</strong>, function(req,res){<br/>   const { trxorder } = req.body;</span><span id="caf7" class="nx ku in nq b gy oe nz l oa ob"><em class="mm">//a new order is saved to any database e.g: mySQL, mongodb etc.<br/>   </em>orders.push(trxorder);<br/>   console.log(JSON.stringify(orders));<br/>   <br/>   <strong class="nq io">emitter.emit('order_created', trxorder.orderid);</strong><br/>   return res.status(200).json({"message" : "ok"});<br/>})</span></pre><p id="9d57" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">正如您所注意到的，新函数<code class="fe nn no np nq b">createorderwithevent</code>比我们的<code class="fe nn no np nq b">createorderwithoutevent</code>函数干净多了。当订单被创建时，我们只需要发出<code class="fe nn no np nq b">order_created</code>事件。自动执行<code class="fe nn no np nq b">emitter.js</code>中注册的所有监听器功能。</p><p id="0863" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">我们新方法最好的一点是，当业务需求动态变化时，我们不需要担心。每当有变化时，<strong class="ln io">我们只需要在一个地方注册/注销监听器函数，这个地方就是<code class="fe nn no np nq b">emitter.js</code>文件中的</strong>。代码现在更加结构化，当我们有许多系列的交易时，这将减少错误。</p><p id="5e85" class="pw-post-body-paragraph ll lm in ln b lo mh jo lq lr mi jr lt lu mj lw lx ly mk ma mb mc ml me mf mg ig bi translated">请注意<code class="fe nn no np nq b">eventEmitter</code>按照注册的顺序同步调用所有监听器。因此，请确保您按照正确的顺序放置侦听器函数。</p></div><div class="ab cl nb nc hr nd" role="separator"><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng nh"/><span class="ne bw bk nf ng"/></div><div class="ig ih ii ij ik"><h1 id="5909" class="kt ku in bd kv kw ni ky kz la nj lc ld jt nk ju lf jw nl jx lh jz nm ka lj lk bi translated">结论</h1><p id="e410" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">现在我们已经了解到<code class="fe nn no np nq b">eventEmitter</code>在我们处理一系列事务时特别有用。我们可以跟上业务需求的任何变化，同时轻松地维护我们的代码。</p></div></div>    
</body>
</html>