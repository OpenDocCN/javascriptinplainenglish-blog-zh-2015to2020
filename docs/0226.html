<html>
<head>
<title>Adding JavaScript features to a Rails web Application</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">向Rails web应用程序添加JavaScript特性</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/adding-javascript-features-to-a-rails-web-application-14fb281a1ba1?source=collection_archive---------0-----------------------#2019-08-28">https://javascript.plainenglish.io/adding-javascript-features-to-a-rails-web-application-14fb281a1ba1?source=collection_archive---------0-----------------------#2019-08-28</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="d53a" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">在我为Flatiron School进行的第四个项目中，我的任务是向我为第三个项目构建的Ruby on Rails应用程序添加JavaScript动态特性。</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/f07906a6287c5122507f759958e659f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*Cl0aMF4lpEyadGVP.jpeg"/></div></div></figure><p id="e884" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要求如下所列。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="345f" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">不要在此应用程序中使用“远程:真”</h2><p id="3a51" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">这让我有点不安，因为我不知道'<strong class="kq io"> remote: true' </strong>做了什么。一个非常快速的谷歌搜索帮助了我，我找到了<a class="ae mp" href="https://medium.com/@AdamKing0126/ajax-and-rails-demystifying-remote-true-fe51ba2ce819" rel="noopener">这篇文章</a>，它相当清楚地解释了它是如何工作的。这基本上是一个非常酷的Rails <em class="mq"> automagic </em>,它:</p><ul class=""><li id="6910" class="mr ms in kq b kr ks ku kv kx mt lb mu lf mv lj mw mx my mz bi translated">防止默认动作，<em class="mq">即</em>提交表单或以<em class="mq">老式的</em>方式跟随链接。</li><li id="ac3e" class="mr ms in kq b kr na ku nb kx nc lb nd lf ne lj mw mx my mz bi translated">发送一个JavaScript视图文件，而不是执行一段在Rails资产管道中编译的JavaScript代码。执行视图文件并执行AJAX调用。</li><li id="99e8" class="mr ms in kq b kr na ku nb kx nc lb nd lf ne lj mw mx my mz bi translated">控制器动作完成时会发送第二个视图文件，更新浏览器中的页面，无需重新加载。</li></ul><p id="9562" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">所有这些都可以通过使用'<strong class="kq io"> remote: true </strong>'而不是编写完整的AJAX调用来轻松完成。以下示例来自主体上的<a class="ae mp" href="https://guides.rubyonrails.org/working_with_javascript_in_rails.html" rel="noopener ugc nofollow" target="_blank">导轨</a>:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="576f" class="lr ls in ng b gy nk nl l nm nn">&lt;%=<!-- --> <!-- -->link_to <em class="mq">"an article"</em>, <strong class="ng io">@article</strong>, remote: true<!-- --> <!-- -->%&gt;</span></pre><p id="89b0" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">因此，这不是用于这个特定的项目，但我期待着尝试它，因为，让我们诚实地说，它似乎真的很酷。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="012b" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">使用类或构造函数语法将来自Rails应用程序的JSON响应转换成JavaScript模型对象</h2><p id="abb0" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">到目前为止，在Ruby中，我们一直使用对象来帮助我们表示现实。这叫做面向对象。它关注两件事:<strong class="kq io">数据</strong>存储为对象<strong class="kq io">属性</strong>，以及<strong class="kq io">动作</strong>存储为对象<strong class="kq io">方法</strong>。</p><p id="7d0c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我们来想一个<em class="mq">自行车</em>物体。在一个处理自行车的应用程序中，你会期望有不止一个<em class="mq">自行车</em>对象。我们可以<strong class="kq io">硬编码</strong>每个对象:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="f97f" class="lr ls in ng b gy nk nl l nm nn"><strong class="ng io">const</strong> b1 = { <strong class="ng io">bicycleType</strong>: "Trekking", <strong class="ng io">size</strong>: "M", <strong class="ng io">colour</strong>: "Green" };</span><span id="de85" class="lr ls in ng b gy no nl l nm nn"><strong class="ng io">const</strong> b2 = { <strong class="ng io">bicycleType</strong>: "Road", <strong class="ng io">size</strong>: "L", <strong class="ng io">colour</strong>: "Red" };</span><span id="f811" class="lr ls in ng b gy no nl l nm nn"><strong class="ng io">const</strong> b3 = { <strong class="ng io">bicycleType</strong>: "Dutch", <strong class="ng io">size</strong>: "S", <strong class="ng io">colour</strong>: "Blue" };</span><span id="be72" class="lr ls in ng b gy no nl l nm nn"><strong class="ng io">const</strong> b4 = { <strong class="ng io">bicycleType</strong>: "Folding", <strong class="ng io">size</strong>: "M", <strong class="ng io">colour</strong>: "Yellow" };</span></pre><p id="1777" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">真好。不过，这就是我们自己干的原则。由于每个<em class="mq">自行车</em>对象看起来具有相同的属性，我们需要的是一个<strong class="kq io">模板</strong>。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="c970" class="lr ls in ng b gy nk nl l nm nn"><strong class="ng io">function</strong> Bicycle(bicycleType, size, colour) {<br/>   <strong class="ng io">this</strong>.bicycleType = bicycleType;<br/>   <strong class="ng io">this</strong>.size = size;<br/>   <strong class="ng io">this</strong>.colour = colour;<br/>};</span><span id="1d42" class="lr ls in ng b gy no nl l nm nn"><strong class="ng io">const</strong> b5 = <strong class="ng io">new</strong> Bicycle("Mountain", "L", "Burgundy");</span></pre><p id="32a6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated"><em class="mq">自行车</em>函数是<strong class="kq io">构造器</strong>函数的一个例子。每当一个对象被<strong class="kq io">实例化</strong>时，它就会被调用，使用<em class="mq"> this </em>关键字创建对象的属性，并为每个属性分配作为参数传入的值。</p><p id="610d" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">现在，如果我们想拥有一个所有实例化对象都拥有的函数，我们可以这样做:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="cd06" class="lr ls in ng b gy nk nl l nm nn"><strong class="ng io">function</strong> Bicycle(bicycleType, size, colour) {<br/>   <strong class="ng io">this</strong>.bicycleType = bicycleType;<br/>   <strong class="ng io">this</strong>.size = size;<br/>   <strong class="ng io">this</strong>.colour = colour;<br/>   <strong class="ng io">this</strong>.displayFeatures = <strong class="ng io">function</strong>() {<br/>      console.log(`${<strong class="ng io">this</strong>.colour} ${<strong class="ng io">this</strong>.bicycleType} bicycle<br/>      available in size ${<strong class="ng io">this</strong>.size}`);<br/>   };<br/>};</span></pre><p id="5568" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这太棒了！因为我们可以在创建的任何<em class="mq">自行车</em>对象上调用那个<em class="mq"> displayFeatures() </em>方法。只有一个问题。使用该语法，每次实例化一个对象时，都会为该特定对象创建一个新的<em class="mq"> displayFeatures() </em>方法，并将其存储在<strong class="kq io">内存</strong>中。因此，如果我们创建263个自行车对象，我们也可以在内存中存储263个相同的<em class="mq"> displayFeatures() </em>方法。事实上，它们做同样的事情，但是声明它们的<em class="mq">这个</em>是不同的，因为它对应于<strong class="kq io">新实例化的对象</strong>。</p><p id="313c" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了避免这个问题，我们可以使用<strong class="kq io">原型</strong>。如果我们将<em class="mq"> displayFeatures() </em>方法的声明移到构造函数之外，那么我们将阻止它在每个对象实例化上的声明。但是，有必要让每个构造的对象访问该函数。这是通过访问自行车原型属性来完成的。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="8805" class="lr ls in ng b gy nk nl l nm nn"><strong class="ng io">function</strong> Bicycle(bicycleType, size, colour) {<br/>   <strong class="ng io">this</strong>.bicycleType = bicycleType;<br/>   <strong class="ng io">this</strong>.size = size;<br/>   <strong class="ng io">this</strong>.colour = colour;<br/>};</span><span id="445a" class="lr ls in ng b gy no nl l nm nn">Bicycle.prototype.displayFeatures = <strong class="ng io">function</strong>() {<br/>   console.log(`${<strong class="ng io">this</strong>.colour} ${<strong class="ng io">this</strong>.bicycleType} bicycle available<br/>   in size ${<strong class="ng io">this</strong>.size}`);<br/>};</span></pre><p id="59ad" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">原型只是一个可以存储特定属性的JavaScript对象。使用构造函数创建的每个新的<em class="mq">自行车</em>对象都引用了自行车函数的原型对象上定义的属性。这样，无论用构造函数创建多少个自行车对象，内存中只有一个<em class="mq"> displayFeatures() </em>方法，所有<em class="mq">自行车</em>对象都可以访问它。</p><p id="86ff" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于<strong class="kq io"> ES6 </strong>，语法中引入了<em class="mq">类</em>的概念。<em class="mq">类</em>函数创建一个<strong class="kq io">模板</strong>来帮助我们在未来的某个时刻创建对象。<em class="mq">构造器</em>方法本质上与我们上面创建的<em class="mq">自行车</em>函数做同样的事情。<em class="mq">类方法</em>可以用同样的方式构建。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="9f07" class="lr ls in ng b gy nk nl l nm nn"><strong class="ng io">class</strong> Bicycle {<br/>   constructor(bicycleType, size, colour) {<br/>      <strong class="ng io">this</strong>.bicycleType = bicycleType;<br/>      <strong class="ng io">this</strong>.size = size;<br/>      <strong class="ng io">this</strong>.colour = colour;<br/>   };</span><span id="98da" class="lr ls in ng b gy no nl l nm nn">   addOwner(name) {<br/>      <strong class="ng io">this</strong>.owner = name;<br/>   };<br/>};</span><span id="47ee" class="lr ls in ng b gy no nl l nm nn"><strong class="ng io">const</strong> b6 = <strong class="ng io">new</strong> Bicycle("Single Speed", "S", "Orange");</span><span id="1757" class="lr ls in ng b gy no nl l nm nn">b6.addOwner("Anne-Laure");</span></pre><p id="6129" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">对于这个特定的任务，使用构造函数语法或类语法没有区别。注意，类语法的引入并不意味着JavaScript语言的本质:它仍然是一种基于原型的语言，而不是像Ruby一样的基于类的语言。</p><p id="79fc" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我选择使用<strong class="kq io">构造函数</strong>语法来构建<em class="mq">城市</em>和<em class="mq">自行车</em>函数:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="fae9" class="lr ls in ng b gy nk nl l nm nn"><strong class="ng io">function</strong> City(object) {<br/>  <strong class="ng io">this</strong>.id = object.id;<br/>  <strong class="ng io">this</strong>.name = object.name;<br/>  <strong class="ng io">this</strong>.country = object.country;<br/>};</span><span id="9e3e" class="lr ls in ng b gy no nl l nm nn"><strong class="ng io">function</strong> Bicycle(object) {<br/>  <strong class="ng io">this</strong>.id = object.id;<br/>  <strong class="ng io">this</strong>.bicycle_type = object.bicycle_type;<br/>  <strong class="ng io">this</strong>.size = object.size;<br/>  <strong class="ng io">this</strong>.colour = object.colour;<br/>  <strong class="ng io">this</strong>.title = object.title;<br/>  <strong class="ng io">this</strong>.description = object.description;<br/>  <strong class="ng io">this</strong>.price = object.price;<br/>  <strong class="ng io">this</strong>.neighborhood = object.neighborhood;<br/>  <strong class="ng io">this</strong>.owner = object.owner;<br/>  <strong class="ng io">this</strong>.country = object.country;<br/>  <strong class="ng io">this</strong>.city = object.city;<br/>}</span></pre><p id="cfa2" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用<em class="mq"> fetch() </em>和jQuery，我从后端API获得了JSON <strong class="kq io">响应</strong>。然后我创建了用使用JSON数据作为参数的<strong class="kq io">构造函数</strong>构建的<strong class="kq io"> JavaScript对象模型</strong>。</p><p id="db58" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">为了在用户的浏览器上显示我想要的东西，我需要能够格式化这些JavaScript对象模型。这就是<strong class="kq io">原型</strong>上的方法出现的地方。为此，我构建了格式化程序来帮助我在用户浏览器上只显示我需要的信息，用于我的<em class="mq">自行车</em>和<em class="mq">城市</em>索引和显示页面。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="e005" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">通过JavaScript和活动模型序列化JSON后端呈现至少一个索引页面</h2><p id="0bc8" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">首先，要做到这一点，我们需要一个后端API <strong class="kq io">端点</strong>。端点基本上是通信信道的一端。在我们的例子中，API端点是在<strong class="kq io">控制器动作</strong>中创建的，在那里我们需要获取JSON数据而不是HTML。事实上，在这种情况下，我们不需要HTML带来的<strong class="kq io">格式</strong>。下面是<em class="mq">城市</em>控制器的指标动作:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="9def" class="lr ls in ng b gy nk nl l nm nn"><strong class="ng io">def</strong> index<br/>   @cities = <strong class="ng io">City</strong>.all<br/>   @countries = Country.alphabetically<br/>   respond_to <strong class="ng io">do</strong> |f|<br/>      f.html<br/>      f.json { render json: @cities}<br/>   <strong class="ng io">end</strong><br/><strong class="ng io">end</strong></span></pre><p id="89f9" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这样，我们可以选择让<strong class="kq io">呈现</strong>相应的<strong class="kq io">视图文件</strong>中存在的常规HTML，或者呈现<strong class="kq io"> JSON </strong>中只包含没有任何格式的数据。在某些情况下，我们可能只需要获取包含在<em class="mq"> @cities </em>变量中的部分数据，并且能够从活动记录关系的灵活性中获益。这就是<strong class="kq io">序列化器</strong>的用武之地。它们允许我们根据需要构造返回的数据。</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="b5de" class="lr ls in ng b gy nk nl l nm nn"><strong class="ng io">class</strong> CitySerializer &lt; ActiveModel::Serializer<br/>   attributes :id, :name</span><span id="470b" class="lr ls in ng b gy no nl l nm nn">   belongs_to :country<br/>   has_many :neighborhoods<br/>   has_many :bicycles<br/>   has_many :bicycles, through: :neighborhoods<br/><strong class="ng io">end</strong></span></pre><p id="1915" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">如果我们查看城市表的<em class="mq">模式</em>，我们会发现每行不仅仅只有一个<em class="mq"> id </em>和一个<em class="mq">名称</em>。但是在我们的例子中，我们只想要<em class="mq"> id </em>和<em class="mq">名称</em>。为此，我们仅将<em class="mq"> id </em>和<em class="mq">名称</em>列为<strong class="kq io">属性</strong>。其次，为了能够访问城市所属国家的数据，我们需要指定模型之间存在的<strong class="kq io">关系</strong>，就像我们在<em class="mq">模型</em>文件中指定它们一样。</p><p id="da04" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">最后，一旦我们准备好了序列化程序和后端API端点，我们就可以使用<strong class="kq io"> JavaScript </strong>来呈现作为响应得到的数据。我将JavaScript代码分成了三个文件:</p><ul class=""><li id="967c" class="mr ms in kq b kr ks ku kv kx mt lb mu lf mv lj mw mx my mz bi translated"><strong class="kq io"> <em class="mq"> main.js </em> </strong>文件:我在其中编写了将被所有其他文件使用的通用JavaScript</li><li id="f096" class="mr ms in kq b kr na ku nb kx nc lb nd lf ne lj mw mx my mz bi translated"><strong class="kq io"> <em class="mq"> bicycle.js </em> </strong>文件:项目中与<em class="mq">自行车</em>对象相关的所有函数都在这里</li><li id="88d3" class="mr ms in kq b kr na ku nb kx nc lb nd lf ne lj mw mx my mz bi translated"><strong class="kq io"> <em class="mq"> city.js </em> </strong>文件:存放所有与<em class="mq">城市</em>对象相关的函数。</li></ul><p id="873e" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">我在这个项目中创建了两个JavaScript渲染的索引。第一个事件发生在单击显示所有城市的按钮时。该按钮调用<em class="mq"> allCitiesClick() </em>函数，该函数调用<em class="mq"> getCities() </em>函数。通过使用<em class="mq"> fetch() </em>和创建的JavaScript对象模型，我设法显示了应用程序<strong class="kq io">中存在的所有城市的列表，而无需重新加载页面</strong>。第二个允许我在城市的显示页面上显示特定城市的所有自行车。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="1dbf" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">通过JavaScript和活动模型序列化JSON后端呈现至少一个显示页面</h2><p id="ae60" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">与我在没有重新加载页面的情况下显示的索引非常相似，通过使用JavaScript，我做了同样的事情来显示关于每个列出的城市的所有信息。对于每个城市，它的名称是一个链接，加载并显示关于这个城市的详细信息，而不需要完全重新加载页面。</p><p id="ebe5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这是通过创建一个名为<em class="mq"> cityClick() </em>的函数来完成的。这个函数使用<em class="mq"> fetch() </em>来获取所需的数据，然后<strong class="kq io">将收到的响应转换为</strong>JSON。然后，通过<em class="mq"> getCity() </em>函数，我能够使用JSON创建JavaScript对象模型，并使用我在开始时构建的<strong class="kq io">构造函数</strong>在原型上显示用<strong class="kq io">格式化程序</strong>函数格式化的适当信息，这在第一节中已经解释过了。最后，使用<em class="mq"> getCityBicycles() </em>函数和在<em class="mq"> City </em>序列化程序中声明的<strong class="kq io">关系</strong>，我可以显示城市中列出的自行车列表。</p></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="21f5" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">使用JavaScript通过JSON在页面上动态呈现至少一个序列化的'<em class="np"> has_many </em>'关系</h2><p id="7fc7" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">如上所述，在用JavaScript显示的城市展示页面中，有一个在城市中列出的自行车的<strong class="kq io">列表</strong>。在<em class="mq">城市</em>序列化器中，我列出了<em class="mq">城市</em>模型和其他模型之间的<strong class="kq io">关系</strong>。在应用中，一个<em class="mq">城市</em> <strong class="kq io">有很多</strong> <em class="mq">自行车</em>。这意味着在我们从<em class="mq"> fetch() </em>得到的<strong class="kq io">响应</strong>中，有一个<strong class="kq io">列表</strong>是属于这个城市的自行车。</p><p id="69b6" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用我在单击城市名称时收集的数据和序列化程序中列出的关系，接收到的<strong class="kq io">响应</strong>转换成JSON，给出了我正在寻找的列表。然后我只需要<strong class="kq io">遍历列表</strong>，用<strong class="kq io">构造器</strong>为每个<em class="mq">自行车</em>项目创建一个新的JavaScript模型对象，并在自行车<strong class="kq io">原型</strong>上用<strong class="kq io">格式化器</strong>方法以适合我的方式格式化它。</p><p id="6342" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">这个任务的关键是通过查询另一个模型(这里是<em class="mq">城市</em>)而不是<em class="mq">自行车</em>模型本身来获取事物的索引(这里是自行车)。我通过查询<em class="mq">城市</em>展览网址获得了自行车列表:</p><pre class="kd ke kf kg gt nf ng nh ni aw nj bi"><span id="2669" class="lr ls in ng b gy nk nl l nm nn">fetch(`/cities/${id}.json`)<br/>   .then(response =&gt; response.json()) </span></pre></div><div class="ab cl lk ll hr lm" role="separator"><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp lq"/><span class="ln bw bk lo lp"/></div><div class="ig ih ii ij ik"><h2 id="fa1d" class="lr ls in bd lt lu lv dn lw lx ly dp lz kx ma mb mc lb md me mf lf mg mh mi mj bi translated">呈现一个表单，用于创建一个通过JavaScript和JSON动态提交并显示的资源，无需重新加载页面</h2><p id="c8bb" class="pw-post-body-paragraph ko kp in kq b kr mk jo kt ku ml jr kw kx mm kz la lb mn ld le lf mo lh li lj ig bi translated">对于这个任务，我们需要使用JavaScript动态提交和显示新创建的资源。在这个应用程序中，主要表单用于列出一辆新自行车。所以我很自然地选择了这个来完成任务。</p><p id="75b5" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">要做的第一件事是确保在提交正确填写的表单时，防止了<strong class="kq io">默认行为</strong>。这可以通过使用<em class="mq"> preventDefault() </em>内置的JavaScript方法轻松完成。然后，我们需要轻松地操作表单中包含的数据。为此，我们使用了内置的<em class="mq"> serialize() </em>方法。该方法接收可执行代码，将其转换成可以在任何地方使用的字符串，然后将其重新构建成可用的代码。</p><p id="a1d8" class="pw-post-body-paragraph ko kp in kq b kr ks jo kt ku kv jr kw kx ky kz la lb lc ld le lf lg lh li lj ig bi translated">使用由<em class="mq"> serialize() </em>方法返回的值和当前用户的id，我们能够使用<strong class="kq io"> jQuery </strong> <em class="mq"> post </em>方法创建一个新的对象，该对象在应用程序的数据库中被<strong class="kq io">持久化</strong>。然后，有了可用的数据，这个过程与其他任务的过程非常相似。使用<strong class="kq io">构造器</strong>函数创建一个新的JavaScript对象，并使用原型上的<strong class="kq io">格式化器</strong>函数进行格式化。</p></div></div>    
</body>
</html>