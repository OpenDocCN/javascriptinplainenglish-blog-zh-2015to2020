<html>
<head>
<title>Functions in JavaScript Have More Secrets Than You Think</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的函数比你想象的有更多的秘密</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/function-in-javascript-has-much-more-secrets-than-you-think-b3bf64055c99?source=collection_archive---------0-----------------------#2020-09-05">https://javascript.plainenglish.io/function-in-javascript-has-much-more-secrets-than-you-think-b3bf64055c99?source=collection_archive---------0-----------------------#2020-09-05</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="794f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">高级JavaScript程序员必须知道的事情。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/596cae287041ca546beff51f176af7b3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9flb0rn0PvVk8f88"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@lucabravo?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Luca Bravo</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="501d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数是每个程序员都熟悉的语法。在JavaScript中，函数的地位非常高，通常被称为一等公民。但是你真的擅长使用函数吗？</p><p id="7dcc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里我将介绍一些使用函数的高级技巧，希望对你有所帮助。本文包括以下几个部分:</p><ul class=""><li id="af60" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">纯函数</li><li id="5f6d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">高阶函数</li><li id="fd58" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">函数缓存</li><li id="09e9" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">惰性函数</li><li id="daf4" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">Currying</li><li id="debc" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">函数合成</li></ul><h1 id="2f8b" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">纯函数</h1><h2 id="de68" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">什么是纯函数？</h2><p id="506a" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">满足以下两个条件的函数称为纯函数:</p><ul class=""><li id="768a" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">如果给出相同的参数，它总是返回相同的结果。</li><li id="bcfd" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">在函数的执行过程中没有副作用发生</li></ul><p id="c2d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例1:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="49c3" class="my mh iq nq b gy nu nv l nw nx">function circleArea(radius){<br/>  return radius * radius * 3.14<br/>}</span></pre><p id="6731" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当半径值相同时，函数总是返回相同的结果。而且函数的执行对函数外部没有影响，所以这是一个纯函数。</p><p id="eeaf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例2:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="04a6" class="my mh iq nq b gy nu nv l nw nx">let counter = (function(){<br/>  let initValue = 0<br/>  return function(){<br/>    initValue++;<br/>    return initValue<br/>  }<br/>})()</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ny"><img src="../Images/948076fafc272565dc759ec1aeb1d713.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-ao0govuJNMZH1Pg_vAu8g.png"/></div></div></figure><p id="3323" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个计数器函数每次运行的方式都会不一样，所以这不是一个纯函数。</p><p id="a1e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">示例3:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="6b66" class="my mh iq nq b gy nu nv l nw nx">let femaleCounter = 0;<br/>let maleCounter = 0;</span><span id="5ce1" class="my mh iq nq b gy nz nv l nw nx">function isMale(user){<br/>  if(user.sex = 'man'){<br/>    maleCounter++;<br/>    return true<br/>  }<br/>  return false<br/>}</span></pre><p id="8d14" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在上面的例子中，函数<code class="fe oa ob oc nq b">isMale</code>，给定相同的参数，总是有相同的结果，但是它有副作用。副作用是改变了全局变量<code class="fe oa ob oc nq b">maleCounter</code>的值，所以不纯。</p><h2 id="0562" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">纯函数有什么用？</h2><p id="2343" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">我们为什么要区分纯函数和其他函数？因为纯函数有很多优点，所以我们可以在编程过程中使用纯函数来提高我们代码的质量。</p><ol class=""><li id="0b7b" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr od ly lz ma bi translated">纯函数更加清晰易读</li></ol><p id="b25d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个纯函数总是完成一个特定的任务，并有一个确切的结果。这将大大提高代码的可读性，使编写文档变得更加容易。</p><p id="e568" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.编译器可以对纯函数进行更多的优化</p><p id="0ec2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我有这样一段代码:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="321a" class="my mh iq nq b gy nu nv l nw nx">for (int i = 0; i &lt; 1000; i++){<br/>    console.log(fun(10));<br/>}</span></pre><p id="04c7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe oa ob oc nq b">fun</code>不是一个纯粹的函数，那么在这段代码运行时<code class="fe oa ob oc nq b">fun(10)</code>需要被执行1000次。</p><p id="9da2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果<code class="fe oa ob oc nq b">fun</code>是一个纯函数，编辑器将能够在编译时优化代码。优化后的代码可能如下所示:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="f005" class="my mh iq nq b gy nu nv l nw nx">let result = fun(10)<br/>for (int i = 0; i &lt; 1000; i++){<br/>    console.log(result);<br/>}</span></pre><p id="2a10" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.纯函数更容易测试</p><p id="c2bd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">纯函数的测试不需要依赖于上下文。当我们为纯函数编写单元测试时，我们简单地给出一个输入值，并断言函数的输出满足我们的要求。</p><p id="a134" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一个简单的例子:一个纯函数将一个数字数组作为参数，并将数组中的每个元素递增1。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="a203" class="my mh iq nq b gy nu nv l nw nx">const incrementNumbers = function(numbers){<br/>  // ...<br/>}</span></pre><p id="832a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们只需要为它编写这样的单元测试:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="5d71" class="my mh iq nq b gy nu nv l nw nx">let list = [1, 2, 3, 4, 5];</span><span id="7937" class="my mh iq nq b gy nz nv l nw nx">assert.equals(incrementNumbers(list), [2, 3, 4, 5, 6])</span></pre><p id="69fc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果不是一个纯函数，我们有很多外部因素要考虑，这不是一个简单的任务。</p><h1 id="a68e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">高阶函数</h1><p id="2ddc" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">什么是高阶函数？</p><p id="f822" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">高阶函数是至少执行下列操作之一的函数:</p><ul class=""><li id="0809" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">接受一个或多个函数作为参数</li><li id="d77e" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">返回一个函数作为结果。</li></ul><p id="31ea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用高阶函数可以增加我们代码的灵活性，让我们能够写出更简洁高效的代码。</p><p id="cf75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">假设我们现在有一个整数数组，我们想创建一个新的数组。新数组的元素长度与原数组相同，对应元素的值是原数组值的两倍。</p><p id="8e75" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果不使用高阶函数，我们可以这样写:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="fdcb" class="my mh iq nq b gy nu nv l nw nx">const arr1 = [1, 2, 3];<br/>const arr2 = [];</span><span id="2fe7" class="my mh iq nq b gy nz nv l nw nx">for (let i = 0; i &lt; arr1.length; i++) {<br/>    arr2.push(arr1[i] * 2);<br/>}</span></pre><p id="1e9e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在JavaScript中，数组对象有一个<code class="fe oa ob oc nq b">map()</code>方法。</p><blockquote class="oe of og"><p id="7f58" class="kw kx oh ky b kz la jr lb lc ld ju le oi lg lh li oj lk ll lm ok lo lp lq lr ij bi translated"><code class="fe oa ob oc nq b"><strong class="ky ir">map(callback)</strong></code>方法创建一个新的数组，其中填充了<strong class="ky ir">对调用数组中的每个元素调用一个提供的函数</strong>的结果。</p></blockquote><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="f201" class="my mh iq nq b gy nu nv l nw nx">const arr1 = [1, 2, 3];<br/>const arr2 = arr1.map(function(item) {<br/>  return item * 2;<br/>});<br/>console.log(arr2);</span></pre><p id="e57d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe oa ob oc nq b">map</code>函数是一个高阶函数。</p><p id="2191" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">正确使用高阶函数可以提高我们代码的质量。接下来的部分都是关于高阶函数的，所以让我们继续。</p><h1 id="eb4a" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">函数缓存</h1><p id="1424" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">假设我们有一个像这样的纯函数:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/f3f6fcc9efade75449a5219d538e56c1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*I6_ntKBi7pBS03jbyexzMg.png"/></div></div></figure><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="e0e1" class="my mh iq nq b gy nu nv l nw nx">function computed(str) {    <br/>    // Suppose the calculation in the funtion is very time consuming        <br/>    console.log('2000s have passed')<br/>      <br/>    // Suppose it is the result of the function<br/>    return 'a result'<br/>}</span></pre><p id="bd8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为了提高程序的速度，我们想缓存函数运算的结果。以后调用时，如果参数相同，就不再执行该函数，而是直接返回缓存中的结果。我们能做什么？</p><p id="cec9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以写一个<code class="fe oa ob oc nq b">cached</code>函数来包装我们的目标函数。这个缓存函数将目标函数作为参数，并返回一个新的包装函数。在<code class="fe oa ob oc nq b">cached</code>函数中，我们可以用<code class="fe oa ob oc nq b">Object</code>或<code class="fe oa ob oc nq b">Map</code>缓存前一次函数调用的结果。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><p id="f9cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里有一个例子:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi oo"><img src="../Images/d87fe9ec1036e46adf620e0615b1d885.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*iLTBkgsiO05dd_XZ.png"/></div></div></figure><h1 id="833e" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">惰性函数</h1><p id="2372" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">函数体通常包含一些条件语句。有时这些语句只需要执行一次。</p><p id="a3de" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以通过在第一次执行后“删除”这些语句来提高函数的性能，这样函数就不需要在后续执行中执行这些语句。那就是懒功能。</p><p id="b66b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">例如，我们现在需要编写一个名为<code class="fe oa ob oc nq b">foo</code>的函数，它总是从<code class="fe oa ob oc nq b">first call</code>返回日期对象，注意“第一次调用”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi op"><img src="../Images/d68571a54595874b45d79446ce72bb65.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*EO_O90uQVGtGVVLWK7B6AQ.png"/></div></div></figure><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="4220" class="my mh iq nq b gy nu nv l nw nx">let fooFirstExecutedDate = null;<br/>function foo() {<br/>    if ( fooFirstExecutedDate != null) {<br/>      return fooFirstExecutedDate;<br/>    } else {<br/>      fooFirstExecutedDate = new Date()<br/>      return fooFirstExecutedDate;<br/>    }<br/>}</span></pre><p id="06b8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每次运行上述函数时，都需要执行判断语句。如果这个判断条件非常复杂，那么就会导致我们程序的性能下降。此时，我们可以使用惰性函数的技术来优化这段代码。</p><p id="64cd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以编写这样的代码:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/c2c35fe9a1ff6c464be6c25124d6d24a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*YJLZSc5r7SCKzsYH1Qnr_A.png"/></div></figure><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="9cec" class="my mh iq nq b gy nu nv l nw nx">var foo = function() {<br/>    var t = new Date();<br/>    foo = function() {<br/>        return t;<br/>    };<br/>    return foo();<br/>}</span></pre><p id="2319" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在第一次执行之后，我们用新函数覆盖原来的函数。以后执行该功能时，将不再执行判决语句。这将提高我们代码的性能。</p><p id="af8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么我们来看一个更实际的例子。</p><p id="bad3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当我们向元素中添加DOM事件时，为了兼容现代浏览器和IE浏览器，我们需要对浏览器环境做出判断:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="8c18" class="my mh iq nq b gy nu nv l nw nx">function addEvent (type, el, fn) {<br/>    if (window.addEventListener) {<br/>        el.addEventListener(type, fn, false);<br/>    }<br/>    else if(window.attachEvent){<br/>        el.attachEvent('on' + type, fn);<br/>    }<br/>}</span></pre><p id="05d6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们每次调用<code class="fe oa ob oc nq b">addEvent</code>函数，都要做一个判断。使用惰性函数，我们可以做到这一点:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/9bb70032438f10b3413d74b93849c0ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*808umxoPzfPqK_L7emvSng.png"/></div></div></figure><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="6b4d" class="my mh iq nq b gy nu nv l nw nx">function addEvent (type, el, fn) {<br/>  if (window.addEventListener) {<br/>      addEvent = function (type, el, fn) {<br/>          el.addEventListener(type, fn, false);<br/>      }<br/>  } else if(window.attachEvent){<br/>      addEvent = function (type, el, fn) {<br/>          el.attachEvent('on' + type, fn);<br/>      }<br/>  }<br/>  addEvent(type, el, fn)<br/>}</span></pre><p id="50da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">综上所述，如果一个函数内部有一个条件判断只需要执行一次，那么我们可以用懒人函数来优化它。特别是在第一次判断后，用新函数覆盖原函数，新函数去掉条件判断。</p><h1 id="10ca" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">函数Currying</h1><p id="8a89" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">Currying是一种将带有多个参数<em class="oh">的函数求值成带有单个参数的函数序列的技术。</em></p><p id="f89d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">换句话说，当一个函数不是一次接受所有参数，而是接受第一个参数并返回一个接受第二个参数的新函数，然后返回一个接受第三个参数的新函数，以此类推，直到满足所有参数。</p><p id="ad32" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这就是我们把一个函数调用<code class="fe oa ob oc nq b">add(1,2,3)</code>变成<code class="fe oa ob oc nq b">add(1)(2)(3)</code>的时候。通过使用这种技术，可以轻松地配置和重用这个小部分。</p><p id="b75d" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为什么有用？</p><ul class=""><li id="ac33" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">Currying帮助你避免一次又一次地传递同一个变量。</li><li id="4c6d" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">它有助于创建高阶函数。这对事件处理非常有帮助。</li><li id="7395" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">小部分可以轻松配置和重用。</li></ul><p id="15e2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们来看一个简单的<code class="fe oa ob oc nq b">add</code>函数。它接受三个操作数作为参数，并返回三者之和作为结果。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="c026" class="my mh iq nq b gy nu nv l nw nx">function add(a,b,c){<br/> return a + b + c;<br/>}</span></pre><p id="b148" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">你可以用太少(结果奇怪)或太多(多余的参数被忽略)来调用它。</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="ccab" class="my mh iq nq b gy nu nv l nw nx">add(1,2,3) --&gt; 6 <br/>add(1,2) --&gt; NaN<br/>add(1,2,3,4) --&gt; 6 //Extra parameters will be ignored.</span></pre><p id="2871" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如何将现有函数转换为curried版本？</p><h2 id="26b3" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">代码:</h2><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="om on l"/></div></figure><h2 id="620d" class="my mh iq bd mi mz na dn mm nb nc dp mq lf nd ne ms lj nf ng mu ln nh ni mw nj bi translated">示例:</h2><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi os"><img src="../Images/c907dbacadfc0f12fda4aea397f00595.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xWlaYdGM43c5UtE-2sDbLw.png"/></div></div></figure><h1 id="d3c0" class="mg mh iq bd mi mj mk ml mm mn mo mp mq jw mr jx ms jz mt ka mu kc mv kd mw mx bi translated">函数合成</h1><p id="a40d" class="pw-post-body-paragraph kw kx iq ky b kz nk jr lb lc nl ju le lf nm lh li lj nn ll lm ln no lp lq lr ij bi translated">假设我们现在需要编写一个这样的函数:</p><blockquote class="ot"><p id="bf39" class="ou ov iq bd ow ox oy oz pa pb pc lr dk translated">输入' bitfish '，返回'你好，BITFISH '。</p></blockquote><p id="1151" class="pw-post-body-paragraph kw kx iq ky b kz pd jr lb lc pe ju le lf pf lh li lj pg ll lm ln ph lp lq lr ij bi translated">正如您所看到的，这个函数有两个组件:</p><ul class=""><li id="2638" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">串联字符串</li><li id="7967" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">将字符串转换为大写</li></ul><p id="aa0b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我们可以这样写代码:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="f308" class="my mh iq nq b gy nu nv l nw nx">let toUpperCase = function(x) { return x.toUpperCase(); };<br/>let hello = function(x) { return 'HELLO, ' + x; };</span><span id="c961" class="my mh iq nq b gy nz nv l nw nx">let greet = function(x){<br/>    return hello(toUpperCase(x));<br/>};</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pi"><img src="../Images/f3719fd5fdfe8a2ff6d15b352aeec94d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jK2JpMEe_O4ZSdC1c75y8g.png"/></div></div></figure><p id="a340" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这个例子中只有两个步骤，所以greet函数看起来并不复杂。如果有更多的操作，greet函数将需要更多的嵌套，编写类似于<code class="fe oa ob oc nq b">fn3(fn2(fn1(fn0(x))))</code>的代码。</p><p id="ab19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">为此，我们可以编写一个专门用于组合函数的<code class="fe oa ob oc nq b">compose</code>函数:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="f1a5" class="my mh iq nq b gy nu nv l nw nx">let compose = function(f,g) {<br/>    return function(x) {<br/>        return f(g(x));<br/>    };<br/>};</span></pre><p id="1377" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此，通过<code class="fe oa ob oc nq b">compose</code>函数可以得到<code class="fe oa ob oc nq b">greet</code>函数:</p><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="4152" class="my mh iq nq b gy nu nv l nw nx">let greet = compose(hello, toUpperCase);<br/>greet('kevin');</span></pre><p id="a009" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe oa ob oc nq b">compose</code>函数将两个函数合并成一个函数，使得代码从右到左运行，而不是从里到外，从而使其可读性更好。</p><p id="45c2" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">但是现在<code class="fe oa ob oc nq b">compose</code>函数只能支持两个参数，我们真的希望函数可以接受任意数量的参数。</p><p id="e582" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">众所周知的开源项目<a class="ae kv" href="https://underscorejs.org/" rel="noopener ugc nofollow" target="_blank">下划线</a>就是这样实现composer函数的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi pj"><img src="../Images/925f0de05d9b48c8f15c74585b2a3634.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UW-P_I4wRqvbneYQh5ZrUw.png"/></div></div></figure><pre class="kg kh ki kj gt np nq nr ns aw nt bi"><span id="d40a" class="my mh iq nq b gy nu nv l nw nx">function compose() {<br/>    var args = arguments;<br/>    var start = args.length - 1;<br/>    return function() {<br/>        var i = start;<br/>        var result = args[start].apply(this, arguments);<br/>        while (i--) result = args[i].call(this, result);<br/>        return result;<br/>    };<br/>};</span></pre><p id="a913" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">通过函数组合，我们可以优化函数之间的逻辑关系，提高代码的可读性，并促进未来的扩展和重构。</p></div></div>    
</body>
</html>