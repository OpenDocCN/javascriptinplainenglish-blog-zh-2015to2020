<html>
<head>
<title>A Data Driven approach to forms with React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React表单的数据驱动方法</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/data-driven-approach-to-forms-with-react-c69fd4ea7923?source=collection_archive---------2-----------------------#2020-02-05">https://javascript.plainenglish.io/data-driven-approach-to-forms-with-react-c69fd4ea7923?source=collection_archive---------2-----------------------#2020-02-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/cc6ad9e5ab71777fabccf84e8f2f268e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*U4aFxcK-cNsKCuhLkY0MGA.jpeg"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Image by <a class="ae jz" href="https://pixabay.com/illustrations/analytics-information-innovation-3088958/" rel="noopener ugc nofollow" target="_blank">xresch</a></figcaption></figure><p id="b4e0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">毫无疑问，表单是用户和web服务器之间最基本的交互模式。从第一次登录到最后一次订单确认，所有这些操作仍然由一些HTML元素作为输入或按钮来处理。由于JavaScript的这种高度重要性和新兴力量，表单变得越来越复杂。异步验证和提交、动态元素、基于触摸的控件、支持不同本地化配置的复杂的多搜索下拉菜单以及许多更高级的功能正在缓慢但肯定地取代简单的静态HTML页面。</p><p id="87de" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是如何处理大型项目中这些无休止的变化呢？其中之一，<a class="ae jz" href="https://www.manageiq.org/" rel="noopener ugc nofollow" target="_blank"> ManageIQ </a>，一个管理云的开源工具，从2006年开始开发至今，包含了一百多个表单。所有这些都是不同的:大多数表单都是用Ruby on Rails提供动态特性的传统方式编写的，只有少数使用AngularJS。然而，由于技术仍在向前发展，ManageIQ决定改用<a class="ae jz" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> ReactJS </a>，团队必须想出一个解决方案，使未来的开发更容易、更易维护和测试。</p></div><div class="ab cl ky kz hr la" role="separator"><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld le"/><span class="lb bw bk lc ld"/></div><div class="ig ih ii ij ik"><p id="c3cb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，该团队研究了可以处理表单的React库。而且有很多:<a class="ae jz" href="https://github.com/jaredpalmer/formik" rel="noopener ugc nofollow" target="_blank"> Formik </a>，<a class="ae jz" href="https://redux-form.com/8.2.2/" rel="noopener ugc nofollow" target="_blank"> ReduxForm </a>，<a class="ae jz" href="https://final-form.org/" rel="noopener ugc nofollow" target="_blank"> Final Form </a>等等很多。问题得到了解决，并提供了所有需要的特性。这些库是先进的，它们提供了开发人员需要的一切。然而，开发人员仍然必须编写HTML标记(尽管它是以JSX的形式)，并且需要使用大量的JavaScript/React代码来实现所有这些功能。因此，实际上什么都没有解决，因为问题将在未来出现，当团队决定转向另一种技术(<em class="lf">也许是苗条？*wink* </em>)</p><p id="a839" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有许多关于如何处理它的讨论，但最终，数据驱动的方法被选为解决方案。它实际上意味着什么？因为您已经阅读了标题，所以您可能有一些想法，但本质上它意味着不用编写HTML标记和JavaScript代码，而是编写简单的数据，不依赖于所使用的技术。我们也可以称之为编写表单的声明式方法。与声明性范例一样，程序员不需要指定如何构建表单，只需要指定用户应该看到什么以及它应该如何表现。其他的都是靠魔法完成的。(不是真的靠魔法，而是靠大量代码……别担心，我们会实现的。)</p><p id="841d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">听起来很简单？真的是。我给你举个例子。假设我们需要构建一个简单的登录页面，包含登录名和密码。(目前，我们选择哪个库并不重要。)首先我们要用一种标准的方式来写:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="4f77" class="lp lq in ll b gy lr ls l lt lu">&lt;form onSubmit={onSubmit}&gt;<br/>  &lt;input type="text" name="login"&gt;Your login name&lt;/input&gt;<br/>  &lt;input type="password" name="password"&gt;Password&lt;/input&gt;<br/>  &lt;button type="submit"&gt;Your login&lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="0462" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">还是简单吧？现在依然如此。然而，当用户在没有输入任何信息的情况下点击按钮时，他们希望看到哪些输入是必需的。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="41e2" class="lp lq in ll b gy lr ls l lt lu">&lt;form onSubmit={onSubmit}&gt;<br/>  &lt;input type="text" name="login"&gt;Your login name&lt;/input&gt;<br/>  <strong class="ll io">{!login.meta.valid &amp;&amp; 'This field is required'}</strong><br/>  &lt;input type="password" name="password"&gt;Password&lt;/input&gt;  <br/>  <strong class="ll io">{!password.meta.valid &amp;&amp; 'This field is required'}</strong><br/>  &lt;button type="submit"&gt;Your login&lt;/button&gt;<br/>&lt;/form&gt;</span></pre><p id="5ca9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太好了。所有的开发者和用户都很高兴……但是没有，UX团队决定显示一个带有警告三角形图标的模态组件，而不是简单的文本。让我们再次改变标记…开玩笑，我希望你已经得到了图片。在正常情况下，每一个变化，即使只是一个小的变化，随着大量代码的改变也会很痛苦。这是可管理的——在一个小项目中这完全没问题，但是在一个有数百个表单的项目中呢？不不可能。即使您最终使用了少量的可重用组件，这种方法也不能让您使用不同的技术，并且当您决定改变它时，所有的表单都必须从头开始构建。</p><p id="4f04" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看如何以React库中使用的格式处理这个表单，<a class="ae jz" href="https://data-driven-forms.org/" rel="noopener ugc nofollow" target="_blank">数据驱动表单</a>:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="94ce" class="lp lq in ll b gy lr ls l lt lu">const schema = {<br/>    fields: [{<br/>        component: 'text-field',<br/>        name: 'login',<br/>        label: 'Your login name'<br/>    }, {<br/>        component: 'text-field',<br/>        type: 'password',<br/>        name: 'password',<br/>        label: 'Password'<br/>    }]<br/>}</span></pre><p id="d5a2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我们将HTML数据转换成JSON时，我们只需将其属性复制到正确的键上。而且这些键大部分都是一样的。name属性变为name，type为type，label为label。组件是来自映射器的一个组件的名称(稍后将详细介绍)。)键很简单，不言自明。你不需要知道任何关于HTML或者React的东西，你仍然能够编写你自己的复杂表单…</p><p id="9452" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">…哦，不，我们忘记添加必要的警告了！让我们修理它。</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="3c1e" class="lp lq in ll b gy lr ls l lt lu">const schema = {<br/>    fields: [{<br/>        component: 'text-field',<br/>        name: 'login',<br/>        label: 'Your login name',<br/><strong class="ll io">        validate: [{<br/>            type: 'required-validator'<br/>        }]</strong><br/>    }, {<br/>        component: 'text-field',<br/>        type: 'password',<br/>        name: 'password',<br/>        label: 'Password',<br/><strong class="ll io">        validate: [{<br/>            type: 'required-validator'<br/>        }]</strong><br/>    }]<br/>}</span></pre><p id="8321" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">三角模态的东西呢？嗯，我们根本不需要改变表单中的任何内容。但是让我们等到实现的时候再说。现在还是来说说这种方式的优势，以及它给我们带来了什么。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi lv"><img src="../Images/d199f53b18ea18838762b69f2a4f86f3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*m3ptQF-vlwLK6h5HgBlObg.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">PatternFly 4 visualization of the form using the schema. You can test it yourself <a class="ae jz" href="https://data-driven-forms.org/live-editor" rel="noopener ugc nofollow" target="_blank">here</a>.</figcaption></figure><p id="c6ec" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">您已经看到，它编码简单，易于阅读，并且可以在CTRL-F和CTRL-V的帮助下毫不犹豫地进行更改。此外，顾名思义，您可以将这些数据保存在数据库中，这样web开发团队和那些开发最新iOS应用程序的酷哥们就可以共享这些数据，并在不同的编程语言和技术中使用它们。我们不需要再谈论可升级性了。无论您使用哪个版本的React，也无论您决定将数据保存在什么格式或什么位置，数据就是数据。</p><p id="efb9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">太棒了，不是吗？当然，也有一些仅仅在JSON中存储信息难以处理的缺陷。(但也不是不可能！)例如，对于每个提交动作，我们仍然使用单独的编码函数，因为每个提交动作是不同的。但是如果您的团队已经很好地设计了API，那么您也可以将API端点存储在模式中，并以通用的方式使用它。使用复杂的文本组件可能会导致另一个问题，因为不可能在数据库中用JSON存储React组件。然而，即使在这里，您仍然可以使用一些文本格式(如markdown ),然后将文本转换成您需要的组件。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div class="gh gi lw"><img src="../Images/3c0b4ab46da232ce50a48af5d93ee89e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1174/format:webp/1*qLL3IoIeY4K71EyIacBMCQ.png"/></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Data Driven Forms is a React library used to change your data into React forms.</figcaption></figure><h1 id="434d" class="lx lq in bd ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt bi translated">数据驱动表单</h1><p id="209e" class="pw-post-body-paragraph ka kb in kc b kd mu kf kg kh mv kj kk kl mw kn ko kp mx kr ks kt my kv kw kx ig bi translated">现在，是时候进入使用数据驱动方法的更具体的例子了。在上文中，我提到了我们的自定义开源库，<a class="ae jz" href="https://data-driven-forms.org/" rel="noopener ugc nofollow" target="_blank">数据驱动表单</a>。它是一个React模块，基本上可以处理标准web表单的所有特性。这在另一个提到的库的帮助下是可能的，<a class="ae jz" href="https://final-form.org/" rel="noopener ugc nofollow" target="_blank">最终形式</a>。最终表单完全处理表单状态、验证和所有重要的东西。如果您更感兴趣，请在另一个选项卡中打开它的文档页面并继续阅读！</p><p id="42b2" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">数据驱动表单由两个独立的组件组成:表单呈现器和映射器。表单渲染器全部由数据驱动表单提供，其职责是使用最终表单将数据解析到表单中，并提供所有功能，因此所有表单的行为都是相同的。映射器是一个不同的故事，你可以轻松地创建你自己的或者你可以使用数据驱动表单团队提供的三个映射器之一:<a class="ae jz" href="https://www.patternfly.org/v3/" rel="noopener ugc nofollow" target="_blank"> PatternFly 3 </a>、<a class="ae jz" href="https://www.patternfly.org/v4/" rel="noopener ugc nofollow" target="_blank"> PatternFly 4 </a>和<a class="ae jz" href="https://material-ui.com/" rel="noopener ugc nofollow" target="_blank"> Material-UI </a>。映射器顾名思义。它是一组将提供的功能(通过传递的属性)映射到React组件的组件。不多不少。每个映射器都包含了设计库中的组件，如您在名称中所见。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi mz"><img src="../Images/7222dc36b3bf5230359bc12ded26fe64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*iy8iK7aJWTV23tlgqP8EbQ.png"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Same data, different mapper (from the left: PatternFly 4, PatternFly 3, Material-UI)</figcaption></figure><p id="a84d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们回到前面的例子来提醒我们数据是什么样子的:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="2b7d" class="lp lq in ll b gy lr ls l lt lu">const <strong class="ll io">schema</strong> = {<br/>    fields: [{<br/>        component: 'text-field',<br/>        name: 'login',<br/>        label: 'Your login name',<br/>        validate: [{<br/>            type: 'required-validator'<br/>        }]<br/>    }, {<br/>        component: 'text-field',<br/>        type: 'password',<br/>        name: 'password',<br/>        label: 'Password',<br/>        validate: [{<br/>            type: 'required-validator'<br/>        }]<br/>    }]<br/>}</span></pre><p id="b21d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，让我们看看如何在数据驱动表单中使用该模式:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="9e5e" class="lp lq in ll b gy lr ls l lt lu">import React from 'react';<br/>import FormRenderer from '<a class="ae jz" href="http://twitter.com/data" rel="noopener ugc nofollow" target="_blank">@data</a>-driven-forms/react-form-renderer';<br/>import { <strong class="ll io">formFieldsMapper</strong>, <strong class="ll io">layoutMapper</strong> } from '<a class="ae jz" href="http://twitter.com/data" rel="noopener ugc nofollow" target="_blank">@data</a>-driven-forms/mui-component-mapper';</span><span id="964e" class="lp lq in ll b gy na ls l lt lu">const Form = () =&gt; (<br/>  &lt;FormRenderer<br/>    schema={schema}<br/>    formFieldsMapper={formFieldsMapper}<br/>    layoutMapper={layoutMapper}<br/>    <strong class="ll io">onSubmit</strong>={console.log}<br/>  /&gt;<br/>)</span></pre><p id="05bb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">那么，这里发生了什么？<a class="ae jz" href="https://www.npmjs.com/package/@data-driven-forms/react-form-renderer" rel="noopener ugc nofollow" target="_blank"> FormRenderer </a>是将你的数据转换成表单的组件。只有四个必需的<a class="ae jz" href="https://data-driven-forms.org/renderer/renderer-api#requiredprops" rel="noopener ugc nofollow" target="_blank">道具</a> : <strong class="kc io"> schema </strong>是具有特定格式的JSON数据，<strong class="kc io"> formFieldsMapper </strong>是一组创建表单元素并能够访问表单状态并更改表单状态的组件，<strong class="kc io"> layoutMapper </strong>是一组像表单包装器或按钮这样的几个特定组件，它们不能从数据中呈现在表单中，也不能更改表单。这两个映射器捆绑在一起。最后一个道具是一个<strong class="kc io"> onSubmit </strong>，它只是一个函数，在表单中按下Enter或Submit按钮后被调用。你可以使用更多的<a class="ae jz" href="https://data-driven-forms.org/renderer/renderer-api#optionalprops" rel="noopener ugc nofollow" target="_blank">道具</a>，这允许更多的定制(重置、取消……)</p><p id="b9a5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这再简单不过了。你写了一份可以立即使用的表格。仅此而已。故事结束。</p><p id="3c4a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">等等。你是不是已经写了很多有很多自定义组件的表单了？嗯，这是编写自定义映射器的最佳时机。下面，您可以看到一个只有一个组件的基本示例:</p><pre class="lg lh li lj gt lk ll lm ln aw lo bi"><span id="0e53" class="lp lq in ll b gy lr ls l lt lu">const TextField = ({ name, type = 'text', <strong class="ll io">meta</strong>, <strong class="ll io">input</strong>, label }) =&gt; {<br/>  <strong class="ll io">const { error, touched } = meta;</strong></span><span id="ffea" class="lp lq in ll b gy na ls l lt lu">return (&lt;div&gt;<br/>    &lt;label htmlFor={ name }&gt;{ label }&lt;/label&gt;<br/>    &lt;input type={ type } onChange={ input.onChange } value={ input.value }/&gt;<br/>    <strong class="ll io">{ touched &amp;&amp; error }</strong><br/>  &lt;/div&gt;);<br/>};</span><span id="3392" class="lp lq in ll b gy na ls l lt lu">formFieldsMapper = {<br/>  'text-field': TextField,<br/>};</span></pre><figure class="lg lh li lj gt jo"><div class="bz fp l di"><div class="nb nc l"/></div></figure><p id="e19d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们一起解开它。该组件只是您了解和喜爱的基本React组件。您会注意到它从模式中获取所有属性，比如名称、类型或标签。不过新增了两个道具:<a class="ae jz" href="https://data-driven-forms.org/renderer/field-provider#input" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io">输入</strong> </a>和<a class="ae jz" href="https://data-driven-forms.org/renderer/field-provider#meta" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> meta </strong> </a>。这些属性由表单渲染器提供，它们是映射器获得的最重要的属性:<strong class="kc io"> meta </strong>是一个对象，它包括关于字段的各种元数据:dirty、priest、modified等。而<strong class="kc io">输入</strong>是一个提供值和方法来改变表单状态的对象。如果您想知道validate属性去了哪里，答案很简单——验证完全由表单呈现器处理，组件不需要知道它。</p><figure class="lg lh li lj gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nd"><img src="../Images/cf3dd4906e76baca3351b0ac6d4a6d55.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*UVfSyKyohTAZ9iXsW7nk-A.gif"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">A wizard form created using the PatternFly 4 mapper. Different steps for each source type are defined in the JSON schema. It’s easy to add new steps, remove old ones or add a completely new wizard branch. All wizard features (jumping back, switching steps, …) are controlled by the mapper, so there is no need to implement anything in the form itself.</figcaption></figure><p id="db8a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">完成了。另一个故事的结尾。但实际上，它更复杂；有更多的<a class="ae jz" href="https://data-driven-forms.org/renderer/component-api" rel="noopener ugc nofollow" target="_blank">组件</a>要覆盖，更多的<a class="ae jz" href="https://github.com/data-driven-forms/react-forms" rel="noopener ugc nofollow" target="_blank">特性</a>要实现。本文是对数据驱动方法世界的介绍。我已经向您展示了它的主要优点以及使用数据构建表单是多么简单。与此同时，我对诸如<a class="ae jz" href="https://data-driven-forms.org/component-example/wizard?mapper=pf4" rel="noopener ugc nofollow" target="_blank">向导</a>表单、<a class="ae jz" href="https://data-driven-forms.org/renderer/validators#asyncvalidator" rel="noopener ugc nofollow" target="_blank">异步验证</a>、<a class="ae jz" href="https://final-form.org/docs/final-form/field-names" rel="noopener ugc nofollow" target="_blank">嵌套名称</a>等许多特性保密。如果你想发现这些，请查看GitHub上的<a class="ae jz" href="https://github.com/data-driven-forms/react-forms" rel="noopener ugc nofollow" target="_blank">我们的社区</a>或者访问我们的<a class="ae jz" href="https://data-driven-forms.org/" rel="noopener ugc nofollow" target="_blank">文档页面</a>，在那里你可以获得你需要开始的所有信息。</p><blockquote class="ne nf ng"><p id="b7cc" class="ka kb lf kc b kd ke kf kg kh ki kj kk nh km kn ko ni kq kr ks nj ku kv kw kx ig bi translated">我要特别感谢Dayle和Gregg，他们帮助我完成了这篇文章。谢谢大家！</p></blockquote><p id="6259" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">更新</strong></p><p id="d231" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">自从写了这篇文章后，<strong class="kc io">新版本的DDF (2.x)已经发布了</strong>，它改变了本文中提到的一些事情:</p><p id="7d87" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">-不再有<strong class="kc io">布局映射器</strong>，取而代之的是使用<strong class="kc io">表单模板</strong>(它允许更多地定制表单)<br/> -一些常量已被更改(<strong class="kc io">必需-验证器</strong>'改为'<strong class="kc io">必需</strong> ') <br/> -定制字段必须使用<strong class="kc io"> useFieldApi </strong>或<strong class="kc io"> FieldProvider </strong>与表单连接(文本字段没有自动连接)</p><p id="5be5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有v1到v2的升级指南:<br/><a class="ae jz" href="https://data-driven-forms.org/migration-guide" rel="noopener ugc nofollow" target="_blank">https://data-driven-forms.org/migration-guide</a></p><p id="3f89" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你也可以查看DDF的最新文章:<a class="ae jz" href="https://medium.com/javascript-in-plain-english/data-driven-form-building-in-react-30768b49e625" rel="noopener">https://medium . com/JavaScript-in-plain-English/data-driven-form-building-in-react-30768 b49 e 625</a></p><p id="8ab0" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">material UI mapper<a class="ae jz" href="https://medium.com/javascript-in-plain-english/introducing-material-ui-component-mapper-for-data-driven-forms-bb05076f7c8" rel="noopener">https://medium . com/JavaScript-in-plain-English/introducing-material-UI-component-mapper-for-data-driven-forms-bb 05076 f7c 8</a></p><p id="60c1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">碳设计系统映射器<a class="ae jz" href="https://medium.com/javascript-in-plain-english/introducing-carbon-component-mapper-for-data-driven-forms-c9221b604d8e" rel="noopener">https://medium . com/JavaScript-in-plain-English/introducing-carbon-component-mapper-for-data-driven-forms-c 9221 b 604 d8e</a></p><h2 id="5989" class="lp lq in bd ly nk nl dn mc nm nn dp mg kl no np mk kp nq nr mo kt ns nt ms nu bi translated">进一步阅读</h2><div class="nv nw gp gr nx ny"><a rel="noopener  ugc nofollow" target="_blank" href="/how-to-build-your-own-surveys-extend-them-with-custom-javascript-b4c7eb5648c4"><div class="nz ab fo"><div class="oa ab ob cl cj oc"><h2 class="bd io gy z fp od fr fs oe fu fw im bi translated">如何构建自己的调查并使用定制的JavaScript扩展它们</h2><div class="of l"><h3 class="bd b gy z fp od fr fs oe fu fw dk translated">这是一本关于如何使用自己的JS函数来扩充SurveyJS附带的条件逻辑和验证器的入门书。</h3></div><div class="og l"><p class="bd b dl z fp od fr fs oe fu fw dk translated">javascript.plainenglish.io</p></div></div><div class="oh l"><div class="oi l oj ok ol oh om jt ny"/></div></div></a></div><p id="c4c5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="lf">更多内容请看</em><a class="ae jz" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lf">plain English . io</em></strong></a><em class="lf">。报名参加我们的</em> <a class="ae jz" href="http://newsletter.plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kc io"> <em class="lf">免费周报</em> </strong> </a> <em class="lf">。关注我们关于</em><a class="ae jz" href="https://twitter.com/inPlainEngHQ" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lf">Twitter</em></strong></a><a class="ae jz" href="https://www.linkedin.com/company/inplainenglish/" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lf">LinkedIn</em></strong></a><em class="lf"/><a class="ae jz" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lf">YouTube</em></strong></a><em class="lf"/><a class="ae jz" href="https://discord.gg/GtDtUAvyhW" rel="noopener ugc nofollow" target="_blank"><strong class="kc io"><em class="lf">不和</em> </strong> </a> <em class="lf">。</em></p></div></div>    
</body>
</html>