<html>
<head>
<title>Why Svelte won’t kill React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">为什么苗条不会杀死反应</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/why-svelte-wont-kill-react-3cfdd940586a?source=collection_archive---------0-----------------------#2019-12-09">https://javascript.plainenglish.io/why-svelte-wont-kill-react-3cfdd940586a?source=collection_archive---------0-----------------------#2019-12-09</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="e529" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">这要归咎于现状吗？还是反应简单更好？</h2></div><p id="334c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当我刚开始阅读《苗条博士》时，我发现它非常鼓舞人心，并打算在Medium上写一篇关于它的悼词。在阅读了来自官方博客和社区的几篇文章后，我意识到这不会发生，因为我注意到了JavaScript世界中一些常见言论的迹象——这种言论让我<strong class="ke io">非常不安。</strong></p><blockquote class="ky kz la"><p id="fe78" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">嘿，还记得那个人类强大的头脑30年来一直试图解决的问题吗？我刚刚找到了一个通用的解决方案！为什么它还没有征服世界？应该很明显。脸书的营销团队正在密谋反对我们。</p></blockquote><p id="f25b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在我看来，与现有的工具相比，可以说你的工具是革命性的。很难对你自己的创作完全没有偏见，我明白。这里有一个正面的例子——我认为Vue在<a class="ae lf" href="https://vuejs.org/v2/guide/comparison.html" rel="noopener ugc nofollow" target="_blank">方面做得非常好</a>,与其他解决方案相比。是的，有一些我不同意的值得怀疑的说法，但它们传达了一个建设性的信息:</p><blockquote class="ky kz la"><p id="e5df" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">我们有这种方法，这里有一些其他现有的方法。我们认为我们的更好，原因如下。这里有一些常见的反驳论点。</p></blockquote><p id="d53d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">相反，官方的苗条博客最终通过只展示硬币的一面来欺骗读者，有时通过关于网络技术和其他libs的预先虚假陈述(我主要指的是React，因为我更了解它)。所以在今天的文章中，我将主要烤苗条只是为了平衡它。话虽如此，我仍然认为这背后有一个绝妙的想法，我会在文章的最后告诉你为什么😊</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi lg"><img src="../Images/ae180308cebae676347c0c181ef8eeb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*w4uLFcsyeLWeVetzq0VgqQ.jpeg"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk"><a class="ae lf" href="https://imgflip.com/i/122lno" rel="noopener ugc nofollow" target="_blank">imgflip.com</a></figcaption></figure><h1 id="5454" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">什么是苗条？</h1><p id="03d7" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">Svelte是一个构建用户界面的工具。与更流行的框架(如React和Vue)不同，它们利用虚拟DOM从组件输出中发出高效的DOM更新，Svelte使用静态分析在构建时创建DOM更新代码。这是一个细长组件的样子:</p><p id="e5a1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io"> App.svelte </strong></p><pre class="lh li lj lk gt mp mq mr ms aw mt bi"><span id="30bc" class="mu lt in mq b gy mv mw l mx my">&lt;script&gt;<br/> import Thing from './Thing.svelte';</span><span id="877c" class="mu lt in mq b gy mz mw l mx my">let things = [<br/>  { id: 1, color: '#0d0887' },<br/>  { id: 2, color: '#6a00a8' },<br/>  { id: 3, color: '#b12a90' },<br/>  { id: 4, color: '#e16462' },<br/>  { id: 5, color: '#fca636' }<br/> ];</span><span id="20cc" class="mu lt in mq b gy mz mw l mx my">function handleClick() {<br/>  things = things.slice(1);<br/> }<br/>&lt;/script&gt;</span><span id="b1fd" class="mu lt in mq b gy mz mw l mx my">&lt;button on:click={handleClick}&gt;<br/> Remove first thing<br/>&lt;/button&gt;</span><span id="8827" class="mu lt in mq b gy mz mw l mx my">{#each things as thing}<br/> &lt;Thing color={thing.color}/&gt;<br/>{/each}</span></pre><p id="43ac" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">身材苗条</strong></p><pre class="lh li lj lk gt mp mq mr ms aw mt bi"><span id="6303" class="mu lt in mq b gy mv mw l mx my">&lt;script&gt;<br/> export let color;<br/>&lt;/script&gt;</span><span id="cd6f" class="mu lt in mq b gy mz mw l mx my">&lt;p&gt;<br/> &lt;span style="background-color: {color}"&gt;current&lt;/span&gt;<br/>&lt;/p&gt;</span><span id="3700" class="mu lt in mq b gy mz mw l mx my">&lt;style&gt;<br/> span {<br/>  display: inline-block;<br/>  padding: 0.2em 0.5em;<br/>  margin: 0 0.2em 0.2em 0;<br/>  width: 4em;<br/>  text-align: center;<br/>  border-radius: 0.2em;<br/>  color: white;<br/> }<br/>&lt;/style&gt;</span></pre><p id="cd23" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">等效反应组分:</p><pre class="lh li lj lk gt mp mq mr ms aw mt bi"><span id="f6fe" class="mu lt in mq b gy mv mw l mx my">import React, {useState} from 'react'<br/>import styled from 'styled-components';</span><span id="28e7" class="mu lt in mq b gy mz mw l mx my">const things = [<br/>  { id: 1, color: '#0d0887' },<br/>  { id: 2, color: '#6a00a8' },<br/>  { id: 3, color: '#b12a90' },<br/>  { id: 4, color: '#e16462' },<br/>  { id: 5, color: '#fca636' }<br/> ];</span><span id="8fd6" class="mu lt in mq b gy mz mw l mx my">const Block = styled.span`<br/>  display: inline-block;<br/>  padding: 0.2em 0.5em;<br/>  margin: 0 0.2em 0.2em 0;<br/>  width: 4em;<br/>  text-align: center;<br/>  border-radius: 0.2em;<br/>  color: white;<br/>  background-color: ${props =&gt; props.backgroundColor}<br/>`;</span><span id="4cda" class="mu lt in mq b gy mz mw l mx my">const Thing = ({color}) =&gt; {<br/>  return (<br/>    &lt;p&gt;<br/>      &lt;Block backgroundColor={color} /&gt;<br/>    &lt;/p&gt;<br/>  );<br/>}</span><span id="f867" class="mu lt in mq b gy mz mw l mx my">export const App = () =&gt; {<br/>  const [things, setThings] = useState(things);<br/>  const removeFirstThing = () =&gt; setThings(things.slice(1))<br/>  return (<br/>    &lt;&gt;<br/>      &lt;button onClick={removeFirstThing} /&gt;<br/>      {things.map(thing =&gt;<br/>        &lt;Thing key={thing.key} color={thing.color} /&gt;<br/>      }<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><h2 id="d324" class="mu lt in bd lu na nb dn ly nc nd dp mc kl ne nf me kp ng nh mg kt ni nj mi nk bi translated">苗条不是一个框架——它是一种语言</h2><p id="5873" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">它不仅仅是用<code class="fe nl nm nn mq b">&lt;script&gt;</code>和<code class="fe nl nm nn mq b">&lt;style&gt;</code>添加类似Vue的“单个文件组件”。它向语言中添加了一些构造来解决UI开发中最复杂的问题之一——状态管理。</p><p id="0fe7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae lf" href="https://medium.com/swlh/what-is-the-best-state-container-library-for-react-b6989a45f236" rel="noopener">我的上一篇文章</a>介绍了使用JavaScript在React中解决这个问题的各种方法。Svelte利用其作为编译器的地位，使反应性成为一种语言特征。在Svelte中有两个新的语言结构服务于这个目的。</p><ul class=""><li id="48e0" class="no np in ke b kf kg ki kj kl nq kp nr kt ns kx nt nu nv nw bi translated">子句<a class="ae lf" href="https://svelte.dev/tutorial/reactive-declarations" rel="noopener ugc nofollow" target="_blank">前的<code class="fe nl nm nn mq b">$:</code>运算符使该子句成为反应性的</a>，即每次它读取的一些变量更新时，都会重新执行该子句。一个语句可以是一个赋值(又名“相关”或“派生”变量)，或者一个代码块或一个调用(又名“效果”)。这有点类似于MobX方法，但是内置于语言中。</li><li id="a797" class="no np in ke b kf nx ki ny kl nz kp oa kt ob kx nt nu nv nw bi translated"><code class="fe nl nm nn mq b">$</code>操作员<a class="ae lf" href="https://svelte.dev/tutorial/auto-subscriptions" rel="noopener ugc nofollow" target="_blank">创建一个对存储库</a>(状态容器)的订阅，当组件被卸载时，该订阅被自动取消</li></ul><p id="8939" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Svelte的反应性概念允许使用常规JS变量作为状态——不需要状态容器。但是真的能提高DX吗？</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi oc"><img src="../Images/2cc3276c23d6277ab4a39e121d1dec28.png" data-original-src="https://miro.medium.com/v2/resize:fit:1166/format:webp/1*c0shUq7fn3MHYBr39JJvQQ.jpeg"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk"><a class="ae lf" href="https://www.reddit.com/r/PrequelMemes/comments/arg2rb/when_people_think_obiwan_only_says_i_dont_think/" rel="noopener ugc nofollow" target="_blank">reddit.com</a></figcaption></figure><h1 id="55e7" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">斯维尔特的反应性</h1><blockquote class="ky kz la"><p id="95e8" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">React最初的承诺是，你可以在每次状态改变时重新渲染整个应用程序，而不用担心性能。实际上，我不认为这是准确的。如果是的话，就不需要像<code class="fe nl nm nn mq b">shouldComponentUpdate</code>(这是一种告诉React什么时候可以安全跳过某个组件的方法)——Rich Harris，Svelte的维护者</p><p id="c7df" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">真正的问题是程序员在错误的地方和错误的时间花了太多的时间担心效率；<strong class="ke io">过早优化是编程中所有罪恶(或者至少是大部分罪恶)的根源</strong>。—唐纳德·克努特，美国scientist⁴计算机公司</p></blockquote><p id="dd6f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">首先，我们先说清楚。即使你的代码中没有任何单个的<code class="fe nl nm nn mq b">shouldComponentUpdate</code>，React <strong class="ke io">也不会在每次状态改变时</strong>重新呈现你的整个应用。检查起来非常简单——你需要做的就是给你的应用程序的根组件添加一个<code class="fe nl nm nn mq b">console.log</code>调用。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div role="button" tabindex="0" class="oe of di og bf oh"><div class="gh gi od"><img src="../Images/acbcec5f959f69a7095e01ae21a916b4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ZykZcYuvyFsz-kHNRIJTpg.png"/></div></div></figure><p id="5118" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这种特殊情况下，<code class="fe nl nm nn mq b">App</code>不会被重新渲染，除非<code class="fe nl nm nn mq b">isAuthorized</code>状态改变。对任何子组件的更改都不会导致<code class="fe nl nm nn mq b">App</code>组件被重新渲染。仅当组件自身的状态发生变化时，或者由React上下文触发时，或者在父组件重新渲染期间，才会重新渲染组件。</p><p id="8a2b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">后一种情况为所谓的<em class="lb">浪费的渲染</em>创造了空间——这是一种预先知道父级重新渲染不会导致子级DOM层次结构发生任何变化，但子级仍然被重新渲染的情况。当子道具不变或者这种特殊的变化不应该影响屏幕上的可见内容时，就会发生这种情况。为了避免浪费渲染，你可以定义shouldComponentUpdate(或者使用<code class="fe nl nm nn mq b">React.memo</code>作为一个更现代的功能替代)。</p><h2 id="4d63" class="mu lt in bd lu na nb dn ly nc nd dp mc kl ne nf me kp ng nh mg kt ni nj mi nk bi translated">优化必须是例外的，而不是默认的</h2><p id="1781" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">在绝大多数情况下，浪费渲染没有任何问题。它们占用的资源如此之少，以至于人眼根本无法察觉。事实上，与简单地重新渲染整个子树相比，将每个组件的属性与其之前的属性进行比较(我甚至没有深入讨论)可能会占用更多的资源。这也是React默认回退到<code class="fe nl nm nn mq b">shouldComponentUpdate: () =&gt; true</code>的原因。此外，React团队甚至从开发工具中删除了“高亮更新”功能，因为人们过去常常痴迷于浪费的渲染，而it⁵.背后没有任何理由</p><p id="8aa1" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这是一种非常危险的做法，因为每次优化都意味着做出假设。如果你正在压缩一个图像，你假设一些有效负载可以被删除而不会严重影响质量，如果你在后端添加一个缓存，你假设API将返回相同的结果。正确的假设可以让你节省资源。一个错误的假设会在你的应用中引入一个bug。这就是为什么优化要有意识的去做。</p><p id="8c2f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Svelte选择了相反的方法。它不会在更新时重新运行组件的代码，除非使用<code class="fe nl nm nn mq b">$:</code>操作符明确地告诉它这样做。我不想花费几十个小时来搜索我忘记添加的地方，并试图找出为什么我的应用程序不工作——以便我的用户可以享受20毫秒更快的重新渲染。如果偶尔有分量重的，我会优化，但那是极其罕见的场合。这将是毫无意义的围绕它旋转我的DX。</p><h2 id="81ba" class="mu lt in bd lu na nb dn ly nc nd dp mc kl ne nf me kp ng nh mg kt ni nj mi nk bi translated">Svelte的优化不是最佳的</h2><p id="604b" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">顺便说一下，如果我们得到技术，Svelte的检查是否需要更新并不总是最佳的。让我们假设我有一个计算非常昂贵的组件，它接受以下形状的道具:<code class="fe nl nm nn mq b">Array&lt;{id: string, otherProps}&gt;</code>。假设我知道id是惟一的，数组项是不可变的，我可以使用下面的代码来判断是否需要更新:</p><pre class="lh li lj lk gt mp mq mr ms aw mt bi"><span id="2965" class="mu lt in mq b gy mv mw l mx my">const shouldUpdate = (prevArr, nextArr) =&gt; {<br/>  if (prevArr.length !== nextArr.length) return true;<br/>  return nextArr.some((item, index) =&gt; item.id !== prevArr[index].id)<br/>}</span></pre><p id="9e40" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">没有办法在Svelte中指定自定义反应比较器，它将回退到这个比较数组:</p><pre class="lh li lj lk gt mp mq mr ms aw mt bi"><span id="50e9" class="mu lt in mq b gy mv mw l mx my">export function safe_not_equal(a, b) { <br/>  return a != a ? b == b : a !== b <br/>    || ((a &amp;&amp; typeof a === 'object') || typeof a === 'function');<br/>}</span></pre><p id="48fe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我知道我可以在苗条者的比较器上使用一些第三方记忆工具<strong class="ke io">，但是我在这里的观点是——没有神奇的药丸,“开箱即用”的优化通常会有局限性。</strong></p><h2 id="07e3" class="mu lt in bd lu na nb dn ly nc nd dp mc kl ne nf me kp ng nh mg kt ni nj mi nk bi translated">不明确的状态更新</h2><p id="fa7c" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">每当你需要更新React中的状态时，你必须调用<code class="fe nl nm nn mq b">setState</code>。为了让你的状态更新得更苗条:</p><blockquote class="ky kz la"><p id="830b" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">…更新变量的名称必须出现在赋值的左边。</p></blockquote><p id="0b1a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Svelte神奇地添加了一个调用内部运行时无效函数来触发反应。这可能会带来一些疯狂的模式。</p><pre class="lh li lj lk gt mp mq mr ms aw mt bi"><span id="0244" class="mu lt in mq b gy mv mw l mx my">const foo = obj.foo;<br/>foo.bar = 'baz';<br/>obj = obj; // If you don't do this, update will not happen</span></pre><p id="c398" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<code class="fe nl nm nn mq b">push</code>或其他变异方法更新数组也不会自动触发组件更新。所以你必须使用数组或对象展开:</p><pre class="lh li lj lk gt mp mq mr ms aw mt bi"><span id="9145" class="mu lt in mq b gy mv mw l mx my">arr = [...arr, newItem];<br/>obj = {...obj, updatedValue: newValue};</span></pre><p id="0a5d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">基本上与React相同，除了在React中你调用一个函数并将更新后的状态传递给它，而在Svelte中你会有一种错觉，你正在处理常规的可变变量。这就把这个魔术的要点简化为“嘿，看多酷啊，Svelte是个编译器”。</p><h1 id="86e6" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">虚拟DOM</h1><blockquote class="ky kz la"><p id="9cdc" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">虚拟DOM是有价值的，因为它允许你在不考虑状态转换的情况下构建应用，其性能一般来说足够好——svelte⁶的维护者Rich Harris</p></blockquote><p id="7136" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这个苗条的博客中，几乎每一篇文章都声称虚拟DOM <a class="ae lf" href="https://svelte.dev/blog/virtual-dom-is-pure-overhead" rel="noopener ugc nofollow" target="_blank">是一个不必要的开销</a>，而且相当高，可以很容易地用预生成的DOM更新程序免费替换。但是这种说法正确吗？部分地。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/6c816a09744f5d8b6940289fdaaff67e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1250/format:webp/1*jomQ-J1bF6mx8eziWMnMww.jpeg"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk"><a class="ae lf" href="http://www.quickmeme.com/meme/362wa3" rel="noopener ugc nofollow" target="_blank">quickmeme.com</a></figcaption></figure><h2 id="7fa6" class="mu lt in bd lu na nb dn ly nc nd dp mc kl ne nf me kp ng nh mg kt ni nj mi nk bi translated">虚拟DOM会增加开销吗？</h2><p id="30a5" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">是的，完全正确。vDOM不是一个特性，只是把它添加到你的应用程序中并不能神奇地让底层的“真正的”DOM和浏览器变得更快。这只是将易于编写、阅读和调试的声明性代码转换成执行成本相对较低的高效命令式DOM操作的可能方法之一。</p><p id="7116" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是开销总是不好的吗？我相信不会——否则苗条的维护者将不得不用Rust或C编写他们的编译器，因为垃圾收集器是JavaScript的最大开销。我想当他们决定编译器的堆栈时，他们做了一个权衡——开销有多高与社区在交换中得到的好处。在这种情况下，开销相对较低——您的设备上没有持续运行的编译器，您只是不时地运行它，涉及的计算相对较少，几秒钟不会对UX产生很大影响。另一方面，因为Svelte基于JavaScript，并以JavaScript作为执行环境，用TS/JS编写工具为DX提供了相对巨大的好处——每个对该工具感兴趣的人——因此可能想要贡献或可能需要研究编译器源代码——都可能知道JavaScript。</p><p id="0fef" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以开销总是一个权衡。在虚拟DOM的情况下，这样做值吗？</p><h2 id="b3f7" class="mu lt in bd lu na nb dn ly nc nd dp mc kl ne nf me kp ng nh mg kt ni nj mi nk bi translated">虚拟DOM的成本</h2><p id="81ae" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">下载、解析和渲染一个React应用需要多长时间？</p><p id="d655" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">第一个问题由里奇·哈里斯自己回答:</p><blockquote class="ky kz la"><p id="1c6d" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">我们向用户发送了太多的代码。像许多前端开发人员一样，我一直否认这个事实，认为在页面加载上提供100kb的JavaScript是没问题的——只需要少用一个<a class="ae lf" href="https://twitter.com/miketaylr/status/227056824275333120" rel="noopener ugc nofollow" target="_blank">。jpg！</a> ⁷</p></blockquote><p id="3704" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是他接着写了一张纸条:</p><blockquote class="ky kz la"><p id="a50f" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">100千磅的。js并不等同于100kb的. jpg。不仅仅是网络时间会扼杀你的应用程序的启动性能，而是花在解析和评估你的脚本上的时间，在此期间，浏览器变得完全没有反应。⁷</p></blockquote><p id="47b0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">听起来很严重，让我们用谷歌浏览器的审计工具做一些测量。幸运的是，多亏了现实世界，我们才有了这种可能性。</p><p id="3c12" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae lf" href="https://react-redux.realworld.io/" rel="noopener ugc nofollow" target="_blank"> React-redux </a>:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/2b87446918c977fb043997c9c8c9c784.png" data-original-src="https://miro.medium.com/v2/resize:fit:266/format:webp/1*SA3Uq_pUV82XGQ7JoK6yMw.png"/></div></figure><p id="a530" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><a class="ae lf" href="https://realworld.svelte.dev/" rel="noopener ugc nofollow" target="_blank">身材苗条</a>:</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ok"><img src="../Images/20e9d53a527bfe6ec05af6d4594a5f22.png" data-original-src="https://miro.medium.com/v2/resize:fit:274/format:webp/1*apQnSN_tRBq7z_U0D3p_Rg.png"/></div></figure><p id="6fb4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">差别是0.15秒——这意味着可以忽略不计。</p><p id="777a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是基准呢？svelet博客提到的基准测试表明，刷1000行需要React 430.7ms毫秒，而svelet可以在51.8毫秒内完成</p><p id="1ea0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但这一指标并不可靠，因为React做出的<a class="ae lf" href="https://reactjs.org/docs/reconciliation.html" rel="noopener ugc nofollow" target="_blank">协调假设</a>导致这一特定操作是React的弱点——这种情况在现实世界的应用中非常罕见，相同的基准测试表明React和Svelte在几乎所有其他情况下的差异也可以忽略不计。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi ol"><img src="../Images/d1c3af1e3e1f94ca4c9602517e1f3be7.png" data-original-src="https://miro.medium.com/v2/resize:fit:478/format:webp/1*toE8L_WfxGiuMn16chedjQ.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">Svelte an React-redux on hooks comparation</figcaption></figure><p id="13ea" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在是我们最终意识到应该有所保留地对待这些基准的时候了。我们有窗口和虚拟化，一次呈现1000行无论如何都不是一个好主意。说真的，你做过吗？</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi om"><img src="../Images/e1a330e194c469a5857f610d05a95ba4.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*qvW2rqknyPnztVy4KTUfzA.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk"><a class="ae lf" href="https://tenor.com/view/well-then-your-are-lost-you-are-lost-obi-wan-kenobi-starwars-gif-7897510" rel="noopener ugc nofollow" target="_blank">tenor.com</a></figcaption></figure><p id="5592" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是苗条的维护者声称vDOM是完全不必要的——那么为什么要浪费任何资源呢？</p><h2 id="8188" class="mu lt in bd lu na nb dn ly nc nd dp mc kl ne nf me kp ng nh mg kt ni nj mi nk bi translated">vDOM的黑仔特性</h2><p id="cebc" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">vDOM有一个杀手锏，是Svelte无可替代的。它是将组件层次结构视为一个对象的能力。</p><p id="d418" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">反应代码:</p><pre class="lh li lj lk gt mp mq mr ms aw mt bi"><span id="fcb9" class="mu lt in mq b gy mv mw l mx my">const UnorderedList = ({children}) =&gt; (<br/>  &lt;ul&gt;<br/>    {<br/>      children.map((child, i) =&gt; &lt;li key={i}&gt;{child}&lt;/li&gt;<br/>    }<br/>  &lt;/ul&gt;<br/>)</span><span id="1160" class="mu lt in mq b gy mz mw l mx my">const App = () =&gt; (<br/>  &lt;UnorderedList&gt;<br/>    &lt;a href="http://example.com"&gt;Example&lt;/a&gt;<br/>    &lt;span&gt;Example&lt;/span&gt;<br/>    Text<br/>  &lt;/UnorderedList&gt;<br/>);</span></pre><p id="23a3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这对于React来说是一个非常简单的任务，而对于Svelte来说几乎是不可能的。因为模板不是图灵完全的，即使是，它们也需要vDOM。这看起来可能是一件小事，但对我来说，这比给我的应用程序增加0.15-0.25秒的交互时间更有道理。这正是我们需要vDOM的原因——我们可能不需要它来进行反应式状态更新、条件渲染或列表渲染，但只要我们拥有它，我们就可以将组件层次结构视为完全动态和可控的对象。如果没有这个特性，你就不能编写一个真正的完全声明性的应用程序。</p><h1 id="c997" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">临时限制(将来可能会得到解决)</h1><p id="b4c3" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">这里有几个不使用苗条身材的额外理由，它们可能会被修正。但这需要大量的社区努力，只要成本大于收益，这就不会发生。</p><h2 id="a5b0" class="mu lt in bd lu na nb dn ly nc nd dp mc kl ne nf me kp ng nh mg kt ni nj mi nk bi translated">不支持类型脚本</h2><p id="8eb3" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">因为Svelte使用模板，所以很难实现我们在React中喜欢的带有道具检查的完整类型支持。这要么需要对Microsoft TypeScript实现进行重大修改(这不太可能发生，因为Svelte的影响力远不如React)，要么需要某种需要持续维护的分支。代码生成也是一个选项，但是对元素层次结构中的每个细微变化运行codegen是一个可怕的DX。</p><h2 id="9a53" class="mu lt in bd lu na nb dn ly nc nd dp mc kl ne nf me kp ng nh mg kt ni nj mi nk bi translated">粗糙</h2><blockquote class="ky kz la"><p id="22a4" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">考虑互操作性。想要<code class="fe nl nm nn mq b">npm install cool-calendar-widget</code>并在你的app中使用？以前，只有当你已经在使用(一个正确版本的)小部件设计的框架时，你才能这样做——如果<code class="fe nl nm nn mq b">cool-calendar-widget</code>是在React中构建的，而你使用的是Angular，那么，嗯，硬奶酪。但是如果widget的作者使用了Svelte，那么使用它的应用程序可以使用任何你喜欢的技术来构建。—里奇·哈里斯，Svelte⁷的维护者</p></blockquote><p id="cde0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我已经有了我能想到的任何React工具——十几个GraphQL客户端、30多个表单状态管理器、数百个日期时间输入。</p><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi on"><img src="../Images/8085b3dee75ba515325134ecca627246.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*1M853tgrdLL2y9YnUp_Otw.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">NPM search for “svelte”</figcaption></figure><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi on"><img src="../Images/f9866eaa42c5039ab093406201bb75ba.png" data-original-src="https://miro.medium.com/v2/resize:fit:470/format:webp/1*PNnZjKUyyHMDT6UBd9PBJQ.png"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk">NPM search for “react”</figcaption></figure><p id="1685" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这在2013年可能会是一个杀手级的功能，但现在已经不重要了。</p><h1 id="d535" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">前途光明？</h1><p id="1aa6" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">尽管有上述限制，我认为苗条实际上提出了一个宝贵的想法。是的，在不牺牲灵活性和代码可重用性的情况下，你无法通过模板完全表达一个现代的应用程序。但是<strong class="ke io">我们的应用程序所做的绝大多数事情都只是条件和列表渲染。话又说回来，如果我只使用了<code class="fe nl nm nn mq b">onChange={e =&gt; setState(e.target.value)}</code>并在我的组件中渲染了十几个<code class="fe nl nm nn mq b">&lt;div&gt;</code>，为什么我需要在我的包中支持键盘事件、滚轮事件和内容可编辑？</strong></p><p id="fcf2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">老实说，我不相信苗条在它目前的形式能打败反应和征服世界。如果有一个框架，不增加任何特定的限制，但是100%树摇动所有未使用的部分，这将是很酷的。并产生一些可以在运行时使用的关于其正确执行的构建时提示。</p><h1 id="1ddd" class="ls lt in bd lu lv lw lx ly lz ma mb mc jt md ju me jw mf jx mg jz mh ka mi mj bi translated">关于可读性的一个注记</h1><p id="cd3d" class="pw-post-body-paragraph kc kd in ke b kf mk jo kh ki ml jr kk kl mm kn ko kp mn kr ks kt mo kv kw kx ig bi translated">我们已经知道，Svelte的关键特性不是性能(好处可以忽略不计)，不是魔力(对于JavaScript来说，有一些不自然的警告，以至于你很难对它们进行推理，+缺乏开发工具增加了额外的乐趣)，也不是互操作性(在2014年将是一件大事，但今天我们几乎拥有React-NG-Vue“三巨头”的一切)。但是可读性呢？</p><blockquote class="ky kz la"><p id="0a37" class="kc kd lb ke b kf kg jo kh ki kj jr kk lc km kn ko ld kq kr ks le ku kv kw kx ig bi translated">差别如此明显是不寻常的——根据我的经验，一个React组件通常比它的瘦对等物——svelte⁸.的维护者Rich Harris大40%左右</p></blockquote><figure class="lh li lj lk gt ll gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/fe1bb0478f69c8aa01407dacfb76f676.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/format:webp/1*H3YESgYacAyOpH31TVVNSQ.jpeg"/></div><figcaption class="lo lp gj gh gi lq lr bd b be z dk"><a class="ae lf" href="https://www.youtube.com/watch?v=byP3lzjuQH4" rel="noopener ugc nofollow" target="_blank">youtube.com</a></figcaption></figure><p id="6da7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每段代码你只写一遍，读很多遍。我知道这是一个品味问题，也是一个有争议的问题，我发现JSX和常规的javascript流操作符比任何种类的<code class="fe nl nm nn mq b">{#blocks}</code>和指令更具可读性。在Vue的人气达到顶峰之前，我曾经是它的忠实粉丝。然后在某个时刻，我偶然发现了模板的局限性和不可表达性，并开始到处使用JSX——因为JSX不是Vue的典型事物，我切换到随着时间的推移做出反应。我不想后退一步。</p></div><div class="ab cl op oq hr or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ig ih ii ij ik"><p id="1817" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">感谢阅读！😍</strong></p><p id="0747" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我希望你喜欢这篇文章。如果你有笔记，想要讨论或辩论——我们竭诚欢迎你发表评论！</p></div><div class="ab cl op oq hr or" role="separator"><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou ov"/><span class="os bw bk ot ou"/></div><div class="ig ih ii ij ik"><p id="0182" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">参考资料:</p><p id="e47d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">【1】:<a class="ae lf" href="https://svelte.dev/" rel="noopener ugc nofollow" target="_blank">https://svelte.dev/</a></p><p id="5844" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[2]:<a class="ae lf" href="https://github.com/sveltejs/rfcs/blob/master/text/0001-reactive-assignments.md" rel="noopener ugc nofollow" target="_blank">https://github . com/sveltejs/rfcs/blob/master/text/0001-reactive-assignments . MD</a></p><p id="dba4" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">【3】:<a class="ae lf" href="https://svelte.dev/blog/virtual-dom-is-pure-overhead" rel="noopener ugc nofollow" target="_blank">https://svelte.dev/blog/virtual-dom-is-pure-overhead</a></p><p id="76a9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">【4】:<a class="ae lf" href="https://en.wikiquote.org/wiki/Donald_Knuth" rel="noopener ugc nofollow" target="_blank">https://en.wikiquote.org/wiki/Donald_Knuth</a></p><p id="3a9d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[5]:<a class="ae lf" href="https://www.reddit.com/r/reactjs/comments/cqx554/introducing_the_new_react_devtools/ex1r9nb/" rel="noopener ugc nofollow" target="_blank">https://www . Reddit . com/r/react js/comments/cqx 554/introducing _ the _ new _ react _ dev tools/ex 1 r9 nb/</a></p><p id="8507" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[6]:<a class="ae lf" href="https://svelte.dev/blog/virtual-dom-is-pure-overhead" rel="noopener ugc nofollow" target="_blank">https://svelte.dev/blog/virtual-dom-is-pure-overhead</a></p><p id="2a5b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[7]:<a class="ae lf" href="https://svelte.dev/blog/frameworks-without-the-framework" rel="noopener ugc nofollow" target="_blank">https://svelte.dev/blog/frameworks-without-the-framework</a></p><p id="2fd8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">[8]:https://svelte.dev/blog/write-less-code<a class="ae lf" href="https://svelte.dev/blog/write-less-code" rel="noopener ugc nofollow" target="_blank"/></p></div></div>    
</body>
</html>