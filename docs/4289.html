<html>
<head>
<title>Callbacks, Promises, and Async/Await in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的回调、承诺和异步/等待</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/callbacks-promises-and-async-await-in-javascript-545918a228a9?source=collection_archive---------14-----------------------#2020-11-30">https://javascript.plainenglish.io/callbacks-promises-and-async-await-in-javascript-545918a228a9?source=collection_archive---------14-----------------------#2020-11-30</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="18e8" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">如何编写异步JavaScript</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/92c8e0a08e891a72ea9dbacf2052b4d4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fFE8UW2Hq7bIqvLf"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@abn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Álvaro Bernal</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="3c06" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript是单线程的，这意味着一次只能发生一件事。<strong class="ky ir">同步代码</strong>按照代码编写的顺序从上到下执行。同步代码也是“阻塞”的——每一行代码在运行之前都要等待前一行代码被执行。</p><p id="3dbe" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">相比之下，<strong class="ky ir">异步代码</strong>是“非阻塞”代码，允许长时间运行的请求不会阻塞主JavaScript线程。当请求完成时，可以执行额外的代码。这通常通过以下三种方式之一实现:</p><ol class=""><li id="28d9" class="ls lt iq ky b kz la lc ld lf lu lj lv ln lw lr lx ly lz ma bi translated">复试</li><li id="59d1" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">承诺</li><li id="60b8" class="ls lt iq ky b kz mb lc mc lf md lj me ln mf lr lx ly lz ma bi translated">异步/等待</li></ol><p id="fa29" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们看几个例子，看看如何使用这三种方法编写异步代码。</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="137d" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">复试</h1><p id="2e1d" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">回调函数是作为参数传递给异步函数的函数。一旦工作的异步部分完成，回调函数就被执行。</p><p id="fe1e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们通过使用<code class="fe nk nl nm nn b">setTimeout</code>方法来模拟等待API请求返回响应。回调方法可能如下所示:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="610b" class="ns mo iq nn b gy nt nu l nv nw">function myAsyncMethod(callback) {<br/>  console.log('myAsyncMethod was executed')<br/>  setTimeout(callback, 1000)<br/>}</span><span id="5adc" class="ns mo iq nn b gy nx nu l nv nw">function myCallbackMethod() {<br/>  console.log('myCallbackMethod was executed')<br/>}</span><span id="e80a" class="ns mo iq nn b gy nx nu l nv nw">myAsyncMethod(myCallbackMethod)</span></pre><p id="69b1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码首先将文本“myAsyncMethod executed”记录到控制台。然后，它将等待一秒钟，然后将文本“myCallbackMethod executed”记录到控制台</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="433c" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">承诺</h1><p id="a3e9" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">承诺是编写异步代码的另一种方式，可以帮助您避免深度嵌套的回调函数，也称为“回调地狱”承诺可以是以下三种状态之一:待定、已解决或已拒绝。一旦承诺得到解决，您就可以使用<code class="fe nk nl nm nn b">promise.then()</code>方法来处理响应。如果承诺被拒绝，您可以使用<code class="fe nk nl nm nn b">promise.catch()</code>方法处理错误。</p><p id="63b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们可以用这样的承诺重写我们之前的例子:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="c8da" class="ns mo iq nn b gy nt nu l nv nw">function myAsyncMethod() {<br/>  console.log('myAsyncMethod was executed')<br/>  <br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(resolve, 1000) <br/>  }) <br/>}</span><span id="fb26" class="ns mo iq nn b gy nx nu l nv nw">function myPromiseThenMethod() {<br/>  console.log('myPromiseThenMethod was executed')<br/>}</span><span id="0be9" class="ns mo iq nn b gy nx nu l nv nw">myAsyncMethod().then(myPromiseThenMethod)</span></pre><p id="6404" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">和以前一样，这段代码首先将文本“myAsyncMethod executed”记录到控制台。然后，它将等待一秒钟，然后将文本“myPromiseThenMethod已执行”记录到控制台</p></div><div class="ab cl mg mh hu mi" role="separator"><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml mm"/><span class="mj bw bk mk ml"/></div><div class="ij ik il im in"><h1 id="9e62" class="mn mo iq bd mp mq mr ms mt mu mv mw mx jw my jx mz jz na ka nb kc nc kd nd ne bi translated">异步/等待</h1><p id="260f" class="pw-post-body-paragraph kw kx iq ky b kz nf jr lb lc ng ju le lf nh lh li lj ni ll lm ln nj lp lq lr ij bi translated">Async/await是ES2017中引入的新语法。它允许你以一种<em class="ny">看起来</em>同步的方式编写异步代码，即使它不是。这使得代码更容易理解。</p><p id="b0da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们再次重写我们的示例，这次使用async/await:</p><pre class="kg kh ki kj gt no nn np nq aw nr bi"><span id="75cc" class="ns mo iq nn b gy nt nu l nv nw">function myAsyncMethod() {<br/>  console.log('myAsyncMethod was executed')<br/>  <br/>  return new Promise((resolve, reject) =&gt; {<br/>    setTimeout(resolve, 1000) <br/>  })<br/>}</span><span id="401a" class="ns mo iq nn b gy nx nu l nv nw">function myAwaitMethod() {<br/>  console.log('myAwaitMethod was executed')<br/>}</span><span id="58cf" class="ns mo iq nn b gy nx nu l nv nw">async function init() {<br/>  await myAsyncMethod()<br/>  myAwaitMethod()<br/>}</span><span id="e7fc" class="ns mo iq nn b gy nx nu l nv nw">init()</span></pre><p id="bdd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">同样，这段代码将首先向控制台记录文本“myAsyncMethod executed”然后，它将等待一秒钟，然后将文本“mywaitmethod executed”记录到控制台</p><p id="3d70" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">注意我们是如何使用关键字<code class="fe nk nl nm nn b">async</code>定义<code class="fe nk nl nm nn b">init</code>函数的。然后，在调用<code class="fe nk nl nm nn b">myAsyncMethod</code>函数之前，我们使用了<code class="fe nk nl nm nn b">await</code>关键字来告诉我们的代码，在 <code class="fe nk nl nm nn b">myAsyncMethod</code>完成运行之后的<em class="ny">之前，我们不想运行调用<code class="fe nk nl nm nn b">myAwaitMethod</code>的下一行代码。</em></p><p id="4f90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在我们有了看起来同步实际上异步运行的代码！Async/await给了我们两全其美的东西:非阻塞代码仍然易于阅读和推理。</p></div></div>    
</body>
</html>