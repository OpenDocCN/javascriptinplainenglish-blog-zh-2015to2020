<html>
<head>
<title>Binary search trees: How they work</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">二分搜索法树:它们是如何工作的</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/binary-search-trees-how-they-work-9c64029eedb7?source=collection_archive---------3-----------------------#2019-09-20">https://javascript.plainenglish.io/binary-search-trees-how-they-work-9c64029eedb7?source=collection_archive---------3-----------------------#2019-09-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><figure class="ip iq gp gr ir is gh gi paragraph-image"><div role="button" tabindex="0" class="it iu di iv bf iw"><div class="gh gi io"><img src="../Images/46680cc649af2c621e92681ed18db2b9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-p4WZsZPKFHJuyMfW1Q3cg.jpeg"/></div></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Photo by <a class="ae jd" href="https://unsplash.com/@veeterzy?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">veeterzy</a> on <a class="ae jd" href="https://unsplash.com/s/photos/tree?utm_source=unsplash&amp;utm_medium=referral&amp;utm_content=creditCopyText" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><div class=""/><h1 id="6cf9" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是二叉树？</h1><p id="7956" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一棵<strong class="ld jh">二叉树</strong>是计算机科学中一种重要的树形数据结构，其中每个节点最多只能有两个子节点。子节点通常被称为左节点和右节点。这种类型的二叉树有时也被称为<strong class="ld jh">根二叉树。</strong></p><figure class="ma mb mc md gt is gh gi paragraph-image"><div class="gh gi lz"><img src="../Images/a4d7351461a8d615a00637159f9c46c0.png" data-original-src="https://miro.medium.com/v2/resize:fit:760/format:webp/1*rZhlYtYNgHrZp1VsxWupQA.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Rooted Binary Tree</figcaption></figure><figure class="ma mb mc md gt is gh gi paragraph-image"><div class="gh gi me"><img src="../Images/7604862672a9958289019a1cdaf492fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*gU9TkbaDo9VK4n8HqsTlQQ.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Full Binary Tree</figcaption></figure><figure class="ma mb mc md gt is gh gi paragraph-image"><div class="gh gi me"><img src="../Images/39c08405cf89f69e322fb26966096791.png" data-original-src="https://miro.medium.com/v2/resize:fit:500/format:webp/1*sXB3gMCh7WYKNIzggg5zYw.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Perfect Binary Tree</figcaption></figure><p id="8b07" class="pw-post-body-paragraph lb lc jg ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">如果一棵二叉树的每个节点都有0或2个孩子，但是没有一个节点只有1个孩子，那么它被认为是一棵<strong class="ld jh">完全二叉树</strong>。左边的绿色树是完全二叉树的一个例子。</p><p id="2526" class="pw-post-body-paragraph lb lc jg ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">一棵<strong class="ld jh">完美的二叉树</strong>，比如左边的黑树，除了最后一层的节点之外，每个节点都有两个子节点，并且所有的叶子都延伸到同一层。二叉树通常用于两个不同的目的，但是在本文中我们只看其中一个用例。以特定方式排序的二叉树被称为<strong class="ld jh">二分搜索法树</strong>。</p><h1 id="29cd" class="kd ke jg bd kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la bi translated">什么是二叉查找树？</h1><p id="24b3" class="pw-post-body-paragraph lb lc jg ld b le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly ij bi translated">一个<strong class="ld jh">二叉查找树</strong>是一种特定类型的二叉树，其中节点按照它们在树中的排列进行排序。每个节点仍然最多只能有两个子节点，但是在二叉查找树中，<strong class="ld jh">左边的子节点<em class="mk">总是比根节点的值</em>小，右边的子节点<strong class="ld jh">总是比根节点的值大。</strong></strong></p><figure class="ma mb mc md gt is gh gi paragraph-image"><div class="gh gi ml"><img src="../Images/6676bd9d771c2bc1e6ad16e48d10adc5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*uJsl1Zt44YYzXCERMmZ4Og.png"/></div><figcaption class="iz ja gj gh gi jb jc bd b be z dk">Binary Search Tree</figcaption></figure><p id="15df" class="pw-post-body-paragraph lb lc jg ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">遍历二分搜索法树很容易，也很有效，因为每个被访问和探索的节点，至少还有一个我们永远不会处理的节点。</p><p id="71d6" class="pw-post-body-paragraph lb lc jg ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">例如，上面的树有8个节点。假设我们需要找到值为90的节点。让我们也说，我们不知道这是一个二叉查找树，所以不遍历它。使用深度优先搜索，我们必须首先访问11，然后是2、1、9、3、57和25，最后到达90。这是8个不同的步骤，或者说是<em class="mk"> n. </em>的大O</p><p id="e1f3" class="pw-post-body-paragraph lb lc jg ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">使用广度优先搜索，我们仍然会先访问11个，然后是2、57、1、9和25个，最后到达90个。这个搜索有7个不同的步骤，也是一个大O的<em class="mk"> n </em>。</p><p id="d8af" class="pw-post-body-paragraph lb lc jg ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">事实上，它是一个二叉查找树，使我们能够大幅降低运行时间。不用遍历每个节点直到找到90，我们可以简单地从根节点11开始，然后问，90是大于还是小于11？它大于，所以我们将移动到右边的子节点，并立即从搜索中删除11左边的4个节点。右边的孩子是57，所以我们再问一次，90是大于还是小于57？它大于，所以我们向右切去25。正确的孩子是90岁，所以我们的搜索接近尾声。</p><p id="2bb6" class="pw-post-body-paragraph lb lc jg ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">如您所见，我们只需3步就能找到我们的节点，而不是7或8步。效率提高了50%以上，这是大规模的重大改进。同样令人惊讶的是，即使在穿越二叉查找树的最坏情况下，运行时间也不会超过树的高度。</p><p id="d088" class="pw-post-body-paragraph lb lc jg ld b le mf lg lh li mg lk ll lm mh lo lp lq mi ls lt lu mj lw lx ly ij bi translated">下周，我们将深入探讨如何使用JavaScript来表示和遍历二叉查找树。</p></div></div>    
</body>
</html>