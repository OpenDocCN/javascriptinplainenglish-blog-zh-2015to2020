<html>
<head>
<title>JavaScript Tips — Function Name, Promises Statuses, and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript提示—函数名、承诺状态等等</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-tips-function-name-promises-statuses-and-more-8d0c1fd01497?source=collection_archive---------12-----------------------#2020-07-16">https://javascript.plainenglish.io/javascript-tips-function-name-promises-statuses-and-more-8d0c1fd01497?source=collection_archive---------12-----------------------#2020-07-16</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/fe268d0e5ac01ba3e1485f08465b2d44.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*zEgDRdZTXeTKwKAF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@austindistel?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Austin Distel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="0f47" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写JavaScript应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些常见JavaScript问题的解决方案。</p><h1 id="336c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从函数中获取函数名</h1><p id="4a62" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">name</code>属性从函数中获取函数名。</p><p id="2e48" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dc2d" class="mq lc iq mh b gy mr ms l mt mu">const foo = () =&gt; {<br/>  console.log(foo.name);<br/>}</span><span id="0377" class="mq lc iq mh b gy mv ms l mt mu">foo();</span></pre><p id="7545" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们应该看到<code class="fe me mf mg mh b">foo</code>被记录。</p><h1 id="47a7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">脚本的加载顺序</h1><p id="4722" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">如果我们没有动态加载脚本或者用<code class="fe me mf mg mh b">defer</code>或<code class="fe me mf mg mh b">async</code>标记它们，那么它们会按照在页面上出现的顺序加载。</p><p id="1f31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个顺序适用于内联脚本和外部脚本。</p><p id="6dde" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">异步脚本以不可预知的顺序异步加载。</p><p id="0b90" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">带有<code class="fe me mf mg mh b">defer</code>的脚本是异步加载的，但是按照它们遇到的顺序。</p><p id="8522" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这让我们可以异步加载相互依赖的脚本。</p><h1 id="ba8e" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">将HTML页面滚动到给定的锚点</h1><p id="4fe6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以将哈希值设置为<code class="fe me mf mg mh b">location.hash</code>的值，以滚动到具有给定ID的元素。</p><p id="7467" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ac73" class="mq lc iq mh b gy mr ms l mt mu">const scrollTo = (id) =&gt; {<br/>  location.hash = `#${id}`;<br/>}</span></pre><p id="010b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们传入元素的ID来滚动到具有该ID的元素。</p><h1 id="0a62" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">提前解决或拒绝后返回</h1><p id="0527" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们需要在早期解决或拒绝的行后添加一个<code class="fe me mf mg mh b">return</code>。</p><p id="e28c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="79fa" class="mq lc iq mh b gy mr ms l mt mu">const add = (a, b) =&gt; {<br/>  <!-- -->return new Promise((resolve, reject) =&gt; {<br/>    if (typeof a !== 'number' || typeof b !== 'number') {<br/>      reject("a or b isn't a number");<br/>      return;<br/>    }<br/>    resolve(a + b);<br/>  });<br/>}</span></pre><p id="3e7c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要在<code class="fe me mf mg mh b">reject</code>调用后添加<code class="fe me mf mg mh b">return</code>，这样它下面的代码就不会运行了。</p><h1 id="1880" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">JavaScript中的类与静态方法</h1><p id="cafa" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">类方法不同于JavaScript中的静态方法。</p><p id="e359" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类方法必须在实例上被调用，并且可以访问<code class="fe me mf mg mh b">this</code>，它是类的实例。</p><p id="11e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">静态方法直接在类本身上调用，不能访问<code class="fe me mf mg mh b">this</code>。</p><p id="53d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="198e" class="mq lc iq mh b gy mr ms l mt mu">function Foo(name){<br/>  this.name = name;<br/>}</span><span id="a1e4" class="mq lc iq mh b gy mv ms l mt mu">Foo.prototype.bar = function(){<br/>  console.log(this.name);<br/>}</span></pre><p id="a4ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，如果我们创建一个新的<code class="fe me mf mg mh b">Foo</code>实例，我们可以调用<code class="fe me mf mg mh b">bar</code>方法:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="55ed" class="mq lc iq mh b gy mr ms l mt mu">const foo = new Foo('mary');<br/>foo.bar();</span></pre><p id="a235" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么应该记录<code class="fe me mf mg mh b">'mary'</code>，因为它是在实例化它时设置的<code class="fe me mf mg mh b">this.name</code>属性的值。</p><p id="b512" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">另一方面，静态方法被直接定义为构造函数的属性:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8b36" class="mq lc iq mh b gy mr ms l mt mu">function Foo(){}<br/>Foo.hello = function() {<br/>  console.log('hello');<br/>}</span></pre><p id="8edd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们直接调用<code class="fe me mf mg mh b">Foo.hello</code>:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="17ff" class="mq lc iq mh b gy mr ms l mt mu">Foo.hello();</span></pre><p id="9148" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并且<code class="fe me mf mg mh b">'hello'</code>被记录。</p><p id="e783" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有了类语法，我们可以把它们都放在一个地方:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7e75" class="mq lc iq mh b gy mr ms l mt mu">class Foo {<br/>  constructor(name) {<br/>    this.name = name;<br/>  }</span><span id="ed70" class="mq lc iq mh b gy mv ms l mt mu">  bar() {<br/>    console.log(this.name);<br/>  }</span><span id="bdf3" class="mq lc iq mh b gy mv ms l mt mu">  static hello() {<br/>    console.log('hello');<br/>  }<br/>}</span></pre><p id="8bb1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">bar</code>是类方法，<code class="fe me mf mg mh b">hello</code>是静态方法。</p><h1 id="aef0" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">从数组中获取子数组</h1><p id="c45a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">slice</code>方法从一个数组中得到一个子数组。</p><p id="360a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="85d5" class="mq lc iq mh b gy mr ms l mt mu">const arr = [1, 2, 3, 4, 5];<br/>const arr2 = arr.slice(1, 4);</span></pre><p id="2813" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到<code class="fe me mf mg mh b">arr2</code>的<code class="fe me mf mg mh b">[2, 3, 4]</code>。不包括结束索引。</p><h1 id="9b33" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">用JavaScript预加载图像</h1><p id="39d8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了预加载图像，我们可以用<code class="fe me mf mg mh b">Image</code>构造函数创建新的img元素，并设置它的<code class="fe me mf mg mh b">src</code>属性。</p><p id="4ffa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="685c" class="mq lc iq mh b gy mr ms l mt mu">const images = [<br/>  'http://placekitten.com/200/200',<br/>  'http://placekitten.com/201/201',<br/>  'http://placekitten.com/202/202',<br/>]</span></pre><p id="a7d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c49d" class="mq lc iq mh b gy mr ms l mt mu">for (const image of images) {<br/>  const img = new Image();<br/>  img.src = image;<br/>}</span></pre><h1 id="667d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">处理Promise.all中的错误</h1><p id="fb05" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过检查结果中是否有任何<code class="fe me mf mg mh b">Error</code>实例来处理来自<code class="fe me mf mg mh b">Promise.allSettled</code>的错误。</p><p id="929b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="4521" class="mq lc iq mh b gy mr ms l mt mu">const getAll = async (<!-- -->promises<!-- -->) =&gt; {<br/>  <!-- -->const results = await Promise.allSettled(promises);<br/>  console.log(result.map(x =&gt; s.status));<br/>}</span></pre><p id="356c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们得到了<code class="fe me mf mg mh b">promises</code>，这是一组承诺。</p><p id="f977" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们调用<code class="fe me mf mg mh b">Promise.allSettled</code>从承诺中得到结果。</p><p id="fefa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们用<code class="fe me mf mg mh b">status</code>属性获得每个承诺的状态。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/9b1fc54ccb31452de274ee2e7fc8db1e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*rlFBy89QsYM6s6wF"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@danieljerez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Daniel Jerez</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="44ce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="697a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">name</code>属性得到一个函数的名字。</p><p id="647d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">脚本的加载顺序与HTML中列出的顺序相同。</p><p id="f859" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">类和静态方法是不同的。</p><p id="70e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">slice</code>来获得一个数组的子数组。</p><p id="cdae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">Promise.allSettled</code>可以得到所有承诺的状态。</p><h2 id="b16b" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="814e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅解码，我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>