<html>
<head>
<title>React Hooks — useState, useEffect, useRef, useMemo (TicTacToe Game)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">React Hooks —使用状态、使用效果、使用参考、使用备忘录(TicTacToe游戏)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/react-hooks-usestate-useeffect-useref-usememo-926fc2a86a6a?source=collection_archive---------0-----------------------#2019-08-11">https://javascript.plainenglish.io/react-hooks-usestate-useeffect-useref-usememo-926fc2a86a6a?source=collection_archive---------0-----------------------#2019-08-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><p id="beea" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">想象一下:你的应用程序中有一个优秀的函数组件，但有一天你需要在其中添加一个生命周期方法。经过一段时间的思考，你可以将函数组件转换成一个类&amp;这就对了。</p><p id="373a" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">您将转换类Temp扩展React。组件，然后在render body中复制您的返回函数。</p><p id="87e6" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">然而，新的React-Hooks有更好的方法来做这件事。您也可以在功能组件和生命周期方法中使用状态。</p><blockquote class="ki kj kk"><p id="bbe9" class="jk jl kl jm b jn jo jp jq jr js jt ju km jw jx jy kn ka kb kc ko ke kf kg kh ig bi translated">注意:这篇文章需要React的基础知识。</p></blockquote></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><p id="4647" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io">钩子让你把状态&amp;生命周期反应特性插入功能组件。</strong></p><p id="2323" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><strong class="jm io"> <em class="kl"> useState </em> </strong>:这个钩子可以让你在功能组件中添加状态。在类组件中，我们可以有“this”。有了“this”的帮助，我们可以在构造函数中初始化状态，并可以做我们的工作。但是在函数组件中，我们没有“this ”,所以我们不能赋值或读取“this”。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3557" class="lf lg in lb b gy lh li l lj lk">import React, { useState } from 'react';<br/><br/>function Example() {<br/>  // Declare a new state variable, which we'll call "count"<br/>  const [count, setCount] = useState(0);</span></pre><p id="fdab" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">在上面的例子中，我们使用了react包中的“useState”。在这个例子中，我们有一个变量“count ”,它的值作为一个参数设置在useState(0)中。所以“0”将是它的初始值，它可以是任何你需要的数据类型。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="1a26" class="lf lg in lb b gy lh li l lj lk">// Can be modified as setCount method which we mentioned in useState.<br/>&lt;button onClick={() =&gt; setCount(count + 1)}&gt; <br/>    {count} // Can be read in this way<br/>  &lt;/button&gt;</span></pre><blockquote class="ll"><p id="4200" class="lm ln in bd lo lp lq lr ls lt lu kh dk translated">完整示例:</p></blockquote><pre class="lv lw lx ly lz la lb lc ld aw le bi"><span id="a83f" class="lf lg in lb b gy lh li l lj lk"> 1:  import React, { useState } from 'react';<br/> 2:<br/> 3:  function Example() {<br/> 4:    const [count, setCount] = useState(0);<br/> 5:<br/> 6:    return (<br/> 7:      &lt;div&gt;<br/> 8:        &lt;p&gt;You clicked {count} times&lt;/p&gt;<br/> 9:        &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br/>10:         Click me<br/>11:        &lt;/button&gt;<br/>12:      &lt;/div&gt;<br/>13:    );<br/>14:  }</span></pre><p id="7e55" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">当我们用<code class="fe ma mb mc lb b">useState</code>声明一个状态变量时，它返回一对——一个包含两项的数组。第一项是当前值，第二项是让我们更新它的函数。</p><h2 id="9312" class="lf lg in bd md me mf dn mg mh mi dp mj jv mk ml mm jz mn mo mp kd mq mr ms mt bi translated">自定义挂钩:</h2><p id="5636" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">React钩子最好的一点是它们是常规的JS函数调用，所以我们可以将它们的所有逻辑重构为一个小函数。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="93f2" class="lf lg in lb b gy lh li l lj lk"><em class="kl">// 🐨 Make a custom hook called useCounter that accepts the step and<br/>// initialCount and returns the count and increment function</em> function useCounter({stepCount = 1, initialCount = 0}) {<br/> const [count, setCount] = React.useState(initialCount)<br/> const increment = () =&gt; setCount(count + stepCount)<br/> return [count, increment]<br/>}</span><span id="e86f" class="lf lg in lb b gy mz li l lj lk">function Counter({step = 1, initialCount = 0}) {<br/> const [count, increment] = useCounter(step, initialCount)<br/> return &lt;button onClick={increment}&gt;{count}&lt;/button&gt;<br/>}</span></pre><h2 id="72da" class="lf lg in bd md me mf dn mg mh mi dp mj jv mk ml mm jz mn mo mp kd mq mr ms mt bi translated">使用效果:</h2><p id="2725" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated">可以用' useEffect '直接在函数组件内部处理3个生命周期事件，即:componentDidMount，componentDidUpdate，componentWillUnmount。</p><p id="47c4" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">有时我们希望每次渲染时都运行我们的代码。我们传递给“React.useEffect”的回调是在组件的<em class="kl"> _every_ </em>渲染(包括重新渲染)之后调用的。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="3d0e" class="lf lg in lb b gy lh li l lj lk">React.useEffect( () =&gt; {<br/>   Console.log("useEffect runs");<br/>});</span></pre><p id="4dd3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">但有时我们只想使用一个有效的回调函数来运行我们的变量值的变化。在这种情况下，对我们来说幸运的是，“React.useEffect”允许您传递第二个参数，称为“依赖关系数组”,当(且仅当)这些依赖关系发生变化时，它会通知React您的效果回调函数应该被调用。所以我们可以用这个来避免做不必要的工作！</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="ac63" class="lf lg in lb b gy lh li l lj lk">//Custom useState hook <br/>function useLocalStorageCounter({step = 1, initialCount = 0, key = 'count'}) {<br/>const [count, setCount] = React.useState(() =&gt;<br/>  Number(window.localStorage.getItem('count') || initialCount),<br/>)<br/>React.useEffect(() =&gt; {<br/>window.localStorage.setItem('count', count)<br/>}, [count]);</span><span id="3171" class="lf lg in lb b gy mz li l lj lk">const increment = () =&gt; setCount(c =&gt; c + step)</span><span id="cc39" class="lf lg in lb b gy mz li l lj lk">return [count, increment]<br/>}</span></pre><figure class="kw kx ky kz gt nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi na"><img src="../Images/9db5432ebfb3a2425eb61f5944fb41ca.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-QHrX7G1g78HBTGkzwOPLQ.png"/></div></div></figure><p id="9694" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果我在useEffect中提供了空的依赖项，那么这意味着我只想在初始加载时加载回调函数。或者，如果我从回调函数中返回一些东西，那么它将像componentWillUnmount lifeCycle方法一样工作。</p><h2 id="1b48" class="lf lg in bd md me mf dn mg mh mi dp mj jv mk ml mm jz mn mo mp kd mq mr ms mt bi translated">useRef:</h2><p id="b6b6" class="pw-post-body-paragraph jk jl in jm b jn mu jp jq jr mv jt ju jv mw jx jy jz mx kb kc kd my kf kg kh ig bi translated"><code class="fe ma mb mc lb b">useRef</code>返回一个可变的ref对象，其<code class="fe ma mb mc lb b">.current</code>属性被初始化为传递的参数(<code class="fe ma mb mc lb b">initialValue</code>)。返回的对象将在组件的整个生存期内保持不变。</p><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="e217" class="lf lg in lb b gy lh li l lj lk">function formMethod() {<br/>  const username= useRef(null);<br/>  const onUsernameClick = () =&gt; {<br/>    // `current` points to the mounted text input element<br/>    username.current.focus();<br/>  };<br/>  return (<br/>    &lt;&gt;<br/>      &lt;input ref={username} type="text" /&gt;<br/>      &lt;button onClick={onUsernameClick}&gt;Focus the input&lt;/button&gt;<br/>    &lt;/&gt;<br/>  );<br/>}</span></pre><p id="b3f3" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">请记住，<code class="fe ma mb mc lb b">useRef</code> <em class="kl">不会在内容改变时通知您。改变<code class="fe ma mb mc lb b">.current</code>属性不会导致重新渲染。</em></p><h2 id="b829" class="lf lg in bd md me mf dn mg mh mi dp mj jv mk ml mm jz mn mo mp kd mq mr ms mt bi translated">使用备忘录:</h2><pre class="kw kx ky kz gt la lb lc ld aw le bi"><span id="cc07" class="lf lg in lb b gy lh li l lj lk">const memoizedValue = useMemo(() =&gt; modifyValue(a), [a]);</span></pre><p id="26aa" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><code class="fe ma mb mc lb b">useMemo</code>只有当其中一个依赖关系发生变化时，才会重新计算记忆值。这种优化有助于避免每次渲染时进行昂贵的计算。</p><p id="69ee" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">记住传递给<code class="fe ma mb mc lb b">useMemo</code>的函数在渲染时运行。不要做任何渲染时通常不会做的事情。如果没有提供数组，每次渲染都会计算一个新值。</p><p id="6a2f" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">为了让你的手脏在代码中，我在CodeSandbox的react hooks中做了一个例子。</p><p id="a671" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated"><a class="ae ni" href="http://TicTacToe Game in react hooks" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/tictactoe-react-hooks-fjth8</a></p><blockquote class="ll"><p id="1f46" class="lm ln in bd lo lp nj nk nl nm nn kh dk translated"><a class="ae ni" href="https://github.com/vinodchauhan7/react-hooks-ticTacToe" rel="noopener ugc nofollow" target="_blank">https://github.com/vinodchauhan7/react-hooks-ticTacToe</a></p></blockquote><figure class="lv lw lx ly lz nb gh gi paragraph-image"><div role="button" tabindex="0" class="nc nd di ne bf nf"><div class="gh gi no"><img src="../Images/e8a6bcd2835a2221945fab4fed8205ce.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oXyFtdu-jrH9EJ9oDaih6A.png"/></div></div></figure><p id="ed67" class="pw-post-body-paragraph jk jl in jm b jn jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ig bi translated">如果你喜欢这个，请提供你的建设性意见和分享。</p></div></div>    
</body>
</html>