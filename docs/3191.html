<html>
<head>
<title>How to implement Drag and Drop from React to SVG (d3)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何实现从React到SVG (d3)的拖放</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-implement-drag-and-drop-from-react-to-svg-d3-16700f01470c?source=collection_archive---------1-----------------------#2020-09-08">https://javascript.plainenglish.io/how-to-implement-drag-and-drop-from-react-to-svg-d3-16700f01470c?source=collection_archive---------1-----------------------#2020-09-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="8fdd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当创建拓扑构建器(或任何类型的基于一组绘制在一个画布上的节点的图形/布局)时，最常见的操作之一是从构建块列表中拖动一个节点，并将其放到该画布上。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/4a772679b14e073e1ef12c7cd764d381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*itYO1BQ1hYNub9lqgcuNzA.gif"/></div></figure><p id="c5a7" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们可以将一个节点拖放到画布上，它将基于拖放的[x，y]位置进行绘制，或者我们可以将它拖放到一个特定的拖放点，甚至是另一个节点的内部。</p><p id="533f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我过去已经实现过几次这样的系统，并且总是需要构建块(我拖到画布中的节点列表)是常规的HTML节点而不是SVG。主要原因是我希望他们成为应用程序框架的一部分，能够与应用程序本身进行交互。例如，它们是从我的模型中已经有的一些列表中生成的，在节点上有更多的操作(比如settings\edit ),或者它们需要像DOM一样工作(比如，因为屏幕尺寸或者监听一些DOM事件而改变布局)等等。</p><p id="6fb8" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在SVG中定义拖放关系非常简单，在HTML中定义拖放关系也非常简单。然而，将两者结合起来有点棘手。</p><p id="3124" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将演示如何使用React和D3实现这一点，我假设您对这两者都有些熟悉。</p><h2 id="d105" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">可拖动组件</h2><p id="f1b9" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">我们将从定义可拖动组件开始。Draggable组件可以包装任何组件，并为其添加拖放功能。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="c943" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每个可拖动对象都有一个拖动对象。拖动对象是与我们正在包装的块相关的数据。例如，如果我从雇员列表中创建拖动对象(无聊的例子，我知道…)，那么拖动对象将是雇员数据。根据这些数据，我们将绘制图块。假设我们画了一个圈，圈里有员工的名字，还有一个代表她所属部门的图标。</p><p id="c992" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在我们的例子中，拖动对象将有一个名称和一种颜色。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lt"><img src="../Images/10c584498c52202a346ca21b903f03a6.png" data-original-src="https://miro.medium.com/v2/resize:fit:372/format:webp/1*1OC1Nz8DdB3wqaI1wjGhxg.png"/></div></figure><p id="1a75" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">除了拖动对象，我们还想保存鼠标光标从拖动对象边缘的偏移量。从截图中可以看出，当您抓取一个对象并开始拖动它时，光标就在被拖动组件的内部。当我们将它放下时，我们将需要被拖动对象的左上角的坐标。但是，拖动事件总是与鼠标位置相关，而与拖动对象位置无关。我们将计算这个偏移量，并在以后使用它来计算正确的落点。</p><p id="fe85" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">为了计算偏移量，我们将首先使用当前目标的<em class="lu"> getBoundingClientRect </em>。我们将简单地从事件当前X位置- <em class="lu"> e.clientX </em>减少左边，从当前Y位置- <em class="lu"> e.clientY </em>减少上面。</p><p id="eaf9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，如果您在该块上有余量，您将需要从计算中减少余量大小(例如<em class="lu">e . clientx-currenttargetrect . left-5</em>)</p><p id="d3bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对于拖动包装器，我们将定义两个事件处理程序:</p><p id="7f8a" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">onDragStart:</p><p id="a91c" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们开始拖动操作时运行。在这个回调中，我们希望保存我们的拖动数据。我们稍后将在拖放节点时使用这些拖动数据，这样我们就可以正确地绘制它。<br/>拖动数据将由我们上面描述的拖动对象和偏移量组成。数据将由我们传递的处理程序onDragStart保存，我们在方法结束时调用该处理程序。</p><p id="41eb" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">onDragEnd:</p><p id="9263" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在这个回调中，我们将简单地禁用传播来启用drop。我们还将为onDragEnd调用呼叫者的回拨。</p><h2 id="3452" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">可拖动的积木</h2><p id="bbaf" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">我们将定义一个要拖动的块列表，并为每个块使用可拖动的包装器。我们将为每个块提供颜色和文本(例如拖动对象):</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="4b16" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">正如你所看到的，DraggableBlocks只是一个可拖动组件的列表。我们使用一个数据块列表，并对其进行迭代以呈现数据块。每个可拖动对象映射到数据列表中的一个可拖动对象。</p><p id="0f2e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意，在真实的系统中，这个数据列表可能来自API或配置。</p><p id="7054" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我们对onDragStart的回调将只调用我们得到的setDragObject回调。这个回调将确保保存拖动对象，以便我们以后在拖放时可以使用它。</p><h2 id="ffa7" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">保存拖动数据</h2><p id="5f44" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">在一个真实的系统中，我们可能会使用一些模型来保存我们的数据。可以是Mobx，Redux，也可以是你选择的任何其他型号。</p><p id="6074" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">出于这个例子的考虑，我将通过直接保存在App.js状态来简化事情。我将使用适当的回调函数在组件树上“冒泡”它，并最终将它保存在主应用程序组件上。</p><p id="7fbe" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">然后，拖动数据将被传递到SVG容器，这样当一个被拖动的组件被放到SVG容器中时，它可以获得正确的放置信息。</p><p id="350f" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">App.js组件如下所示:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><h2 id="bf33" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">SVG组件</h2><p id="b4dc" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">现在让我们添加我们的SVG容器。我们稍后将希望能够将这些块放到SVG容器中，并让SVG在它被放下的地方准确地绘制这些块。</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="5230" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">SVG是我们的降落区。我们将定义一些拖放回调来处理拖放操作。目前，当一个被拖动的对象被拖动到SVG (onDragOver)上时，我们将在SVG容器上添加\移除一个“drag-over”类，当块退出SVG容器(onDragLeave)或被放下(onDrop)时，我们将移除它。</p><p id="7f30" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在本例中，该类将在SVG容器中添加\移除红色虚线边框。通常，这是用来给用户一些关于放置点有效性的反馈。它可以是边框颜色、容器颜色，甚至是添加一些文本“放在这里”。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi lv"><img src="../Images/729a9471910e28cde97d4376fd61b858.png" data-original-src="https://miro.medium.com/v2/resize:fit:864/1*tEKA-yV5FIen-lcBShOZvA.gif"/></div></figure><h2 id="f4dc" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">放下拖动的组件</h2><p id="ae31" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">为了实现“drop ”,我们需要首先获取拖动数据，计算它的新位置，然后将其添加到节点列表中。稍后我将展示我们如何获取这个节点列表并绘制它。</p><p id="38e0" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">让我们看看onDrop:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="83cd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">onDrop回调首先计算SVG上的新放置点。它使用一个助手方法将我们从事件中获得的DOM坐标转换成SVG坐标。我们需要这样做的原因是SVG有一个不同于DOM的坐标系。此外，SVG可以放大和缩小(我在这个例子中没有实现它，但它通常是我们想要添加到绘图中的一个功能)，并且可以“滚动”——以画布本身的拖动方式从一边移动到另一边。</p><p id="0395" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我不会详细说明convertCoordinatesDOMtoSVG，我只是补充说，如果我们的SVG中有一个容器是可滚动\可缩放的容器，我们将需要更改</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="60ae" class="kt ku iq lx b gy mb mc l md me">return pt.matrixTransform(svg.node().getScreenCTM().inverse());</span></pre><p id="402e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">到</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="58de" class="kt ku iq lx b gy mb mc l md me">return pt.matrixTransform(container.node().getScreenCTM().inverse());</span></pre><p id="a3e1" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">onDrop要做的第二件事是将新节点的信息添加到节点列表中，包括生成的id(在真实的应用程序中，我们可能会使用一些实用程序来创建唯一的UUID)、拖动数据和我们刚刚计算的新位置。</p><p id="35bc" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">节点列表是什么？</p><p id="ae55" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">节点列表只是一个数组，包含我们在SVG容器中删除的所有节点。</p><p id="4d62" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">在一个真正的应用程序中，我们可能会从一个API中获得一些节点的初始列表，并有一些节点的初始绘图，拖动新节点只是为了扩展这个图形\图表。</p><p id="b26d" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">现在我们有了关于节点的所有正确信息，我们可以画出它们了。为了在SVG上绘制节点，我使用了另一个名为SVGDrawer的类。</p><pre class="km kn ko kp gt lw lx ly lz aw ma bi"><span id="5fe6" class="kt ku iq lx b gy mb mc l md me">SVGDrawer.draw(nodes)</span></pre><p id="59c4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">每次删除一个节点时，我都会调用这个方法。此外，您将在完整的示例中看到，我还将在初始加载时调用它来绘制列表中已经存在的节点——理论上我将从API中获取这些节点。</p><h2 id="4c66" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">绘制节点:</h2><p id="ab40" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">使用d3绘制节点。一旦我们有了坐标，这里就没有什么特别要做的了。</p><p id="b00e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是SVG抽屉:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="a91e" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">请注意这里enter的用法。当使用“join”时，第一个参数是对“enter”的回调，这意味着所有符合条件的新节点(选择+数据)，第二个参数是“update”，第三个参数是“exist”-delete。</p><p id="2ec9" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">当我们使用enter only时，这意味着这段代码将只在新的节点上运行，这意味着它不会重新绘制已经在列表中并且之前已经绘制过的节点。假设我已经在容器中放置了10个节点，现在我又添加了一个。“回车”只会在新添加的节点上运行，不会重画前10个节点。</p><p id="bfb2" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">这是SVGArea的最终版本:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="lr ls l"/></div></figure><p id="f1e4" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在这里看到我们简单地放了一个<svg>标签，所有的绘制都是在SVGDrawer类中完成的。注意，我从两个地方调用draw方法:onDrop和on initial load (useEffect用[]作为第二个参数)。</svg></p><h2 id="03ae" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">全部完成！</h2><p id="2f5b" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">至此，我们有了一个工作示例。我们可以拖放一个节点。被拖放的节点将被精确地绘制在其被拖放的位置。</p><figure class="km kn ko kp gt kq gh gi paragraph-image"><div class="gh gi kl"><img src="../Images/4a772679b14e073e1ef12c7cd764d381.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/1*itYO1BQ1hYNub9lqgcuNzA.gif"/></div></figure><h2 id="85fe" class="kt ku iq bd kv kw kx dn ky kz la dp lb jy lc ld le kc lf lg lh kg li lj lk ll bi translated">下一步是什么？</h2><p id="fb26" class="pw-post-body-paragraph jn jo iq jp b jq lm js jt ju ln jw jx jy lo ka kb kc lp ke kf kg lq ki kj kk ij bi translated">除了简单地在画布上添加一个节点之外，有时我们会希望将拖放的节点捕捉到网格中，或者允许将该节点拖放到现有节点中，或者只允许拖放到特定区域中。</p><p id="57dd" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">那么，我们如何检测到我们正在将一个节点拖到另一个节点上呢？如何才能只设置特定的投放点？</p><p id="ebb5" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">我将在下一篇文章中尝试涵盖这些场景。</p><p id="e730" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">你可以在我的Github repo <a class="ae mf" href="https://github.com/Kinnza/Drag-n-Drop-React-to-SVG-example" rel="noopener ugc nofollow" target="_blank">这里</a>或者CodeSandBox中找到完整的代码:</p><figure class="km kn ko kp gt kq"><div class="bz fp l di"><div class="mg ls l"/></div></figure></div></div>    
</body>
</html>