<html>
<head>
<title>30-Day LeetCoding Challenge In JavaScript: Week 1</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">30天的JavaScript leet coding挑战:第1周</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/30-day-leetcoding-challenge-in-javascript-week-1-a67e10fb?source=collection_archive---------5-----------------------#2020-04-18">https://javascript.plainenglish.io/30-day-leetcoding-challenge-in-javascript-week-1-a67e10fb?source=collection_archive---------5-----------------------#2020-04-18</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div class="gh gi jk"><img src="../Images/8c1f705cb6226118225897e071ee4bc3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1000/format:webp/0*SWOk6LWIbav_5kas.png"/></div></figure><p id="2ba6" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">整个四月，LeetCode决定举办一项名为30天leet code挑战赛的活动。在活动期间，他们将每24小时发布一个问题，每个问题都要在其发布的24小时内解决。</p><p id="684d" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我决定分享我对这些问题的解决方案，并提供这些问题背后的直觉。问题将按照发布的顺序列出。</p></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="5c01" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">单号(4月1日)</h1><blockquote class="lu lv lw"><p id="2f6b" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">给定一个<strong class="jt io">非空的</strong>整数数组，每个元素出现<em class="in">两次</em>，只有一个除外。找到那个单身的。</p><p id="57e5" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">注:</strong></p><p id="cc64" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">你的算法应该有一个线性的运行时间复杂度。你能不使用额外的内存来实现它吗？</p><p id="8072" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">例1: </strong></p><p id="09de" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">输入:</strong>【2，2，1】<br/><strong class="jt io">输出:</strong> 1</p><p id="360f" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">例2: </strong></p><p id="e061" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">输入:</strong>【4，1，2，1，2】<br/><strong class="jt io">输出:</strong> 4</p></blockquote><h2 id="3389" class="mb kx in bd ky mc md dn lc me mf dp lg kc mg mh lk kg mi mj lo kk mk ml ls mm bi translated">最初的直觉</h2><p id="3876" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">我们首先应该注意到没有空间方面的限制。这意味着最初的解决方案可能是使用一个<code class="fe ms mt mu mv b">Map</code>来构造一个计数器，其中每个唯一值都是一个键，并且该值将是该键值在数组中出现的次数。</p><p id="8ec8" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一旦初始化了这个计数器，我们就可以遍历它的元素，寻找值为1的键。</p><p id="aea3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们上面描述的解决方案将给我们<code class="fe ms mt mu mv b">O(n)</code>时间复杂度和<code class="fe ms mt mu mv b">O(n)</code>空间复杂度。</p><p id="5659" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然而，注释建议我们尝试在没有额外内存的情况下实现这个问题的解决方案。</p><h2 id="bf62" class="mb kx in bd ky mc md dn lc me mf dp lg kc mg mh lk kg mi mj lo kk mk ml ls mm bi translated">最优解的解释</h2><p id="9ff1" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">我们应该考虑到，除了一个数字之外，每个元素都有一个对，并且如果数组非空，总会有一个答案。</p><p id="d538" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为此，我们可以利用位操作。使用XOR运算符，我们知道<code class="fe ms mt mu mv b">a ^ a = 0</code>。我们还知道，对于任意值<code class="fe ms mt mu mv b">a</code>的<code class="fe ms mt mu mv b">a ^ 0 = a</code>，使得<code class="fe ms mt mu mv b">a &gt; 0</code>。此外，我们链接这些运算的顺序并不重要，因为可以证明XOR是可交换的和结合的。所以像<code class="fe ms mt mu mv b">a ^ b ^ a</code>这样的语句，总会给我们<code class="fe ms mt mu mv b">b</code>。因此，对于像<code class="fe ms mt mu mv b">[2, 2, 1]</code>这样的测试用例，如果我们要在整个数组中执行XOR运算，这样我们就有了<code class="fe ms mt mu mv b">2 ^ 2 ^ 1</code>，我们可以看到我们获得了所需的值<code class="fe ms mt mu mv b">1</code>，这是唯一没有重复的元素。</p><p id="faf4" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后，我们可以对传递给函数的整数数组执行归约操作，并对运行值和当前值执行异或操作。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Optimal Solution using Bit Manipulation</figcaption></figure></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="1aef" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">快乐数字(4月2日)</h1><blockquote class="lu lv lw"><p id="0548" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">写一个算法，判断一个数字<code class="fe ms mt mu mv b">n</code>是否“快乐”。</p><p id="cb1c" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">快乐数字是由以下过程定义的数字:从任何正整数开始，用其数字的平方和替换该数字，并重复该过程，直到该数字等于1(它将停留在该位置)，或者它<strong class="jt io">在不包括1的周期</strong>中无限循环。这个过程<strong class="jt io">以1 </strong>结束的那些数字是快乐数字。</p><p id="a33c" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">如果<code class="fe ms mt mu mv b">n</code>是一个快乐的数字，则返回True，否则返回False。</p></blockquote><h2 id="7231" class="mb kx in bd ky mc md dn lc me mf dp lg kc mg mh lk kg mi mj lo kk mk ml ls mm bi translated">说明</h2><p id="5883" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">这个问题本身很简单。给定某个整数<code class="fe ms mt mu mv b">n</code>，我们对每个数字的平方求和，如果结果是1，我们返回true。否则我们会无休止地循环下去(或者我是这样认为的)。</p><p id="c03e" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">这个问题最让人困惑的是，是否可以假设总有答案。事实是这不是真的。我最初实现一个解决方案是基于这样的假设，即总会有一个解决方案，并且我遇到了超过<em class="lx">时间限制的</em>错误。</p><p id="b2ba" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了弥补我们不被允许实际上无限循环的事实，我使用了一个<code class="fe ms mt mu mv b">Set</code>来跟踪我们已经看到的数字。如果算法遇到一个它已经见过的数字，那么我们就跳出循环，确定我们已经见过的数字是1还是其他数字。当然，如果数字为1，我们返回true，否则返回false。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Solution for Happy Number</figcaption></figure></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="2f4d" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">最大子阵列(4月3日)</h1><blockquote class="lu lv lw"><p id="8e18" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">给定一个整数数组<code class="fe ms mt mu mv b">nums</code>，找出具有最大和的连续子数组(至少包含一个数)并返回其和。</p><p id="d117" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">示例:</strong></p><p id="561c" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">输入:</strong> [-2，1，-3，4，-1，2，1，-5，4]，<br/> <strong class="jt io">输出:</strong> 6 <br/> <strong class="jt io">解释:</strong>【4，-1，2，1】求和最大= 6。</p><p id="8e84" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">跟进:</strong></p><p id="361e" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">如果你已经找到了O( <em class="in"> n </em>)的解决方案，试着用分而治之的方法编写另一个解决方案，这更微妙。</p></blockquote><h2 id="baf3" class="mb kx in bd ky mc md dn lc me mf dp lg kc mg mh lk kg mi mj lo kk mk ml ls mm bi translated">说明</h2><p id="5b9b" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">这是一个我已经解决过无数次的问题，因为它在编码面试中经常出现。我所知道的这个问题的<code class="fe ms mt mu mv b">O(n)</code>解决方案叫做<em class="lx">卡丹算法。</em></p><p id="ba27" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">该算法的基本思想是跟踪两个最大值:局部最大值和全局最大值。局部最大值的思想是，在数组的每次迭代中，最大值要么是我们正在累加的当前运行总和加上我们已经迭代过的当前元素，要么是当前元素本身。全局最大值只是初始全局最大值或局部最大值之间的最大值。</p><p id="b6f0" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">为了对此有所了解，让我们假设我们有以下数组:<code class="fe ms mt mu mv b">[-1, -2, 1]</code></p><blockquote class="lu lv lw"><p id="8669" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">迭代前，假设局部最大值和全局最大值是数组的第一个元素，</strong> <code class="fe ms mt mu mv b"><strong class="jt io">-1</strong></code></p><p id="1225" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">然后在迭代1(值为-2): </strong></p><p id="01a3" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">局部最大值=最大值(-2，-1±2)=-2</p><p id="5fd3" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">全局最大值=最大值(-1，-2) = -1</p><p id="4ad3" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">迭代2时(值为1): </strong></p><p id="c431" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">局部最大值=最大值(1，-2 + 1) = 1</p><p id="d6d3" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">全局最大值=最大值(-1，1) = 1</p><p id="7622" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">然后我们返回1作为我们的最大值</strong></p></blockquote><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="e713" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">移动零(4月4日)</h1><blockquote class="lu lv lw"><p id="7b76" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">给定一个数组<code class="fe ms mt mu mv b">nums</code>，写一个函数将所有的<code class="fe ms mt mu mv b">0</code>移动到它的末尾，同时保持非零元素的相对顺序。</p><p id="cb8e" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">例:</strong></p><p id="a870" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">输入:</strong>T4<br/><strong class="jt io">输出:</strong>T5】</p><p id="0ab9" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">注</strong>:</p><p id="b6ba" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">您必须在不复制数组的情况下就地执行<strong class="jt io"/>。</p><p id="d0e8" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">最小化操作总数。</p></blockquote><h2 id="9b15" class="mb kx in bd ky mc md dn lc me mf dp lg kc mg mh lk kg mi mj lo kk mk ml ls mm bi translated">说明</h2><p id="7122" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">这个问题的关键是要有一个指针，只有当你遇到非零值时，这个指针才会递增。</p><p id="ef48" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">假设我们称这个指针为<code class="fe ms mt mu mv b">j</code>。当我们迭代数组时，每当我们遇到非零值时，我们设置<code class="fe ms mt mu mv b">nums[j] = nums[i]</code>然后递增<code class="fe ms mt mu mv b">j</code>。否则，我们什么也不做。</p><p id="6e04" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">一旦我们完成了初始迭代，我们就从<code class="fe ms mt mu mv b">j</code>迭代到数组的末尾，并将每个值设置为0。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="393b" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">买卖股票II的最佳时间(4月5日)</h1><blockquote class="lu lv lw"><p id="504e" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">假设您有一个数组<code class="fe ms mt mu mv b">prices</code>，对于该数组<em class="in"> i </em>元素是给定股票在第<em class="in"> i </em>天的价格。</p><p id="c51c" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">设计一个算法来寻找最大利润。您可以完成任意多的交易(即多次买入并卖出一股股票)。</p><p id="b827" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">注意:</strong>您不得同时进行多项交易(即必须先卖出后再买入)。</p></blockquote><h2 id="6ba6" class="mb kx in bd ky mc md dn lc me mf dp lg kc mg mh lk kg mi mj lo kk mk ml ls mm bi translated">说明</h2><p id="6174" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">对于这个问题，在计算最大利润方面，我采用了贪婪策略。每当我们达到某个指数<code class="fe ms mt mu mv b">i</code>的某个价格<code class="fe ms mt mu mv b">prices[i]</code>时，我们会检查之前的指数，看它是否低于当前指数的价格，然后我们将它们的差额添加到我们的利润中。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="594a" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">分组字谜(4月6日)</h1><blockquote class="lu lv lw"><p id="fbbe" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">给定一个字符串数组，将变位组合在一起。</p><p id="2ec3" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">示例:</strong></p><p id="248d" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">输入:</strong> <code class="fe ms mt mu mv b">["eat", "tea", "tan", "ate", "nat", "bat"]</code>，<br/> <strong class="jt io">输出:</strong> <br/> <code class="fe ms mt mu mv b">[<br/> ["ate","eat","tea"],<br/> ["nat","tan"],<br/> ["bat"]<br/>]</code></p><p id="28e1" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><strong class="jt io">注:</strong></p><p id="6eb3" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">所有输入都将是小写。</p><p id="3aaa" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">输出的顺序并不重要。</p></blockquote><h2 id="1259" class="mb kx in bd ky mc md dn lc me mf dp lg kc mg mh lk kg mi mj lo kk mk ml ls mm bi translated">说明</h2><p id="180f" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">这个问题没有太大的难度。解决这个问题需要一种强力的方法。为了将这些值组合在一起，我们可以使用一个映射，其中键是数组中唯一排序的字符串，值是一个字符串数组，其中每个字符串都是键的变位词。</p><p id="6ba3" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">对于数组中的每个字符串，我们都制作了一个排序后的副本。然后，我们检查排序后的副本是否已经在地图中。如果是，那么我们将原始字符串放入数组中的那个键。否则，我们必须将包含原始字符串的数组插入到映射中，并将排序后的字符串作为键。</p><p id="156c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">然后，我们将创建的地图的值作为数组返回。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl kp kq hr kr" role="separator"><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku kv"/><span class="ks bw bk kt ku"/></div><div class="ig ih ii ij ik"><h1 id="b403" class="kw kx in bd ky kz la lb lc ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt bi translated">计数元素(4月7日)</h1><blockquote class="lu lv lw"><p id="8ccf" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated">给定一个整数数组<code class="fe ms mt mu mv b">arr</code>，计算元素<code class="fe ms mt mu mv b">x</code>，使得<code class="fe ms mt mu mv b">x + 1</code>也在<code class="fe ms mt mu mv b">arr</code>中。</p><p id="1a07" class="jr js lx jt b ju jv jw jx jy jz ka kb ly kd ke kf lz kh ki kj ma kl km kn ko ig bi translated"><code class="fe ms mt mu mv b">arr</code>中如有重复，单独统计。</p></blockquote><h2 id="769e" class="mb kx in bd ky mc md dn lc me mf dp lg kc mg mh lk kg mi mj lo kk mk ml ls mm bi translated">说明</h2><p id="fac1" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">这个问题依赖于对<code class="fe ms mt mu mv b">arr</code>中的值进行跟踪。一旦我们初始化了我们的集合，我们再次迭代数组，检查集合中是否存在<code class="fe ms mt mu mv b">x+1</code>。如果值确实存在，我们增加一些计数器。</p><figure class="mw mx my mz gt jo"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="cb80" class="mb kx in bd ky mc md dn lc me mf dp lg kc mg mh lk kg mi mj lo kk mk ml ls mm bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="9a36" class="pw-post-body-paragraph jr js in jt b ju mn jw jx jy mo ka kb kc mp ke kf kg mq ki kj kk mr km kn ko ig bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae ng" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="jt io">AI in Plain English</strong></a>，<a class="ae ng" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="jt io">UX in Plain English</strong></a>，<a class="ae ng" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="jt io">Python in Plain English</strong></a><strong class="jt io"/>——谢谢，继续学习！</p><p id="a03c" class="pw-post-body-paragraph jr js in jt b ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko ig bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae ng" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="jt io">submissions @ plain English . io</strong></a><strong class="jt io"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>