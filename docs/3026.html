<html>
<head>
<title>Node.js Tips — Global Objects, Synchronous Requests, Shared Code for Tests</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js提示——全局对象、同步请求、测试的共享代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-tips-global-objects-synchronous-requests-shared-code-for-tests-153191d91c2d?source=collection_archive---------3-----------------------#2020-08-20">https://javascript.plainenglish.io/node-js-tips-global-objects-synchronous-requests-shared-code-for-tests-153191d91c2d?source=collection_archive---------3-----------------------#2020-08-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/61578ba0028b5b1bc813394efe6ca20f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*5d_wX8YuLb6GxNR_"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@riccardogiorato?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">riccardo giorato</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6928" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像任何类型的应用程序一样，当我们编写节点应用程序时，有一些困难的问题需要解决。</p><p id="96a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将研究一些编写节点应用程序时常见问题的解决方案。</p><h1 id="d4bd" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">Node.js中的同步请求</h1><p id="817a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">sync-request</code>包在节点应用程序中发出同步请求。</p><p id="6bf3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="b684" class="mq lc iq mh b gy mr ms l mt mu">const request = require('sync-request');</span><span id="b71c" class="mq lc iq mh b gy mv ms l mt mu">try {<br/>  const res1 = request('GET', '/yrl1');<br/>  const res2 = request('GET', '/url2');<br/>  //...<br/>} <br/>catch (e) {<br/>  //...<br/>}</span></pre><p id="0ce1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们导入<code class="fe me mf mg mh b">sync-request</code>包并使用它的<code class="fe me mf mg mh b">request</code>函数同步发出请求。</p><p id="098b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，像往常一样，同步代码是阻塞的，所以不应该在生产应用程序中使用。</p><p id="73f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，可能对脚本有好处。</p><h1 id="e55c" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">获取一个MongoDB数据库的模式，该数据库是用Mongoose在另一个模型中定义的</h1><p id="7f7c" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">model</code>方法得到Mongoose模式。</p><p id="94f9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="c7bc" class="mq lc iq mh b gy mr ms l mt mu">const PersonSchema = require('mongoose').model('person').schema</span></pre><p id="c7b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为<code class="fe me mf mg mh b">person</code>集合获取Mongoose模式。</p><h1 id="2ea7" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">检测Node.js或浏览器环境</h1><p id="b0a0" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了检查一段代码是在Node中运行还是在浏览器中运行，我们可以检查<code class="fe me mf mg mh b">window</code>对象是否存在。</p><p id="3d2d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果是，那么我们知道它正在浏览器中运行。</p><p id="0eea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，它在Node中运行。</p><p id="eebb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8d68" class="mq lc iq mh b gy mr ms l mt mu">const app = window ? window : global;</span></pre><p id="3f65" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">以获得相应平台的全局变量。</p><p id="ecc9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">window</code>是浏览器的全局对象。</p><p id="a8aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">global</code>是节点的全局对象。</p><h1 id="be4a" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">readFile和readFileSync的区别</h1><p id="62a7" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">fs.readFile</code>接受回调并异步读取文件。</p><p id="bd4a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论何时完成，回调函数都会被调用并给出结果。</p><p id="cdb8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">同步读取文件，并在完成后返回文件内容。</p><p id="fd46" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该在大多数应用程序中使用<code class="fe me mf mg mh b">readFile</code>,因为它不会阻止应用程序的其他部分运行。</p><p id="f73a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，<code class="fe me mf mg mh b">readFileSync</code>适用于除了脚本中的代码之外，我们不运行任何其他东西的脚本。</p><h1 id="0968" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">如何在Express.js应用程序中检测环境</h1><p id="b320" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">app.get</code>方法来获取Express应用程序中的环境变量。</p><p id="9055" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="d107" class="mq lc iq mh b gy mr ms l mt mu">app.get('env')</span></pre><p id="845d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">获取环境变量。</p><p id="cb7b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="6e05" class="mq lc iq mh b gy mr ms l mt mu">if (app.get('env') === 'development') {<br/>  //...<br/>}</span></pre><p id="d819" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">检查应用程序是否在<code class="fe me mf mg mh b">'development'</code>环境中运行。</p><h1 id="8006" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">解析Express中的表单数据请求有效负载</h1><p id="1720" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">body-parser</code>包让我们可以解析Express中的请求负载。</p><p id="16bd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="3fd2" class="mq lc iq mh b gy mr ms l mt mu">const bodyParser = require('body-parser');<br/>app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded());<br/><br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="de06" class="mq lc iq mh b gy mv ms l mt mu">app.post('/post',(req, res) =&gt; {<br/>  console.log(req.body) <br/>})</span></pre><p id="06b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们需要<code class="fe me mf mg mh b">body-parser</code>，这样我们就可以调用<code class="fe me mf mg mh b">json</code>方法来解析JSON。</p><p id="9c3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们调用<code class="fe me mf mg mh b">urlencoded</code>以便它可以解析表单数据有效载荷。</p><p id="12be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">extended</code>意味着我们可以解析嵌套在表单数据请求中的JSON。</p><p id="f90f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么解析后的请求负载将在<code class="fe me mf mg mh b">req.body</code>中可用。</p><p id="3103" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，我们可以使用<code class="fe me mf mg mh b">express-formidable</code>中间件来做同样的事情。</p><p id="6c8e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过运行以下命令来安装它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ea9e" class="mq lc iq mh b gy mr ms l mt mu">npm install express-formidable</span></pre><p id="0e41" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以通过写来使用它:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="dbac" class="mq lc iq mh b gy mr ms l mt mu">const express = require('express');<br/>const formidable = require('express-formidable');</span><span id="d616" class="mq lc iq mh b gy mv ms l mt mu">const app = express();</span><span id="3737" class="mq lc iq mh b gy mv ms l mt mu">app.use(formidable());</span><span id="de42" class="mq lc iq mh b gy mv ms l mt mu">app.post('/upload', (req, res) =&gt; {<br/>  res.send(JSON.stringify(req.fields));<br/>});</span></pre><p id="e137" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们只是传入了<code class="fe me mf mg mh b">formidable</code>中间件。</p><p id="72bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们用<code class="fe me mf mg mh b">req.fields</code>对象获得解析后的请求负载。</p><h1 id="4378" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">按顺序运行异步Mocha共享测试代码</h1><p id="0e5b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以通过使用<code class="fe me mf mg mh b">before</code>钩子来运行多个测试之间共享的代码，从而按顺序运行异步Mocha测试。</p><p id="1249" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="8321" class="mq lc iq mh b gy mr ms l mt mu">let someCondition = false;<br/>//...</span><span id="33e5" class="mq lc iq mh b gy mv ms l mt mu">describe('is dependent on someCondition', () =&gt; {<br/>  const beforeTest = (done) =&gt; {<br/>    if (someCondition) {<br/>      done();<br/>    }<br/>    else {<br/>      setTimeout(() =&gt; beforeTest(done), 1000);<br/>    }<br/>  }</span><span id="9065" class="mq lc iq mh b gy mv ms l mt mu">  before((done) =&gt; {<br/>    beforeTest(done);<br/>  });</span><span id="85f8" class="mq lc iq mh b gy mv ms l mt mu">  it('does something', () =&gt; { <br/>    // ...<br/>  });</span><span id="fb2f" class="mq lc iq mh b gy mv ms l mt mu">})</span></pre><p id="bd79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在使用<code class="fe me mf mg mh b">beforeTest</code>函数运行测试之前，我们检查是否满足<code class="fe me mf mg mh b">someCondition</code>。</p><p id="9b30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，我们1秒后再调用<code class="fe me mf mg mh b">beforeTest</code>。</p><p id="3698" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们这样做，直到<code class="fe me mf mg mh b">someCondition</code>是<code class="fe me mf mg mh b">true</code>。</p><p id="c94e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将<code class="fe me mf mg mh b">done</code>传递给<code class="fe me mf mg mh b">beforeTest</code>函数，这样我们就可以在<code class="fe me mf mg mh b">someConditional</code>最终变成<code class="fe me mf mg mh b">true</code>时调用它。</p><p id="be2c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦<code class="fe me mf mg mh b">done</code>被调用，测试将会运行。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/13e26c30e7d59ec14d3d6b4b92776986.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*wK0zC62tmzis7z_q"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@rogozin?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aleksandr Rogozin</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="a108" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="cb29" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以在运行测试之前运行一些检查，并在运行测试之前等待条件变为真。</p><p id="42ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">sync-request</code>包来运行同步请求。</p><p id="12bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，它阻塞了应用程序的其余部分，所以它应该只在脚本中使用。</p><p id="ddcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过检查哪个全局对象可用来检测一段代码运行的平台。</p><h2 id="ada7" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated"><strong class="ak">简单英语的JavaScript</strong></h2><p id="3e0e" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>