<html>
<head>
<title>The Basics of JavaScript Generators</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript生成器的基础知识</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/the-basics-of-javascript-generators-f89c9b0e8d72?source=collection_archive---------0-----------------------#2019-05-17">https://javascript.plainenglish.io/the-basics-of-javascript-generators-f89c9b0e8d72?source=collection_archive---------0-----------------------#2019-05-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5665" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">快速浏览ES6的最佳功能之一</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/77bd054c5e31245cd5026bbed339bafe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*PjyveyhJAySMOZd5"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="af17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">ES6生成器函数是那些可以在中间停止执行并从同一点继续执行的函数。这些函数不返回单个值；相反，它们能够返回多个值。它们基于迭代器的概念。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="055b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">没有发电机功能的生活</h1><p id="9a12" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">下面是一个没有生成器的简单函数。普通的JavaScript函数一被调用就开始执行。这些函数在任何其他代码执行之前运行完成。</p><p id="9463" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们通常认为<strong class="ky ir"> </strong>函数会在其他JavaScript函数运行之前完成执行。一个正常的函数开始执行，只有当执行完成时才暂停。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="f151" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">函数可以在下列情况之一中停止执行:</p><ol class=""><li id="dbb2" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">编译器到达函数的末尾。</li><li id="5eaf" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">它遇到了<code class="fe nm nn no np b">return</code>关键字。</li><li id="5ce0" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">该函数抛出错误或异常。</li></ol></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="890b" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">发电机:我们不一样！</h1><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nq"><img src="../Images/f05c34868e8d542c3676e7071bf33473.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H69bu3hU86xfwe5j"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@cinn?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Cinn</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="00af" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在生成器的情况下，这些函数能够返回多个值，并且它们可能不会完全执行。功能执行可以部分触发。它可以在中间停止执行并继续另一个任务，过一会儿，从它停止的地方继续执行该功能。在我们继续之前，让我们看一个生成器的基本例子。</p><p id="bf24" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">生成器函数可以暂停并恢复一次或多次，这使得它们很有趣，并且与普通函数非常不同。当函数暂停时，它允许其他函数和代码执行。默认情况下，生成器是异步的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="3482" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上面的代码包含一个简单的生成器实现。当调用生成器时，它返回一个<em class="nr">迭代器</em>。<code class="fe nm nn no np b">function</code>关键字后的<code class="fe nm nn no np b"><strong class="ky ir">*</strong></code> <strong class="ky ir"> </strong>表示它是一个生成器，迭代器从函数返回。这个迭代器不会自己获取结果。它需要从外部触发。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="2020" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">发电机:告诉我什么时候可以开始</h1><p id="0a6a" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">一旦迭代器被创建，我们需要触发这个迭代器从生成器获取数据。我们可以通过在返回的迭代器上调用<code class="fe nm nn no np b">next</code> <strong class="ky ir"> </strong>方法<strong class="ky ir"> </strong>来从生成器函数中检索值，从而继续执行函数。每次在迭代器上调用<code class="fe nm nn no np b">next()</code>函数时，它都会执行该函数，直到到达下一个<code class="fe nm nn no np b">yield</code>关键字。在每个<code class="fe nm nn no np b">yield</code>之后，它停止进一步处理。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="1ad4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦执行停止，我们需要在迭代器上重新触发<code class="fe nm nn no np b">next</code>函数。当迭代器上的<code class="fe nm nn no np b">next</code>函数被触发时，它继续执行，直到遇到下一个<code class="fe nm nn no np b">yield</code>，并给出<code class="fe nm nn no np b">2</code>作为输出。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="b010" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">发电机:不要告诉我停止</h1><p id="24d8" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">ES6发电机功能不能从外部中断。除非在执行过程中遇到<code class="fe nm nn no np b">yield</code>，否则不能停止发电机。如果生成器函数不包含任何<code class="fe nm nn no np b">yield</code>关键字，它将像一个正常函数一样执行到完成。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9982" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated">从生成器中获取值</h1><p id="8521" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">在下面的程序中，当在返回的迭代器上遇到<code class="fe nm nn no np b">next()</code>时，它继续执行生成器函数。它开始执行该功能，并在遇到第一个<code class="fe nm nn no np b">yield</code>时在第3行停止。<code class="fe nm nn no np b">yield</code>关键字可以向调用的<code class="fe nm nn no np b">next()</code>函数返回值。在这种情况下，第一个<code class="fe nm nn no np b">yield</code>关键字将返回一个值<code class="fe nm nn no np b">1</code>以及表示生成器执行是否完成的标志。</p><p id="3daf" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于生成器仍未完成，它将返回标志值<code class="fe nm nn no np b">done</code>作为<code class="fe nm nn no np b">false</code>。<code class="fe nm nn no np b">yield</code>返回包含<code class="fe nm nn no np b">value</code>和<code class="fe nm nn no np b">done</code>作为键的键/值对。</p><p id="3d53" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因此返回的输出是:<code class="fe nm nn no np b">{ value: 1, done: false }</code></p><p id="71a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe nm nn no np b">1</code>表示与<code class="fe nm nn no np b">yield</code>关键字成对出现的值，因为生成器可以生成更多的值，所以<code class="fe nm nn no np b">done</code>属性仍然为假。</p><p id="9e99" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在迭代器上可以多次调用<code class="fe nm nn no np b">next</code>函数，标志<code class="fe nm nn no np b">done </code>将指示生成器是否完成。一旦发生器完成执行，所有进一步的输出将显示<code class="fe nm nn no np b">done</code>标志的值为<code class="fe nm nn no np b">true</code>，字段<code class="fe nm nn no np b">value</code>为<code class="fe nm nn no np b">undefined</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="8d81" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">调用<code class="fe nm nn no np b">next</code>函数将恢复发生器的执行，直到下一个<code class="fe nm nn no np b">yield</code>可用。在第24行，所有的<code class="fe nm nn no np b">yield</code>关键字都用完了，所以在这种情况下，返回值将是<code class="fe nm nn no np b">undefined</code>(因为函数不返回任何东西)，并且<code class="fe nm nn no np b">done</code>标志设置为<code class="fe nm nn no np b">true</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="644a" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">在生成器</strong>中使用R  <code class="fe nm nn no np b"><strong class="ak">eturn</strong></code> <strong class="ak">关键字</strong></h1><p id="d712" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">一个生成器函数可以有一个<code class="fe nm nn no np b">return</code>语句。生成器函数一遇到<code class="fe nm nn no np b">return</code>关键字，就将<code class="fe nm nn no np b">done</code>标志更新为<code class="fe nm nn no np b">true</code>，即使我们在函数中有更多的<code class="fe nm nn no np b">yield</code>关键字，生成器也会被认为是完整的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="9b9a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">一旦<code class="fe nm nn no np b">return</code>关键字被执行，所有其他的<code class="fe nm nn no np b">yield</code>将返回<code class="fe nm nn no np b">undefined</code>并将<code class="fe nm nn no np b">done</code>标志设置为<code class="fe nm nn no np b">true</code>。</p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="9a52" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">将值传递给“下一个”函数</strong></h1><p id="bce1" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">我们已经看到，当我们向关键字<code class="fe nm nn no np b">yield</code>传递一个值时，它将该值返回给调用函数<code class="fe nm nn no np b">next</code>。但是，生成器支持双向通信。<code class="fe nm nn no np b">next</code>功能也可以将数据传递给生成器。</p><p id="5628" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在下面的代码中，您可以看到在第15行，我们将一个参数传递给了<code class="fe nm nn no np b">next</code>函数。现在让我们来理解这行代码是如何执行的。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure><p id="5c19" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">以下是第一次给<code class="fe nm nn no np b">next()</code>打电话时的事件:</p><ol class=""><li id="b5ee" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">当迭代器上第一次调用<code class="fe nm nn no np b">next</code>时，生成器开始执行。</li><li id="d8f9" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">生成器代码一直执行，直到遇到第一个<code class="fe nm nn no np b">yield</code>关键字。</li><li id="056e" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">它返回传递给<code class="fe nm nn no np b">yield</code>函数的内容。</li></ol><p id="7b41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:<code class="fe nm nn no np b">{ value: 1, done: false }</code></p><p id="6c8b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当<code class="fe nm nn no np b">next(10)</code>被调用时:</p><ol class=""><li id="0b6d" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">传递的参数代替了<code class="fe nm nn no np b">yield 1</code>。</li></ol><p id="5f84" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以实际上，生成器中的第3行变成了<code class="fe nm nn no np b">let x = 10</code>。</p><p id="7cc0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">2.它进一步执行该功能，直到遇到下一个<code class="fe nm nn no np b">yield</code>。</p><p id="52f1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.它用10替换<code class="fe nm nn no np b">x</code>的值，并返回结果值(10 +1)。</p><p id="b527" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:<code class="fe nm nn no np b">{ value: 11, done: false }</code></p><p id="b325" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在<code class="fe nm nn no np b">next()</code>的以下调用中:</p><ol class=""><li id="8d5c" class="my mz iq ky b kz la lc ld lf na lj nb ln nc lr nd ne nf ng bi translated">由于没有进一步的<code class="fe nm nn no np b">yield</code>关键字，它返回<code class="fe nm nn no np b">undefined</code>作为返回值。</li><li id="8897" class="my mz iq ky b kz nh lc ni lf nj lj nk ln nl lr nd ne nf ng bi translated">并且由于生成器已经完成，所以<code class="fe nm nn no np b">done</code>标志被设置为<code class="fe nm nn no np b">true</code>。</li></ol><p id="b0f3" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:<code class="fe nm nn no np b">{ value: undefined, done: false }</code></p></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><h1 id="04ce" class="lz ma iq bd mb mc md me mf mg mh mi mj jw mk jx ml jz mm ka mn kc mo kd mp mq bi translated"><strong class="ak">使用for … of循环</strong></h1><p id="94e7" class="pw-post-body-paragraph kw kx iq ky b kz mr jr lb lc ms ju le lf mt lh li lj mu ll lm ln mv lp lq lr ij bi translated">因为生成器函数返回迭代器，所以这些迭代器可以在<code class="fe nm nn no np b">for</code> … <code class="fe nm nn no np b"> of</code>循环中使用。迭代器将遍历生成器函数中的所有值。传递给<code class="fe nm nn no np b">yield</code>关键字的参数将作为一个值传递给迭代器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="mw mx l"/></div></figure></div><div class="ab cl ls lt hu lu" role="separator"><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx ly"/><span class="lv bw bk lw lx"/></div><div class="ij ik il im in"><p id="fba1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我希望您现在对使用生成器函数更加熟悉了。生成器很神奇，可以解决各种用例场景。尝试在您当前的应用程序中找到生成器会使事情变得更简单的场景。希望这篇文章对你有帮助！</p><p id="0bd7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="nr">更多内容请看</em><a class="ae kv" href="http://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"><em class="nr">plain English . io</em></a></p></div></div>    
</body>
</html>