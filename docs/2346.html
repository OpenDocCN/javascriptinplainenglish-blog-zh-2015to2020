<html>
<head>
<title>Node.js Basics — Streams, URLs, and Events</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Node.js基础——流、URL和事件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-basics-streams-urls-and-events-a5d2ef856ae1?source=collection_archive---------5-----------------------#2020-06-15">https://javascript.plainenglish.io/node-js-basics-streams-urls-and-events-a5d2ef856ae1?source=collection_archive---------5-----------------------#2020-06-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a15bd61d83979012319f72b0a9ed6839.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HE4Qp5ecRqTvsXxv"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@anniespratt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Annie Spratt</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="75f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript是世界上最流行的编程语言之一。为了有效地使用它，我们必须了解它的基础知识。</p><p id="c189" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解Node.js的基础知识，包括创建流。</p><h1 id="efa1" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">流</h1><p id="8bef" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">可写流在Node中的许多地方被使用。</p><p id="b7a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这些流是具有<code class="fe me mf mg mh b">write</code>方法的对象，可以通过字符串或<code class="fe me mf mg mh b">Buffer</code>对象向流中写入内容。</p><p id="8b79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">end</code>方法关闭流，并可选地在关闭前取一个值写入流。</p><p id="31e1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以从<code class="fe me mf mg mh b">fs</code>模块创建一个指向具有<code class="fe me mf mg mh b">createWriteStream</code>功能的文件的可写流。</p><p id="bfc7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">write</code>方法一次写一个文件，而不是像<code class="fe me mf mg mh b">writeFile</code>一样一次写完。</p><p id="c8b9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可读流可以从各种来源读取数据。</p><p id="fe70" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用事件处理程序读取数据。</p><p id="a80b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在节点中发出事件的对象有一个<code class="fe me mf mg mh b">on</code>方法来监听事件。</p><p id="364a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可读流发出<code class="fe me mf mg mh b">data</code>和<code class="fe me mf mg mh b">end</code>事件。</p><p id="33c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">data</code>每当数据进入时被触发，</p><p id="5389" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">end</code>在流结束时调用。</p><p id="305c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它适用于可以立即处理的流式数据。</p><p id="c1c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以将HTTP服务器发送的响应更改如下:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="acba" class="mq lc iq mh b gy mr ms l mt mu">const { createServer } = require("http");</span><span id="5929" class="mq lc iq mh b gy mv ms l mt mu">createServer((request, response) =&gt; {<br/>  response.writeHead(200, { "Content-Type": "text/plain" });<br/>  request.on("data", chunk =&gt;<br/>    response.write(chunk.toString().toLowerCase()));<br/>  request.on("end", () =&gt; response.end());<br/>}).listen(8000);</span></pre><p id="ddab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，如果我们用纯文本正文进行请求，则纯文本将被转换为小写。</p><p id="7bd5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是因为<code class="fe me mf mg mh b">chunk</code>有部分请求体，我们把它们写到读流中。</p><p id="e3a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">读取流以<code class="fe me mf mg mh b">end</code>事件的发射结束，我们结束响应。</p><h1 id="f6e5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">节点. js文件服务器</h1><p id="e12f" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">fs</code>模块和<code class="fe me mf mg mh b">url</code>模块从请求中解析路径，为我们的服务器提供文件。</p><p id="7eda" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="f7f0" class="mq lc iq mh b gy mr ms l mt mu">const http = require('http');<br/>const url = require('url');<br/>const fs = require('fs');</span><span id="0f3c" class="mq lc iq mh b gy mv ms l mt mu">http.createServer((req, res) =&gt; {<br/>  const q = url.parse(req.url, true);<br/>  const filename = `.${q.pathname}`;<br/>  fs.readFile(filename, (err, data) =&gt; {<br/>    if (err) {<br/>      res.writeHead(404, {'Content-Type': 'text/html'});<br/>      return res.end("404 Not Found");<br/>    } <br/>    res.writeHead(200, {'Content-Type': 'text/html'});<br/>    res.write(data);<br/>    return res.end();<br/>  });<br/>}).listen(8080);</span></pre><p id="9576" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们从文件名中获取文件的路径。</p><p id="a7e7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">url</code>模块有一个<code class="fe me mf mg mh b">parse</code>方法，通过<code class="fe me mf mg mh b">pathname</code>属性获取文件的路径。</p><p id="59ec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后使用<code class="fe me mf mg mh b">readFile</code>读取给定相对路径的文件。</p><p id="0aea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在回调中，如果文件存在，我们就编写它。</p><p id="ba24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有错误，我们会返回404响应。</p><p id="4cfd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以当我们向<code class="fe me mf mg mh b">http://localhost:8080/foo.txt</code>提出请求时，如果它存储在服务器上，我们会得到<code class="fe me mf mg mh b">foo.txt</code>的内容。</p><h1 id="29d5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">事件</h1><p id="64b3" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">events</code>模块发出并监听事件。</p><p id="dad0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="9976" class="mq lc iq mh b gy mr ms l mt mu">const events = require('events');<br/>const eventEmitter = new events.EventEmitter();</span></pre><p id="94bc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">创建一个新的<code class="fe me mf mg mh b">EventEmitter</code>对象。</p><p id="b701" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们可以使用<code class="fe me mf mg mh b">emit</code>方法来发出一个事件:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="7f8a" class="mq lc iq mh b gy mr ms l mt mu">eventEmitter.emit('hello');</span></pre><p id="432a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过书写来听:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="ea78" class="mq lc iq mh b gy mr ms l mt mu">eventEmitter.on('hello', () =&gt; {<br/>  console.log('got hello');<br/>});</span></pre><p id="a411" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以向事件发送数据。例如，我们可以写:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="bc1e" class="mq lc iq mh b gy mr ms l mt mu">eventEmitter.emit('hello', 'james');</span></pre><p id="b89c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后<code class="fe me mf mg mh b">'james'</code>就是我们的数据。</p><p id="c780" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们可以通过写下来获得数据:</p><pre class="mi mj mk ml gt mm mh mn mo aw mp bi"><span id="a6cf" class="mq lc iq mh b gy mr ms l mt mu">eventEmitter.on('hello', (data) =&gt; {<br/>  console.log(`hello ${data}`);<br/>});</span></pre><p id="4b0f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">data</code>有我们发送的数据。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/ec1c0e46c3e646f24999fdedc8bf2e00.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*HUhWo3Ac3pbRmZ63"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@freetousesoundscom?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Free To Use Sounds</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="14ff" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="be2a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">流是可以传递和读写的数据。</p><p id="b316" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可读流是可以成块读取数据的流。</p><p id="a9c8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可写流可以分块写入数据。</p><p id="6c6b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以使用<code class="fe me mf mg mh b">url</code>模块将URL解析成我们可以使用的东西。</p><p id="77a3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe me mf mg mh b">EventEmitter</code>构造函数可以用来创建事件发射器和监听事件。</p><h2 id="8a4a" class="mq lc iq bd ld mx my dn lh mz na dp ll ko nb nc lp ks nd ne lt kw nf ng lx nh bi translated">简单英语的JavaScript</h2><p id="a3e1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">喜欢这篇文章吗？如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的YouTube频道</strong> </a> <strong class="kf ir">获取更多类似内容！</strong></p></div></div>    
</body>
</html>