<html>
<head>
<title>How to Make Stunning Data Visualizations With D3.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用D3.js制作令人惊叹的数据可视化</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-make-stunning-data-visualizations-with-d3-js-93a588600b45?source=collection_archive---------1-----------------------#2020-04-24">https://javascript.plainenglish.io/how-to-make-stunning-data-visualizations-with-d3-js-93a588600b45?source=collection_archive---------1-----------------------#2020-04-24</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="1ad0" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">将分层数据集显示为交互式树形图</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/01dd96c40c327da9ebbe67317b4ca546.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*H2djlKaDsSHbcVqL"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@aaronburden?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aaron Burden</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/how-to-make-stunning-data-visualizations-with-d3-js"><div class="gh gi kw"><img src="../Images/c19cb3069af1beba3c93258d9fcfe139.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*-PVzecNs3s4ZbJsdsgIsGA.png"/></div></a></figure><p id="a392" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">随着数据变得越来越普遍，用可视化让它们变得生动起来也变得越来越普遍。它帮助我们理解趋势和模式，否则很难发现。</p><p id="d9f2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在本教程中，我们将学习如何制作一个树状图。受到Mike Bostock的启发——D3.js的创建者——我们将在D3 . js的最新第五版中讨论如何实现这一点。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi lu"><img src="../Images/092cec2cbdba87c21c9a92957a74ebf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*dQLdOqib_9XhsakZ2DAVSg.gif"/></div></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="9528" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">D3是什么？</h1><p id="87c3" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated"><a class="ae kv" href="https://d3js.org/" rel="noopener ugc nofollow" target="_blank"> D3.js </a>是一个JavaScript库，我们可以使用它通过HTML、CSS和SVG来创建数据可视化。这个名字本身代表数据驱动文档。</p><p id="8ad0" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是一个非常强大的框架，可以创建各种具有流畅动画和交互性的可视化效果。本教程结束时，您将学习如何创建以下交互式树形图:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mz"><img src="../Images/0a87a8f5cfffafaf4072a4fb8904c01a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*MtxpzML4pBH26pgSy1xmqg.gif"/></div></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="348b" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">项目设置</h1><p id="ed1f" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">让我们开始建立我们的项目吧。用一个索引文件创建一个新文件夹并导入D3。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4f4f" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我还创建了一个<code class="fe nc nd ne nf b">styles.css</code>文件来保存一些重置，以及负责生成树形图的<code class="fe nc nd ne nf b">treemap.js</code>。其他一切都将由D3处理。我们将从JavaScript填充SVG。</p><p id="5b17" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在<code class="fe nc nd ne nf b">styles.css</code>中，此时我只有两条规则来让SVG占据整个屏幕。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="3cd2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然而，在开始处理树形图之前，我们需要一个数据集。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="c47a" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">生成数据</h1><p id="c239" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">我们将使用一个JSON文件。最后，我们希望有一个这样的结构:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/7cfb8598bbea2d30fdb36583c26e092f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*rmX31iQptPWy-HtYObhkSg.png"/></div></figure><p id="a73b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们在顶部有根文件夹。每个文件夹都可以有文件或子文件夹。子文件夹由一个名称和一组<code class="fe nc nd ne nf b">children</code>表示。如果我们遇到一个文件，我们也想将它的大小存储为<code class="fe nc nd ne nf b">value</code>。</p><p id="bbc8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为了生成数据，我们可以创建一个递归函数。为此，我使用了我在以前的教程中创建的一个类似的实现。在那里，我解释了递归是如何工作的。这是函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="9ca4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们简单看看它是如何工作的。</p><h2 id="092d" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">了解数据生成功能</h2><p id="7a9e" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">我们可以通过调用选择文件夹的函数来生成一个对象。因为它返回一个JavaScript对象，我们将不得不对它调用<code class="fe nc nd ne nf b">JSON.stringify</code>。让我们来分析一下它是如何工作的:</p><ul class=""><li id="56a4" class="nt nu iq kz b la lb ld le lg nv lk nw lo nx ls ny nz oa ob bi translated">我们从一些检查开始。如果文件夹不存在，我们用<code class="fe nc nd ne nf b">null</code>返回。</li><li id="dd7f" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated"><strong class="kz ir">行:6 </strong>:我们定义根对象。它有一个名字和一些孩子。</li><li id="2664" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated"><strong class="kz ir">行:13 </strong>:如果我们正在处理一个目录，我们想循环遍历每个文件，从第16行开始。</li><li id="c831" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated"><strong class="kz ir">行:19 </strong>:如果其中一个文件是子目录，我们想用一个新的路径调用这个函数。它的输出值将是一个<code class="fe nc nd ne nf b">child</code>节点。</li><li id="e487" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated"><strong class="kz ir"> Line:25 </strong>:如果我们正在处理一个文件，我们可以简单地把它的名字和大小附加到<code class="fe nc nd ne nf b">children</code>上。</li><li id="780c" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated"><strong class="kz ir"> Line:32 </strong>:如果我们在根目录下，并且我们传入的参数是一个文件，同样的步骤也可以完成。</li></ul><p id="aedb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">你可以在我使用的同一个文件夹上运行这个函数，得到同样的结果。我用的是<a class="ae kv" href="https://github.com/facebook/react/tree/master/packages/react-reconciler/src" rel="noopener ugc nofollow" target="_blank"> React的一个包</a>。别忘了用<code class="fe nc nd ne nf b">JSON.stringify</code>包起来。将输出保存为<code class="fe nc nd ne nf b">data.json</code>，因为我们稍后会用到它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="92fb" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">制作树形图设置</h1><p id="f927" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">现在我们已经设置好了一切，让我们进入<code class="fe nc nd ne nf b">treemap.js</code>。首先，从定义一些配置变量开始。</p><h2 id="f049" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">定义配置</h2><p id="a5f6" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">将以下内容添加到您的<code class="fe nc nd ne nf b">treemap.js</code>中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="d861" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们希望全屏显示树形图，所以我们使用窗口的宽度和高度。我们还想在开始时定义数据的路径，以便以后可以轻松地更改它。</p><p id="6ed4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">最后，我创建了另外两个变量，一个在我们读取文件时保存JSON数据。另一个是配色方案。这将返回一个我们可以用不同的数字调用的新函数。对于每个数字，它将返回不同的颜色。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f2b5c0e42dab9c01d099a1559b6bc037.png" data-original-src="https://miro.medium.com/v2/resize:fit:1228/format:webp/1*VHdLwMu23joq4UXKFi_N7Q.png"/></div></figure><p id="7e1a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们将使用树的深度为不同的层次创建不同的颜色。</p><h2 id="8857" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">创建树形图函数</h2><p id="2610" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">首先，我们需要一个函数，它将根据传递的数据为我们创建一个树形图。为此我们可以使用内置的<code class="fe nc nd ne nf b">d3.treemap</code>函数。将以下内容添加到您的<code class="fe nc nd ne nf b">treemap.js</code>中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="cb31" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">让我们来看看这个函数的作用。我们调用<code class="fe nc nd ne nf b">d3.treemap</code>并设置一些参数:</p><ul class=""><li id="4468" class="nt nu iq kz b la lb ld le lg nv lk nw lo nx ls ny nz oa ob bi translated">我们让它全屏显示</li><li id="e647" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated">设置一些填充，使矩形很好地分开</li><li id="b48d" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated">对矩形的宽度和高度启用舍入</li><li id="cdc0" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated">然后我们用<code class="fe nc nd ne nf b">d3.hierarchy</code>调用treemap函数，传递我们的JSON数据。这将用额外的属性来修饰我们的数据集，比如<code class="fe nc nd ne nf b">depth</code>或<code class="fe nc nd ne nf b">parent</code>。然后我们需要对数据集求和并排序，这样我们就可以将最大的元素放在最上面。</li></ul><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oi"><img src="../Images/13a5e80446489dea48e7aa4ae4cf6d75.png" data-original-src="https://miro.medium.com/v2/resize:fit:790/format:webp/1*WVar21_jpRji_hbCjFh8WA.png"/></div></figure><h2 id="c129" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">从JSON获取数据</h2><p id="bc84" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">下一步是获取JSON数据。为此我们可以使用<code class="fe nc nd ne nf b">d3.json</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="dbfd" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">由于这个函数在内部使用了<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API" rel="noopener ugc nofollow" target="_blank"> Fetch API </a>，我们将需要使用一个web服务器。为此，我使用了<code class="fe nc nd ne nf b"><a class="ae kv" href="https://www.npmjs.com/package/http-server" rel="noopener ugc nofollow" target="_blank">http-server</a></code>模块，这是服务静态资产的完美解决方案。你可以通过运行<code class="fe nc nd ne nf b">npm i http-server -g</code>在全球范围内安装它。</p><p id="8d44" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">之后，我们可以将数据传递给一个<code class="fe nc nd ne nf b">render</code>函数，该函数会将所有内容绘制到屏幕上。让我们现在就创建它。</p></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="939b" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">制作树状图</h1><p id="a514" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">首先，我们想定义树形图的根，并从DOM中获取SVG。这是我们放东西的地方。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="208e" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这可以用<code class="fe nc nd ne nf b">d3.select</code>来完成。它就像jQuery选择器一样工作。我们也可以用<code class="fe nc nd ne nf b">attr</code>方法操作属性。由于每个<code class="fe nc nd ne nf b">d3</code>调用都返回相同的对象，我们可以一个接一个地连锁调用。我们想让我们的SVG占据整个屏幕。这就是为什么我们将<code class="fe nc nd ne nf b">viewBox</code>设置为屏幕的宽度和高度。</p><p id="7345" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">另外,<code class="fe nc nd ne nf b">root</code>现在将有每个节点的位置和尺寸信息，所以我们知道在哪里放置它们。</p><h2 id="f4e3" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">创建SVG组</h2><p id="700d" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">现在我们需要为包含矩形及其标题的组创建节点。将以下内容添加到<code class="fe nc nd ne nf b">render</code>功能中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="4abe" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">乍一看，这似乎有点吓人，但是让我们看看每个函数是做什么的。首先，我们选择SVG并选择其中的所有组元素。因为我们没有，D3将根据我们传入的数据长度为我们创建这个。</p><p id="72bb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">第二个<code class="fe nc nd ne nf b">data</code>函数用于数据绑定。它需要一个数组。对于每一层，我们希望创建一个单独的组。从我们的树形图的后代，<code class="fe nc nd ne nf b">d3.nest.key.entries</code>会计算出我们有多少深度。基于传递给<code class="fe nc nd ne nf b">key</code>的数据的高度属性。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/f0f49d93a4ceba12990f1e35f46cbfeb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1210/format:webp/1*qBxe4D8KN9JXynHdsHdqrQ.png"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">data returned from d3.nest().key(<em class="oj">d</em> =&gt; d.height).entries(root.descendants()), 4 groups</figcaption></figure><p id="52f2" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后我们需要调用<code class="fe nc nd ne nf b">join</code>来更新元素，以匹配之前由<code class="fe nc nd ne nf b">data</code>绑定的数据。</p><p id="a82c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后我们想再次绑定数据。为了做到这一点，我们必须再次调用<code class="fe nc nd ne nf b">selectAll</code>。但这一次，我们将使用之前数据绑定返回的<code class="fe nc nd ne nf b">values</code>。因此，对于每个数组元素，我们在每个顶部组中创建一个新的组项。之后，我们需要再次调用<code class="fe nc nd ne nf b">join</code>来更新元素。</p><p id="5806" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，现在我们有了可以向每个元素添加转换的数据。这用于在地图中定位矩形。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ok"><img src="../Images/8e59e05b6b3f0108a76d8ae6edf4f4a8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*S_kIMsRMRQ6xrUDINTFpkg.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">The generated DOM</figcaption></figure><h2 id="3651" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">创建矩形</h2><p id="d01a" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">现在让我们在屏幕上显示一些东西。我们首先要创建矩形。在<code class="fe nc nd ne nf b">node</code>变量后添加以下内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="0042" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在每个<code class="fe nc nd ne nf b">attr</code>调用中，<code class="fe nc nd ne nf b">d</code>代表数据，即每个元素的属性。对于每个节点，我们添加一个矩形，并根据其高度属性选择填充颜色。这是我们使用我们定义的颜色函数的地方。我们也可以根据起点和终点来计算宽度和高度。现在你应该有一些空的矩形画在屏幕上:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/fb4f68fa78c93f1a1c6af9518670916e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*gL-VIWy2o8gLH9g5cU_n6g.png"/></div></div></figure><h2 id="4140" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">添加标签</h2><p id="1a2e" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">下一步让我们添加标签。在矩形后添加以下行。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="5c44" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这里我们再次使用<code class="fe nc nd ne nf b">selectAll-data-join</code>链。这将在<code class="fe nc nd ne nf b">text</code>节点中创建两个<code class="fe nc nd ne nf b">tspan</code>元素。一个具有名称，一个具有值。在第5行，我们也设置不透明度值为75%。如您所见，回调函数可以接受三个参数:</p><ul class=""><li id="5cdf" class="nt nu iq kz b la lb ld le lg nv lk nw lo nx ls ny nz oa ob bi translated">一个用于数据，保存关于节点的信息。由于我们之前绑定了<code class="fe nc nd ne nf b">d.data.name</code>和<code class="fe nc nd ne nf b">d.value</code>，它将只保存那些值。</li><li id="5405" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated">一个用于循环中的索引</li><li id="f7e0" class="nt nu iq kz b la oc ld od lg oe lk of lo og ls ny nz oa ob bi translated">一个用于保存对DOM节点的引用的节点</li></ul><p id="f773" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">因此，如果循环是在最后一个元素，它持有<code class="fe nc nd ne nf b">d.value</code>，我们减少不透明度。否则，我们可以让它保持原样。如果你刷新页面，我们现在将有一些标题。但是他们定位很差。让我们修理它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ol"><img src="../Images/5de9a87d930354d16c136c5d8bfc3c75.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QhTk9AJRZHIXuSsexfRujQ.png"/></div></div></figure><h2 id="7ba3" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">定位标签</h2><p id="17d7" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">我们想把父母和孩子分开定位。为此，向<code class="fe nc nd ne nf b">treemap.js</code>添加两个新模块。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="8920" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这可以通过使用过滤器来完成。对于第一个块，任何有子块的都将被选中。第二个块的情况正好相反。对于父类，我们希望名字和值在同一行。对于孩子们，我们想让他们在不同的线上。我们可以遵循用于<code class="fe nc nd ne nf b">fill-opacity</code>的相同逻辑来正确定位两个<code class="fe nc nd ne nf b">tspan</code>元素。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/ab4599cdfe8f4822af24ea7155ce041d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Vcyky5Px2t1eF-rhpPvsjg.png"/></div></div></figure><p id="d200" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">开始有点眉目了，但是我们还有一个问题。短信泛滥。</p><h2 id="ac8e" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">固定溢出</h2><p id="d289" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">为了解决这个问题，我们想添加一个<code class="fe nc nd ne nf b">clipPath</code>元素，其尺寸与矩形相同。在SVG中，这可以通过使用引用矩形id的<code class="fe nc nd ne nf b">use</code>标签来完成。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi on"><img src="../Images/925756bec598c7fb5c5b370404b905c8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1120/format:webp/1*d-Zs1ecvVXDGPbfpy0HjqQ.png"/></div></figure><p id="e1cc" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">由于页面上有相当多的元素，我们需要以某种方式生成唯一的id。为此，我求助于<a class="ae kv" href="https://stackoverflow.com/questions/105034/how-to-create-guid-uuid" rel="noopener ugc nofollow" target="_blank"> StackOverflow </a>来找出最佳方法。这是我最终使用的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b8bb" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">首先，让我们用id属性扩展矩形。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Adding an id for the existing rectangles</figcaption></figure><p id="d947" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们还可以向数据添加其他属性。稍后我们将在<code class="fe nc nd ne nf b">clipPath</code>元素中重用<code class="fe nc nd ne nf b">nodeId</code>。所以接下来让我们补充一下。就在我们定义矩形之后添加它。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Add clipPath before the text element, otherwise we won’t have access to d.clipId</figcaption></figure><p id="4715" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们还想为剪辑路径设置一个id。这是为了我们可以在正文中引用它。对于<code class="fe nc nd ne nf b">href</code>，我们可以使用之前设置的<code class="fe nc nd ne nf b">nodeId</code>。最后，我们需要在文本元素中引用这个剪辑路径。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Adding the clip-path attribute to the text elements</figcaption></figure><p id="b017" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">如果我们做的一切都正确，我们现在应该有一个相当坚实的基础。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/cb2a001dfcdc4eae1e413608638697dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*TX0lqYePugLaoY3mqpo74Q.png"/></div></div></figure><h2 id="a4fb" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">格式化值</h2><p id="63bc" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">我们可以添加一个东西使标签更漂亮。这些值目前以字节为单位。这对于一般人来说并没有太大的意义，我们就把它们转换成可读性更强的格式吧。我再次求助于StackOverflow 来找出我们如何将字节转换成KB和MB。这是我们想要使用的函数:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c612" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要格式化这些值，我们所要做的就是将<code class="fe nc nd ne nf b">d.value</code>包装到这个函数中，在这里我们添加文本。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="e279" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在看起来好多了。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi om"><img src="../Images/33870ecb8d8d02a66f4b9a8aa78054ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tCFcc8JbLgzT99m_tcTkKg.png"/></div></div></figure><h2 id="15bd" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">添加标题</h2><p id="ae7d" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">为了提高可访问性，让我们也给矩形添加标题。我们更希望看到完整的路径，如下图所示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oo"><img src="../Images/617485e7a37c906237548380b70e8263.png" data-original-src="https://miro.medium.com/v2/resize:fit:1280/format:webp/1*16WhMyEmgyQz9S777gatAQ.png"/></div></figure><p id="1570" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">为此，将以下内容添加到<code class="fe nc nd ne nf b">treemap.js</code>:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="f59c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">基于<code class="fe nc nd ne nf b">getPath</code> — <em class="lt">的返回值，我们还没有定义</em> —我们想要显示一个文件或文件夹图标。接下来是文件的完整路径。在新的一行中，我们还可以显示尺寸。<code class="fe nc nd ne nf b">getPath</code>功能可以在一行中完成。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c67a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">它需要一个元素和一个分隔符。有了<code class="fe nc nd ne nf b">element.ancestors</code>，我们可以得到每一个家长。先从根开始，我们还需要调用<code class="fe nc nd ne nf b">reverse</code>。由于我们只对它们的名字感兴趣，我们可以调用一个<code class="fe nc nd ne nf b">map</code>并用传递的分隔符将字符串连接在一起。</p><h2 id="1797" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">添加阴影</h2><p id="c636" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">最后，为了让每一层的深度更加突出，让我们添加一些阴影。为此，我们需要在SVG上创建一个新的过滤器。在<code class="fe nc nd ne nf b">render</code>功能的开头，添加以下内容:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="b94c" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">就其本身而言，这不会做太多，但是现在我们有了一个id为<code class="fe nc nd ne nf b">shadow</code>的<code class="fe nc nd ne nf b">filter</code>元素，我们可以为我们的节点引用它。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi op"><img src="../Images/9f19c39b193821aae587912ae9265fb1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1214/format:webp/1*ifPwknbJWR2hcFcqrD9GhA.png"/></div></figure><p id="9f2b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要使用它，我们需要做的就是为组元素添加一个<code class="fe nc nd ne nf b">filter</code>属性。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="052b" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">现在我们应该有一些漂亮的阴影显示。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi oq"><img src="../Images/9296a730b6d587a61ebe6183fb52c04a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*5H94FqySVsKU9Xv7Zxvcmg.png"/></div></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="2ee1" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">使地图互动</h1><p id="e3e5" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">作为最后一步，让我们让整个事情互动起来。首先，让我们从创建一个主题切换器开始，这样我们就可以从不同的配色方案中进行选择。然后，我们还可以实现缩放功能，使树状图可以导航。</p><h2 id="4c4f" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated"><strong class="ak">主题</strong>切换器</h2><p id="6ef1" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">为此，我们需要一个下拉菜单。将以下内容添加到您的<code class="fe nc nd ne nf b">index.html</code>文件中。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="cad4" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们还可以在CSS中添加一些绝对定位，使其始终显示在右上角。为了让它工作，我们需要为select添加一个on-change监听器。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="944d" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">在回调函数中，我们只需要重新定义<code class="fe nc nd ne nf b">color</code>变量，它是我们在开始时作为配置添加的。然后我们从select中获取值，并将其传递给<code class="fe nc nd ne nf b">scaleSequential</code>。例如，如果我们选择第四个选项，我们将返回<code class="fe nc nd ne nf b">d3['interpolateInferno']</code>，这将返回一个插值器。</p><p id="0d05" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">然后我们只需将<code class="fe nc nd ne nf b">fill</code>属性重新分配给具有新颜色的矩形。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/7354df0820bd78182aead54b9a774bb4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*OP40qL7B3tj4LnTP-ndX1Q.gif"/></div></div></figure><h2 id="6060" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated"><strong class="ak">增加缩放功能</strong></h2><p id="9898" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">现在有一些节点非常小，我们看不到任何子文件夹。就像上面GIF中的“forks”文件夹一样。理想情况下，我们想放大它们。所以现在我们来补充一下。</p><p id="7c28" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">要做到这一点，我们需要用一个新的根重新渲染树形图。在本例中，根将是“forks”文件夹。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="fb50" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">从过滤器开始。我们只想添加一个点击事件到那些有孩子的。我们也不想在根上有一个点击监听器。为了向用户暗示这个元素可以被交互，让我们也把鼠标变成一个指针。</p><p id="3ad8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这将调用一个带有路径和JSON数据的<code class="fe nc nd ne nf b">zoom</code>函数。因为我们在数据上没有路径属性，所以让我们也添加它。在我们追加文本的标题内，添加这一新行:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><h2 id="51a2" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated">创建缩放功能</h2><p id="0a8d" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">对于<code class="fe nc nd ne nf b">zoom</code>函数，我们想用一个新的根来调用<code class="fe nc nd ne nf b">render</code>。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="c6e8" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">根的名称将是路径中的最后一个元素。停留在例子上，万一<code class="fe nc nd ne nf b">react-src.forks</code>了，那就“分叉”了。为了得到<code class="fe nc nd ne nf b">treemapData</code>,我们可以使用一个reducer来遍历JSON并得到我们感兴趣的部分。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="966a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">由于我们总是从根开始，所以我们可以去掉路径的第一部分。对于<code class="fe nc nd ne nf b">react-src.forks</code>来说，我们只剩下<code class="fe nc nd ne nf b">forks</code>了。这将是<code class="fe nc nd ne nf b">normalizedPath</code>的价值。在reducer内部，我们使用一个<code class="fe nc nd ne nf b">forEach</code>来遍历子对象，如果名称匹配，我们就返回那个对象。如果我们尝试这样做，我们会得到一个错误。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi os"><img src="../Images/2ddd400fa64748732e158a283f9dceab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*95ZVM4WCBW_Ahug-otteJg.png"/></div></figure><p id="d551" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这是因为，在<code class="fe nc nd ne nf b">render</code>函数的最开始，我们需要删除SVG中的所有内容。否则，我们会尝试为已经填充的SVG添加相同的内容。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi or"><img src="../Images/41fec4f284fba30f0f57cd3c3806a1fc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*_6Li2L_7jY5bM32iqTXJ6g.gif"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">re-rendering the treemap with a new root</figcaption></figure><p id="e776" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">但是我们没有办法缩小。要解决这个问题，在我们呈现初始数据之后，向您的索引文件添加一个按钮和一个新的click listener。</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="na nb l"/></div></figure><p id="ab10" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">这确保我们能够重置视图并返回到原始根。</p><blockquote class="ot"><p id="9674" class="ou ov iq bd ow ox oy oz pa pb pc ls dk translated">你刚刚创建了你的第一个树状图！</p></blockquote></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><h1 id="f360" class="mc md iq bd me mf mg mh mi mj mk ml mm jw mn jx mo jz mp ka mq kc mr kd ms mt bi translated">包装东西</h1><p id="7dc1" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">我希望完成这个项目所需的步骤不会太多。总结一下，我想给你提供一些文档，可以帮助你更深入地了解D3.js的世界。虽然官方的<a class="ae kv" href="https://github.com/d3/d3/blob/master/API.md" rel="noopener ugc nofollow" target="_blank"> D3文档</a>相当大，但是很难看出它们是如何组合在一起的。这就是为什么我建议浏览一下<a class="ae kv" href="https://observablehq.com/@d3/gallery" rel="noopener ugc nofollow" target="_blank">可观察的</a>上的例子。</p><p id="da76" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">此外，整个项目托管在<a class="ae kv" href="https://github.com/flowforfrank/d3-treemap" rel="noopener ugc nofollow" target="_blank"> GitHub </a>上，所以如果你想用完成的作品做实验，你可以克隆它。感谢您花时间阅读这篇文章。编码快乐！</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://medium.com/@ferencalmasi/membership"><div class="gh gi pd"><img src="../Images/e66c4cd6d9849ac0bd245f3fc39b65c6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*hZ9xuLqLkbqUG65sgVB3gg.png"/></div></a></figure></div><div class="ab cl lv lw hu lx" role="separator"><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma mb"/><span class="ly bw bk lz ma"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><a href="https://www.webtips.dev/"><div class="gh gi kw"><img src="../Images/b0d8e0a0c2689a59aa62a677429b83b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1358/format:webp/1*_QOx8lB1bc1rVmMjWQ3Yfw.png"/></div></a></figure><h2 id="9a6c" class="nh md iq bd me ni nj dn mi nk nl dp mm lg nm nn mo lk no np mq lo nq nr ms ns bi translated"><strong class="ak">用简单英语写的JavaScript笔记</strong></h2><p id="cdaa" class="pw-post-body-paragraph kx ky iq kz b la mu jr lc ld mv ju lf lg mw li lj lk mx lm ln lo my lq lr ls ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物，表达对它们的喜爱:<a class="ae kv" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kz ir">AI in Plain English</strong></a>，<a class="ae kv" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kz ir">UX in Plain English</strong></a>，<a class="ae kv" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kz ir">Python in Plain English</strong></a><strong class="kz ir"/>——谢谢，继续学习！</p><p id="af4a" class="pw-post-body-paragraph kx ky iq kz b la lb jr lc ld le ju lf lg lh li lj lk ll lm ln lo lp lq lr ls ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kv" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kz ir">submissions @ plain English . io</strong></a><strong class="kz ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>