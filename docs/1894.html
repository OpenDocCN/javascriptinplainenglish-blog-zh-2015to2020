<html>
<head>
<title>Building an API consumer-first with Pact</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用Pact构建消费者第一的API</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/building-an-api-consumer-first-with-pact-88360a19bf0d?source=collection_archive---------8-----------------------#2020-05-02">https://javascript.plainenglish.io/building-an-api-consumer-first-with-pact-88360a19bf0d?source=collection_archive---------8-----------------------#2020-05-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a93904c02d4a4418691465970988bdae.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*o6uMZBs9TF4fth98"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@askkell?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andy Kelly</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="c3b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">4月初，我决定最终采取行动，尝试建立自己的应用程序，基于我个人的项目，用FRESH和HackMyResume自动化我的简历。</p><p id="205c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我目前正在经历该应用程序的想法验证阶段，但由于该应用程序最终需要一个后端，我决定花一些时间来建立一个基本的API，具有CV数据的创建，读取，更新和删除(CRUD)功能。</p><p id="b6cb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个CRUD API是我尝试Pact的完美借口，Pact是我以前在另一个项目中用于测试我的API消费者代码的工具，但从来没有将其作为消费者驱动的契约测试解决方案。</p><p id="ec1a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我真的很喜欢使用Pact和它提供的范式转变，所以我想分享我使用它的经验，我已经创建了一个演示项目<a class="ae kc" href="https://gitlab.com/colinfwren/pact-demo" rel="noopener ugc nofollow" target="_blank">，你可以下载来亲自尝试一下</a>。</p><div class="lb lc gp gr ld le"><a href="https://gitlab.com/colinfwren/pact-demo" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">科林·雷恩/ pact-demo</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">展示契约的演示项目</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">gitlab.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jw le"/></div></div></a></div><h1 id="d90f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">什么是消费者驱动的契约测试？</h1><p id="3437" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">契约测试是验证契约的行为，在API的情况下，这将是API端点期望接收什么以及它基于输入返回什么的契约。</p><p id="054c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">构建API来生成某种形式的文档是常见的做法，无论是文档形式还是使用Swagger这样的工具进行API定义。</p><p id="6cea" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然Swagger是一个很好的工具(它很好地补充了Pact ),但它也有一些缺陷:</p><ul class=""><li id="3aa3" class="mw mx iq kf b kg kh kk kl ko my ks mz kw na la nb nc nd ne bi translated">如果实现更新了，而文档没有更新，那么Swagger文档(甚至那些作为代码库的一部分生成的文档)可能会变得不正确</li><li id="1322" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">Swagger文档通常与API消费者单向使用，用它来测试契约，而API提供者从不验证契约是否得到维护</li><li id="a166" class="mw mx iq kf b kg nf kk ng ko nh ks ni kw nj la nb nc nd ne bi translated">作为一个API提供者，很难想象哪些服务在使用API，以及它们实际上在使用哪些属性，因为消费者无法告诉Swagger这一点</li></ul><p id="2887" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">消费者驱动的契约测试颠倒了这种自上而下的单向通信流程，API消费者定义他们如何使用API，API提供者使用定义来测试它是否遵守“契约”。</p><p id="825a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个强有力的想法，因为这意味着API提供者可以自由地更新任何API消费者不使用的任何端点或属性，允许API在保持质量的同时发展。</p><p id="9187" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Pact的代理服务还为API提供者提供了不同消费者的可视化，这有助于基于微服务的规模化部署，在这种部署中，API提供者可能有许多消费者都需要不同的属性。</p><h1 id="95f0" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">设计API</h1><p id="1f09" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">正如前面提到的，Swagger是一个很棒的工具，而且它仍然是迄今为止我用来勾画API的最好的工具，所以我首先为API创建了下面的Swagger文档。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Swagger definition for a Doggo API, part of the demo project</figcaption></figure><p id="01f2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">通常Swagger文档会被用来创建一个供消费者使用的模拟服务器，来测试它的API集成代码，但是我使用了Pact。</p><h1 id="3e9f" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">构建API消费者</h1><p id="f24a" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">在有一个API可以使用之前就构建API消费者可能会感觉有点奇怪，但是当我在一个分布式团队中工作时，我已经多次这样做了，前端和后端团队都构建相同的API定义，后来集成总是会导致问题(Pact解决了这一问题)。</p><p id="4813" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我在我的前端存储库中构建了一个新模块来与未来的API集成，并在Jest中为该模块创建了一个测试套件，使用Pact来定义发送给API提供者的请求和预期的响应。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Example Pact test, the interaction is described and then validated against a mock server</figcaption></figure><p id="6eb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，Pact使用这些定义(称为pact)创建一个模拟服务器，前端API请求将被发送到该模拟服务器，并将返回预期的响应，从而允许对功能进行集成测试，而无需访问API提供者。</p><p id="77d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">需要注意的一个问题是，当您有与相同响应状态匹配的测试时，比方说因为用户没有发送身份验证头而返回401的测试，以及因为身份验证令牌无效而返回401的测试，在这种情况下,<a class="ae kc" href="https://github.com/pact-foundation/pact.io/blob/06c43f405a523d09d103a420c9580c7b8b670df6/best_practices/consumer/contract_tests_not_functional_tests.md" rel="noopener ugc nofollow" target="_blank"> Pact只会将响应代码的第一个交互添加到最终Pact中。</a></p><p id="a1a6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，我向Pact Broker发布了这个协议，Pact Broker是一个管理其他服务的协议的服务器，用于验证、测试API消费者和提供者之间的结果和关系。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The JS implementation of Pact has a simple way of publishing pacts, other implementations may differ</figcaption></figure><h1 id="db3d" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">设置契约代理</h1><p id="c4e9" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">Pact为Pact Broker提供了一个Docker映像，非常适合本地测试，因为它可以快速启动，但他们也在其付费服务Pactflow上提供了一个免费层，允许持有5个Pact。</p><p id="1851" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我已经创建了一个Docker Compose文件，您可以使用它来设置Pact Broker，这将使服务在<a class="ae kc" href="http://localhost:9292" rel="noopener ugc nofollow" target="_blank"> http://localhost:9292 </a>可用(使用<code class="fe nq nr ns nt b">test</code>作为用户名和密码登录)。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Spinning up the Pact Broker in Docker is really easy</figcaption></figure><p id="11f4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦约定发布作业被配置为将约定上传到约定代理，并且约定被发布，消费者的约定将在约定代理的UI中可用。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nu"><img src="../Images/6f269b7b9a19b215f3a473c1fd91efe4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*048y5gMFKLzZ7qa2w2_wgA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Once the consumer’s pact is published to the Pact Broker it’s available to be verified by the provider</figcaption></figure><p id="ccc0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下一步是使用契约代理来允许API提供者下载API消费者的契约，验证API提供者是否遵守该契约，并将结果上传到契约代理。</p><h1 id="bd21" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">使用Pact for TDD构建API提供者</h1><p id="a153" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">下载API消费者契约和验证一致性的能力显示了消费者驱动契约的力量，因为现在我们能够使用已经验证过的契约来实践测试驱动开发(TDD)。</p><p id="d884" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">与为API消费者构建的测试套件相比，为API提供者构建的测试套件没有那么冗长。这是因为这些测试套件的关注点是验证契约是否被遵守，而不是定义它。</p><figure class="nk nl nm nn gt jr"><div class="bz fp l di"><div class="no np l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The provider test downloads the pacts it needs to verify, runs the server, tests them and publishes the results</figcaption></figure><p id="b8ae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦测试套件运行，测试套件的结果将被上传到Pact Broker，并且每个人都可以看到结果。这意味着如果测试失败，那么很容易看出哪些消费者受到了变化的影响。</p><figure class="nk nl nm nn gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/c4ab479ad223240000ce77ad372fa9f8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*oAQEfEb0Botf7uSvTkr10A.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Once the provider runs it’s test the results of the pact are published to the Pact Broker</figcaption></figure><h1 id="8f67" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">红色、绿色、重构</h1><p id="a38e" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">为了让我的初始测试套件通过API，我严重依赖于存根值，但当然最终的应用程序将使用适当的认证服务来完成这一点，当使用Pact时，这可能很难管理。</p><p id="6e59" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Pact的JSON结构是静态的，因此在测试运行时，消费者和提供者都需要使用认证令牌和其他潜在的动态数据。</p><p id="89d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://docs.pact.io/provider/handling_auth" rel="noopener ugc nofollow" target="_blank"> Pact提出了一些缓解这个问题的方法</a>，比如使用长期认证令牌，或者将认证作为一个单独的层，允许Pact针对未经认证的端点运行。</p><p id="90fe" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当重构我的API以使用firebase时，我选择保留存根值，但使用Jest优秀的模仿特性为<code class="fe nq nr ns nt b">firebase/app</code>、<code class="fe nq nr ns nt b">firebase/auth</code>和<code class="fe nq nr ns nt b">firebase-admin</code>模块构建模仿，在模仿中返回存根。</p><p id="d016" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这允许我将所有的测试逻辑移出控制器，移入那些底层函数中，这比我之前基于<code class="fe nq nr ns nt b">NODE_ENV</code>为<code class="fe nq nr ns nt b">test</code>使用策略模式返回存根的方法好得多(Jest在运行时设置这一点)。</p><h2 id="a002" class="nw lu iq bd lv nx ny dn lz nz oa dp md ko ob oc mh ks od oe ml kw of og mp oh bi translated">测试数据</h2><p id="0a92" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">随着API功能和消费服务数量的增长，管理测试数据并确保存根数据的行为标志使用一组一致的值变得非常重要。</p><p id="94b5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我通过创建另一个测试数据模块来管理这一点，该模块存储所有请求和响应有效负载以及身份验证令牌和id的值，允许我更改任何测试值，而不会由于数据不匹配而中断测试。</p><p id="5ca7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的演示项目中，我也使用了这种技术，测试数据在<code class="fe nq nr ns nt b">common</code>文件夹中。</p><h1 id="3af3" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">摘要</h1><p id="4808" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">通过使用消费者驱动的契约测试，我甚至能够在构建API本身之前验证我的前端能够与我的API一起工作，然后使用消费者的契约通过TDD来构建API。</p><p id="4fec" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">作为一个曾在多个团队工作过的人，我们要么收到一份过时的Swagger文档，要么因为后端开发人员没有像前端开发人员那样解释Swagger文档而不得不花时间重新开发API集成，Pact是一个令人惊叹的解决方案。</p><p id="5c6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在我的应用程序开发中，我在我的持续集成(CI)中使用pact的Pactflow服务，以便在每次推送时验证Pact，直接从<code class="fe nq nr ns nt b">package.json</code>开始使用应用程序的版本，以确保正确报告版本。</p><p id="2705" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">随着我的应用程序变得越来越大，我期待着看到Pact如何扩展，因为越来越多的消费者开始使用CRUD API的数据来处理更集中的工作。</p><h1 id="da66" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">你自己去看看</h1><p id="5b15" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">我已经创建了一个演示项目，其中包含一个API消费者、API提供者和一个Docker合成文件来运行Pact Broker，它可以用来玩Pact，并了解消费者驱动的契约测试如何为API驱动的应用程序带来更高的质量水平。</p><div class="lb lc gp gr ld le"><a href="https://gitlab.com/colinfwren/pact-demo" rel="noopener  ugc nofollow" target="_blank"><div class="lf ab fo"><div class="lg ab lh cl cj li"><h2 class="bd ir gy z fp lj fr fs lk fu fw ip bi translated">科林·雷恩/ pact-demo</h2><div class="ll l"><h3 class="bd b gy z fp lj fr fs lk fu fw dk translated">展示契约的演示项目</h3></div><div class="lm l"><p class="bd b dl z fp lj fr fs lk fu fw dk translated">gitlab.com</p></div></div><div class="ln l"><div class="lo l lp lq lr ln ls jw le"/></div></div></a></div><h1 id="c22c" class="lt lu iq bd lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm mn mo mp mq bi translated">来自简明英语团队的说明</h1><p id="3ce2" class="pw-post-body-paragraph kd ke iq kf b kg mr ki kj kk ms km kn ko mt kq kr ks mu ku kv kw mv ky kz la ij bi translated">简明英语刚刚推出了一个YouTube频道！我们希望您现在就通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅来支持我们！</strong> </a></p></div></div>    
</body>
</html>