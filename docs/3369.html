<html>
<head>
<title>What Does it Mean that JavaScript Is Prototype Based?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基于原型是什么意思？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-does-it-mean-that-javascript-is-prototype-based-1974a5e8be49?source=collection_archive---------8-----------------------#2020-09-23">https://javascript.plainenglish.io/what-does-it-mean-that-javascript-is-prototype-based-1974a5e8be49?source=collection_archive---------8-----------------------#2020-09-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="c783" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">__proto__到底是什么</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/72ad082dead986ccf456fc506fea59dd.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9x7cGNg4rehIbjXz"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Photo by <a class="ae ks" href="https://unsplash.com/@jeswinthomas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jeswin Thomas</a> on <a class="ae ks" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="5643" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">当我刚开始学习JavaScript和OOP时，我一遍又一遍地听说JavaScript是一种面向对象的语言，尽管它不是基于类而是基于原型。 <br/>在这篇文章中，我们将试图理解这意味着什么，以及为什么知道原型是什么对于认识我们正在做的事情很重要。</p><p id="f77c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">在其他面向对象的语言中<strong class="kv io">当你声明一个类时，你正在创建一个新的复杂数据类型</strong>，也就是说，一个由原始数据类型组成的数据类型。但这并不是JavaScript中发生的事情，即使我们从ES2015开始使用关键字类。类是蓝图，<strong class="kv io">原型是对象实例。在JavaScript中，默认情况下，对象直接从其他对象继承。</strong></p></div><div class="ab cl lp lq hr lr" role="separator"><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu lv"/><span class="ls bw bk lt lu"/></div><div class="ig ih ii ij ik"><h2 id="9c1f" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak">要理解这意味着什么，我们需要理解原型链是什么。</strong></h2><p id="17dc" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">原型链是一个连接对象功能的<strong class="kv io">树形结构，在这个树的根部是Object.prototype所在的位置。Object.prototype提供了一些在所有对象中都出现的方法，比如toString()、hasOwnProperty()或keys()。</strong></p><p id="b65c" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们遵循原型链，JavaScript中的几乎每个对象都是object的实例。您可能知道，JavaScript中的几乎所有东西都是对象，<a class="ae ks" href="https://javascriptweblog.wordpress.com/2010/09/27/the-secret-life-of-javascript-primitives/" rel="noopener ugc nofollow" target="_blank">甚至一些原始数据类型(特别是字符串、布尔和数字)在很短的时间内也可以是对象</a>。所以，数组是对象，函数是对象，当然，对象是对象。</p><p id="71fd" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">例如，原型链允许我们创建数组的实例，这些实例可以访问数组的所有可用方法，如map、forEach、reduce、filter和big等。但是数组也可以访问所有Object.prototype功能。</p><h2 id="0362" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak">这是怎么发生的？</strong></h2><p id="8c75" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">在我们继续之前澄清一下，因为我们在这个例子中使用了数组，所以数组是JavaScript中的语法糖。它们是具有特殊行为的对象，使它们看起来和感觉起来像一个数组，但在本质上它们是这样的:</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="381b" class="lw lx in mv b gy mz na l nb nc">{<br/>  '0': value,<br/>  '1': value,<br/>  '2': value<br/>}</span></pre><p id="8438" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">原来每个对象都有一个名为__proto__的属性，它保存了对构造函数的原型对象的引用。因此，以数组为例，数组可以访问Object.prototype中的所有方法，因为每个数组都是数组对象的一个实例，而数组对象又是Object对象的一个实例。<strong class="kv io">并且这个链继续下去，直到我们命中Object.prototype的原型，它将是<em class="nd"> null </em>。</strong></p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ne"><img src="../Images/717a4555b08dc1d0d6de58a7a1d048e7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*VpSDNqO78F8X2ZcJ2gI4EA.png"/></div></div></figure><p id="6b57" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这样，当我们试图在一个对象上执行一个方法时，第一个JS将查找对象本身的属性。如果它没有找到同名的属性，它将查找它的__proto__属性，该属性包含对其构造函数的原型对象的引用。如果它没有在那里找到它，它将在这个构造函数对象的__proto__属性中查找。这将继续下去，直到它找到或没有找到它，并抛出一个类型错误。</p><p id="1d12" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">这意味着，例如,<strong class="kv io">每次我们声明一个数组时，我们都在创建一个该语言附带的array对象的实例。</strong>如果我们在控制台中查看它，我们会看到它的__proto__属性链接到了Array对象:</p><p id="5473" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">如果我们继续往下看兔子洞，我们会看到,【_ _ proto _ _ object本身就有一个_ _ proto _ _ property，它保存了对Object.prototype 的引用(它是一个引用，尽管您可以在控制台中看到所有的属性，因为您知道，DRY)。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nf"><img src="../Images/ece003c31673ecb99843dcc60f7583d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*fSYNQEG1ZB7T03i9t_tyjQ.png"/></div></div></figure><h2 id="dda7" class="lw lx in bd ly lz ma dn mb mc md dp me lc mf mg mh lg mi mj mk lk ml mm mn mo bi translated"><strong class="ak">那么，有没有办法在JavaScript中创建一个没有原型的对象呢？</strong></h2><p id="a0f5" class="pw-post-body-paragraph kt ku in kv b kw mp jo ky kz mq jr lb lc mr le lf lg ms li lj lk mt lm ln lo ig bi translated">是的，有。创建对象的方法之一是使用<code class="fe ng nh ni mv b">Object.create()</code>，我们可以将我们希望该对象具有的原型作为参数传递给它，默认情况下该原型是<code class="fe ng nh ni mv b">Object.prototype</code>。如果我们将它作为参数传递为null，我们将得到一个对象，一个哈希表。</p><pre class="kd ke kf kg gt mu mv mw mx aw my bi"><span id="f92e" class="lw lx in mv b gy mz na l nb nc">const objectWithoutPrototype = Object.create(null);</span></pre><p id="99ec" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">我写这篇文章的主要资源是Marijn Haverbeke的<a class="ae ks" href="https://eloquentjavascript.net/" rel="noopener ugc nofollow" target="_blank">雄辩的JavaScript </a>和Will Sentance的课程<a class="ae ks" href="https://frontendmasters.com/courses/object-oriented-js/" rel="noopener ugc nofollow" target="_blank"> JavaScript:面向对象JavaScript的难点</a>。</p><p id="8d08" class="pw-post-body-paragraph kt ku in kv b kw kx jo ky kz la jr lb lc ld le lf lg lh li lj lk ll lm ln lo ig bi translated">谢谢你阅读❤</p></div></div>    
</body>
</html>