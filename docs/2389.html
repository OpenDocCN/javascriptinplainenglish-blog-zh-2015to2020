<html>
<head>
<title>Decoupling code in JavaScript with the Dependency Inversion Principle</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用依赖倒置原则解耦JavaScript代码</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/decoupling-code-in-javascript-with-the-dependency-inversion-principle-6d23342b4aaa?source=collection_archive---------0-----------------------#2020-06-20">https://javascript.plainenglish.io/decoupling-code-in-javascript-with-the-dependency-inversion-principle-6d23342b4aaa?source=collection_archive---------0-----------------------#2020-06-20</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="8d63" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">使用可靠的原则构建健壮的软件。</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/6b424bcba20ddd192d8c6cd0e1e1026f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*LeYBjLHr6kmYIoSx-aHdDA.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Two monitors with background code.</figcaption></figure><p id="c071" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">SOLID是由Robert C. Martin定义的mnemotechnic首字母缩略词，(通常被称为<a class="ae lr" href="https://en.wikipedia.org/wiki/Robert_Cecil_Martin" rel="noopener ugc nofollow" target="_blank">Bob叔叔</a>)是为了使软件设计更易于维护、理解和灵活而创建的五个设计原则。</p><p id="da1b" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这些原则结合在一起，使得开发人员能够轻松地构建更易于扩展和维护的软件。它们让开发人员可以轻松地重构代码，避免代码味道。它是现代敏捷软件开发的重要组成部分，如果你想开发出高质量且易于维护的软件，了解并应用它们是至关重要的。</p><p id="48e7" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们在互联网上有很多关于它们的信息，但是当你试图在javascript中应用它们时，信息就少了。另一方面，我找到的例子几乎都是重复同样的案例，有时候直观上不太好理解。</p><p id="263c" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">软件应用程序设计的5个基本原则是:</p><p id="4f80" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">S —单一责任原理(SRP) <br/> O —开/闭原理(OCP) <br/> L —李斯科夫替代原理(LSP) <br/> I —界面分离原理(ISP) <br/> <strong class="kx ir"> D —依赖倒置原理(DIP) </strong></p><p id="45e1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我将要写的关于这五个原则的系列文章中，我将谈论与我更相关的一个原则<strong class="kx ir"/>:依赖倒置原则或DIP，以及如何在JavaScript中实现它。</p><h2 id="6a7a" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">从属倒置原则</h2><p id="181a" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">依赖性反转原理或DIP指的是一种特定形式的解耦软件模块。当遵循这一原则时，从高级策略设置模块到低级依赖模块建立的传统依赖关系被颠倒。</p><p id="dde4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">这一原则的基础是:</p><ul class=""><li id="fc2b" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">高层模块不应该依赖低层模块。两者都应该依赖于抽象。</li><li id="8770" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">抽象不应该依赖于细节。细节应该依赖于抽象。</li><li id="4635" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">DIP是关于在客户端代码使用的接口后面绑定类。</li><li id="455d" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">DIP声明实现接口的类对于客户端代码是不可见的。</li></ul><p id="2d54" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">一般来说，它通过从外部提供元素的依赖关系来指示<strong class="kx ir">解耦元素，而不是直接创建它们，这将创建附着</strong>。</p><p id="e226" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">我们可以通过多种方式为实例提供必要的依赖关系，例如:</p><ul class=""><li id="382f" class="mq mr iq kx b ky kz lb lc le ms li mt lm mu lq mv mw mx my bi translated">方法注入</li><li id="65a0" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">构造函数注入</li><li id="1c4d" class="mq mr iq kx b ky mz lb na le nb li nc lm nd lq mv mw mx my bi translated">资产注入</li></ul><p id="7579" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">但是，如何在JavaScript中实现DIP呢？</p><p id="6d38" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">JavaScript中依赖注入的另一个实现是带有ES6模块的<strong class="kx ir"/>，能够使用和封装相同的代码，然后将它导入我们需要的地方。</p><p id="70c4" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在下面的例子中，我们有一个名为<code class="fe ne nf ng nh b">DownloadToConsole</code>的类。在这个类中，我们有一个方法:<code class="fe ne nf ng nh b">downloadDataFromAPI</code>，它从一个外部API下载数据，然后将其记录在控制台中。但是这个实现有什么问题呢？如果我们想使用另一种形式来获取数据，如<a class="ae lr" href="https://github.com/axios/axios" rel="noopener ugc nofollow" target="_blank"> Axios </a>或<a class="ae lr" href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest" rel="noopener ugc nofollow" target="_blank"> XMLHttpRequest </a>，而不是Fetch，该怎么办？</p><p id="50b9" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">如果我们在所有的类中直接使用Fetch实现，我们将不得不用一个实现替换所有使用它的类中的另一个实现，因为<strong class="kx ir">我们直接使用</strong>，bud DIP告诉我们应该使用接口，而不是实现。</p><p id="f543" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">让我们看一个例子:</p><h2 id="96e3" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">DownloadToConsole.js</h2><p id="ea77" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">1.直接使用Fetch。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="0c1e" class="ls lt iq nh b gy nm nn l no np">const url = "https://jsonplaceholder.typicode.com/posts"</span><span id="9779" class="ls lt iq nh b gy nq nn l no np">class Example {</span><span id="32b7" class="ls lt iq nh b gy nq nn l no np"> constructor() {<br/>  ...<br/> }</span><span id="7201" class="ls lt iq nh b gy nq nn l no np"> downloadDataFromAPI(params) {<br/>        <br/>  //1.<br/>  <strong class="nh ir">fetch</strong>(url, {<br/>   method: 'GET'<br/>  }).then(r =&gt; r.json())<br/>    .then(r =&gt; {<br/>      console.log("Posts:" + r);<br/>   });<br/> }<br/>}</span></pre><p id="7295" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在JavaScript中，我们没有接口，但是我们可以使用模块封装来实现类似的行为:例如，导出一个类或一个方法。</p><p id="0c00" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在这种情况下，为了简单起见，我们将导出一个用于下载数据的方法。此方法在内部使用Fetch</p><p id="5241" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，在一个<strong class="kx ir"> utils.js </strong>文件中创建一个<code class="fe ne nf ng nh b">doGet</code>方法来封装如何获取数据。</p><h2 id="5b4b" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">实用工具</h2><p id="5aa2" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">2.这里我们可以使用Fetch、Axios或XMLHttpRequest。</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="cf6a" class="ls lt iq nh b gy nm nn l no np">export const <strong class="nh ir">doGet </strong>= (url) =&gt; {</span><span id="e18f" class="ls lt iq nh b gy nq nn l no np"> //2.<br/> return <strong class="nh ir">fetch</strong>(url, {<br/>        method: 'GET',<br/>        mode: 'same-origin',<br/>        ...<br/> }).then(r =&gt; r.json())</span><span id="de87" class="ls lt iq nh b gy nq nn l no np">};</span></pre><h2 id="da4d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">DownloadToConsole.js</h2><p id="14a3" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">我们可以简单地导入<code class="fe ne nf ng nh b">doGet</code> <strong class="kx ir"> </strong>依赖关系并使用它:</p><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="b8f7" class="ls lt iq nh b gy nm nn l no np">import { <strong class="nh ir">doGet </strong>} from './utils.js'</span><span id="e0d9" class="ls lt iq nh b gy nq nn l no np">const url = "https://jsonplaceholder.typicode.com/posts"</span><span id="ddf7" class="ls lt iq nh b gy nq nn l no np">class Example{</span><span id="b0a0" class="ls lt iq nh b gy nq nn l no np"> constructor() {<br/>  ...<br/> }</span><span id="8884" class="ls lt iq nh b gy nq nn l no np"> downloadDataFromAPI(params) {<br/>       <br/>  <strong class="nh ir">doGet</strong>(url)<br/>   .then(r =&gt; {<br/>    console.log("Posts:" + r);<br/>   });<br/> }</span><span id="e290" class="ls lt iq nh b gy nq nn l no np">}</span></pre><p id="b39e" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">现在，代替Fetch，如果我们想要使用Axios，我们将只改变<strong class="kx ir"> utils.js </strong>中的<code class="fe ne nf ng nh b">doGet</code>实现来使用Axios，并且一切将仍然像以前一样工作，而不必再做任何修改。</p><h2 id="d029" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">实用工具</h2><pre class="kg kh ki kj gt ni nh nj nk aw nl bi"><span id="4fa6" class="ls lt iq nh b gy nm nn l no np">export const <strong class="nh ir">doGet </strong>= (url) =&gt; {<br/>  return <strong class="nh ir">axios</strong>.get(url);<br/>};</span></pre><h2 id="9e03" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">结论</h2><p id="d7ec" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">为了说明这个原理，我通过导出一个方法来尽可能简化它的使用，在这个方法中，下载数据的逻辑将使用Fetch、Axios或其他方法来实现。</p><p id="3da2" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">在我们导入该方法的类中，我们不关心它在内部是如何实现的，这允许您将下载代码从实现中分离出来。</p><p id="de36" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">此外，在我们的例子中，通过封装代码，我们实现了不重复自己。(<a class="ae lr" href="http://Don't repeat yourself (DRY, or sometimes do not repeat yourself)" rel="noopener ugc nofollow" target="_blank">干</a>理)</p><h2 id="7a2d" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">参考</h2><div class="nr ns gp gr nt nu"><a href="https://medium.com/javascript-in-plain-english/comparing-different-ways-to-make-http-requests-in-javascript-39ab0f090788" rel="noopener follow" target="_blank"><div class="nv ab fo"><div class="nw ab nx cl cj ny"><h2 class="bd ir gy z fp nz fr fs oa fu fw ip bi translated">比较用Javascript发出HTTP请求的不同方式</h2><div class="ob l"><h3 class="bd b gy z fp nz fr fs oa fu fw dk translated">简明、有用的JavaScript课程——让它变得简单。</h3></div><div class="oc l"><p class="bd b dl z fp nz fr fs oa fu fw dk translated">medium.com</p></div></div><div class="od l"><div class="oe l of og oh od oi kp nu"/></div></div></a></div><p id="fa03" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">坚实的原则:</p><p id="b1a1" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated"><a class="ae lr" href="https://en.wikipedia.org/wiki/SOLID" rel="noopener ugc nofollow" target="_blank">https://en.wikipedia.org/wiki/SOLID</a></p><p id="9583" class="pw-post-body-paragraph kv kw iq kx b ky kz jr la lb lc ju ld le lf lg lh li lj lk ll lm ln lo lp lq ij bi translated">谢谢你阅读我。希望你觉得有用！</p><h2 id="9910" class="ls lt iq bd lu lv lw dn lx ly lz dp ma le mb mc md li me mf mg lm mh mi mj mk bi translated">简单英语的JavaScript</h2><p id="8885" class="pw-post-body-paragraph kv kw iq kx b ky ml jr la lb mm ju ld le mn lg lh li mo lk ll lm mp lo lp lq ij bi translated">你知道我们有四种出版物吗？通过<a class="ae lr" href="https://plainenglish.io/" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir"> plainenglish.io </strong> </a>找到他们——通过关注我们的出版物和<a class="ae lr" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kx ir">订阅我们的YouTube频道</strong> </a> <strong class="kx ir">来表达爱意吧！</strong></p></div></div>    
</body>
</html>