<html>
<head>
<title>Comparing Images in Node.js with JIMP</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">将Node.js中的图像与JIMP进行比较</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/comparing-images-in-node-js-with-jimp-4e98659e08c3?source=collection_archive---------2-----------------------#2020-11-07">https://javascript.plainenglish.io/comparing-images-in-node-js-with-jimp-4e98659e08c3?source=collection_archive---------2-----------------------#2020-11-07</a></blockquote><div><div class="fc if ig ih ii ij"/><div class="ik il im in io"><div class=""/><div class=""><h2 id="fb2a" class="pw-subtitle-paragraph jo iq ir bd b jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf dk translated">发现图像的意外复制或故意窃取</h2></div><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj kg"><img src="../Images/84485201a5ff7a978466d1a2e865e074.png" data-original-src="https://miro.medium.com/v2/resize:fit:1268/format:webp/1*wUuSAUgZKiYMlRNMDcctzg.png"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">Image: <a class="ae ks" href="https://pixabay.com/illustrations/detective-searching-man-search-1424831/" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><p id="f208" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">JIMP npm包为我们提供了比较图像文件的方法，以识别无意的重复或故意的抄袭。在这篇文章中，我将演示如何使用它们，在这个过程中，我们将发现两个图像必须有多相似才能被认为是相同的。</p><h2 id="053b" class="lp lq ir bd lr ls lt dn lu lv lw dp lx lc ly lz ma lg mb mc md lk me mf mg mh bi translated">JIMP及其图像比较方法</h2><p id="b9dd" class="pw-post-body-paragraph kt ku ir kv b kw mi js ky kz mj jv lb lc mk le lf lg ml li lj lk mm lm ln lo ik bi translated">JIMP是JavaScript图像处理程序，你可以在它的npm页面上阅读完整的文档。</p><p id="04fc" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">如果您只想为这个项目安装它，那么运行:</p><p id="03c8" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe mn mo mp mq b">npm install --save jimp</code></p><p id="9e15" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">我将使用三种方法来比较图像:</p><ul class=""><li id="4730" class="mr ms ir kv b kw kx kz la lc mt lg mu lk mv lo mw mx my mz bi translated"><code class="fe mn mo mp mq b">hash</code>:返回一个图像的64位感知哈希。与您可能熟悉的加密哈希不同，感知哈希的变化与输入的差异大致成比例，因此相似图像的哈希也将是相似的。</li><li id="5f91" class="mr ms ir kv b kw na kz nb lc nc lg nd lk ne lo mw mx my mz bi translated"><code class="fe mn mo mp mq b">distance</code>:两个图像哈希之间的汉明距离，即。不同的位数。</li><li id="d841" class="mr ms ir kv b kw na kz nb lc nc lg nd lk ne lo mw mx my mz bi translated"><code class="fe mn mo mp mq b">diff</code>:两幅图像之间的百分比差异。</li></ul><p id="ca67" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">上面链接的JIMP文档推荐使用<code class="fe mn mo mp mq b">distance</code>和<code class="fe mn mo mp mq b">diff</code>来比较图像。如果任一个小于0.15，则可以认为图像是相同的。他们声称99%的成功率只有1%的假阳性。</p><p id="a24a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">然而，对于这个过程，我心中有几个未解的问题:</p><ul class=""><li id="0998" class="mr ms ir kv b kw kx kz la lc mt lg mu lk mv lo mw mx my mz bi translated">如果其中一张图片被转换成黑白的，它还能工作吗？</li><li id="2099" class="mr ms ir kv b kw na kz nb lc nc lg nd lk ne lo mw mx my mz bi translated">如果图像大小不同，是否有效？</li><li id="10d3" class="mr ms ir kv b kw na kz nb lc nc lg nd lk ne lo mw mx my mz bi translated">如果其中一个图像被稍微增强了，比如锐化了，它还能工作吗？</li><li id="d1fd" class="mr ms ir kv b kw na kz nb lc nc lg nd lk ne lo mw mx my mz bi translated">它是否适用于繁重的编辑工作，例如，如果一幅图像高度像素化？</li></ul><p id="41ce" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">为了不吊你胃口，我发现它在所有这些情况下都工作得很好。我创建了四个按照上述要点编辑的图像，所有图像都与未编辑的原始图像具有完全相同的哈希(因此具有相同的汉明距离),尽管百分比差异确实有相当大的变化。然而，根据推荐的方法，只要至少一个测量值小于0.15，图像就被标记为相同。</p><p id="eeda" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">在这篇文章中，我将使用下面的图片展示用于测试这些案例的源代码。还有一个完全不同的图像，我只是想看看会发生什么。</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/9e564a6d5b6ffe7cbdd1e30c45d13a8c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*6cYKQYjU2FQOpEZIj_mw8Q.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk"><em class="ng">edinburgh_original.jpg</em></figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/a0f9a7fcd792d1967c7ba19de14350e4.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*B9YJIya_j5tCsBX07pqQTA.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">edinburgh_sharpened.jpg</figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/3e649d1df1357e5dd5c3e75a9cbbc619.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*wbQmakDcOe6cYmXJ5JJKgg.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">edinburgh_bw.jpg</figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/d7157c4f12a61691f6d0ddcf46f9e375.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*lxNCMOTdBVssRshwunm5tA.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">edinburgh_pixelized.jpg</figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nh"><img src="../Images/5dc66b5a288933c5fe37bf1757517e39.png" data-original-src="https://miro.medium.com/v2/resize:fit:800/format:webp/1*8CKK2H7l3Mn0w98tw3U7fA.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">edinburgh_small.jpg</figcaption></figure><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nf"><img src="../Images/af20712175868cc8cbfa08ef931d3f92.png" data-original-src="https://miro.medium.com/v2/resize:fit:1200/format:webp/1*reHc64a85_CJmyASAOo4hQ.jpeg"/></div><figcaption class="ko kp gk gi gj kq kr bd b be z dk">london.jpg</figcaption></figure><p id="0ac2" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">源代码由一个名为<strong class="kv is"> comparingimages.js </strong>的文件组成，您可以从<a class="ae ks" href="https://github.com/CodeDrome/comparing-images-node-jimp" rel="noopener ugc nofollow" target="_blank"> Github库</a>中获取该文件。这是清单。</p><figure class="kh ki kj kk gu kl"><div class="bz fq l di"><div class="ni nj l"/></div></figure><p id="b508" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe mn mo mp mq b">compare</code>功能是<code class="fe mn mo mp mq b">async</code>,因为我已经用<code class="fe mn mo mp mq b">await</code>打开了图像。因为这只是一个实验，所以我省略了错误处理，当然，任何与外界交互的产品代码，例如文件系统，都应该处理错误。</p><p id="03d9" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">图像打开后，输出原始图像的<code class="fe mn mo mp mq b">hash</code>。当不带参数调用时，<code class="fe mn mo mp mq b">hash</code>函数返回一个基数为64的数字，但是你也可以指定一个基数。这里我也打印了二进制或基数为2的等价物。</p><p id="2f9e" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">剩下的代码是重复的，计算原始图像和每个编辑图像之间的<code class="fe mn mo mp mq b">hash</code>、<code class="fe mn mo mp mq b">distance</code>和<code class="fe mn mo mp mq b">diff</code>。</p><p id="778c" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">这里使用的函数相对来说是资源密集型的，运行这个程序，即使只有六张小照片也需要2-3秒。如果您正在编写代码来比较大量的图像，请记住这一点。</p><p id="d17f" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">现在让我们运行代码…</p><p id="0d12" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated"><code class="fe mn mo mp mq b">node comparingimages.js</code></p><p id="e03a" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">…这给了我们这个:</p><figure class="kh ki kj kk gu kl gi gj paragraph-image"><div class="gi gj nk"><img src="../Images/b49ecff48591f5c387895ff4ad73ba70.png" data-original-src="https://miro.medium.com/v2/resize:fit:1296/format:webp/1*QqFzl4Br1C7RmdnaCtr62Q.png"/></div></figure><p id="f6bd" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">正如我上面提到的，爱丁堡照片的哈希和汉明距离是相同的，尽管百分比差异越来越大。注意“百分比”是误导性的；这些数字实际上是小数，例如，0.5 = 50%。</p><p id="fef9" class="pw-post-body-paragraph kt ku ir kv b kw kx js ky kz la jv lb lc ld le lf lg lh li lj lk ll lm ln lo ik bi translated">毫不奇怪，无论从哪方面来看，伦敦的照片都非常不同。</p></div></div>    
</body>
</html>