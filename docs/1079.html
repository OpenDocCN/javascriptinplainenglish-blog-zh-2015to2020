<html>
<head>
<title>JavaScript Events Handlers— onfocus, oncancel and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript事件处理程序— onfocus、oncancel等等</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-events-handlers-onfocus-oncancel-and-more-ce0d6f76c5c8?source=collection_archive---------4-----------------------#2020-01-26">https://javascript.plainenglish.io/javascript-events-handlers-onfocus-oncancel-and-more-ce0d6f76c5c8?source=collection_archive---------4-----------------------#2020-01-26</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/c197e4908fb8e0e9fa4ed5a7c447c5c7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*9TcNgKUM779eMYcR"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@priscilladupreez?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Priscilla Du Preez</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="faad" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在JavaScript中，事件是应用程序中发生的动作。它们是由各种事情触发的，比如输入、提交表单、调整大小等元素变化，或者应用程序运行时发生的错误等。我们可以分配事件处理程序来处理这些事件。发生在DOM元素上的事件可以通过为相应事件的DOM对象的属性分配一个事件处理程序来处理。在本文中，我们将看看<code class="fe lb lc ld le b">oncanplaythrough</code>、<code class="fe lb lc ld le b">onchange</code>、<code class="fe lb lc ld le b">onclick</code>和<code class="fe lb lc ld le b">onclose</code>事件处理程序。</p><h1 id="ca4e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">在线播放</h1><p id="108d" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">oncanplaythrough</code>属性让我们为它分配自己的事件处理函数来处理<code class="fe lb lc ld le b">canplaythrough</code>事件。当用户代理可以播放媒体，并且估计加载了足够的数据来播放媒体直到结束，而不必停止并缓冲更多数据时，就会触发此事件。例如，我们可以通过添加以下HTML代码来监听视频的<code class="fe lb lc ld le b">canplaythrough</code>事件:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="21f5" class="mq lg iq le b gy mr ms l mt mu">&lt;video width="320" height="240" controls id='video'&gt;<br/>  &lt;source src="<a class="ae kc" href="https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4" rel="noopener ugc nofollow" target="_blank">https://sample-videos.com/video123/mp4/240/big_buck_bunny_240p_30mb.mp4</a>" type="video/mp4"&gt;<br/>&lt;/video&gt;</span></pre><p id="73cf" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的JavaScript代码中，我们可以添加:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="1e64" class="mq lg iq le b gy mr ms l mt mu">const video = document.getElementById('video');<br/>video.oncanplaythrough = (event) =&gt; {<br/>  console.log(event);<br/>}</span></pre><p id="edd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以通过在视频DOM节点上使用<code class="fe lb lc ld le b">addEventListener</code>方法来附加<code class="fe lb lc ld le b">canplaythrough</code>事件监听器，如以下代码所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2546" class="mq lg iq le b gy mr ms l mt mu">const video = document.getElementById('video');<br/>video.addEventListener('canplaythrough', (event) =&gt; {<br/>  console.log(event);<br/>});</span></pre><p id="2239" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论哪种方式，我们都可以通过使用媒体元素(包括视频和音频元素)的<code class="fe lb lc ld le b">readyState</code>属性来检查是否已经下载了足够多的媒体部分，以便完成下载。<code class="fe lb lc ld le b">readyState</code>可以有以下可能值之一:</p><ul class=""><li id="260a" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated">常量<code class="fe lb lc ld le b">HAVE_NOTHING </code>或数字<code class="fe lb lc ld le b">0</code> —没有关于媒体资源的信息</li><li id="bb30" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">常数<code class="fe lb lc ld le b">HAVE_METADATA</code>或数字<code class="fe lb lc ld le b">1</code> —媒体资源的足够部分已经被下载，元数据属性被初始化。在本州或更远的地方寻找不会引发异常</li><li id="ea98" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">常量<code class="fe lb lc ld le b">HAVE_CURRENT_DATA</code>或数字<code class="fe lb lc ld le b">2</code> —当前播放位置有足够的数据，但不足以实际播放一帧以上</li><li id="3d69" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">常量<code class="fe lb lc ld le b">HAVE_FUTURE_DATA</code>或数字<code class="fe lb lc ld le b">3</code> —下载了当前播放位置的足够数据，以及至少播放到未来一点的足够数据，这意味着至少2帧视频。</li><li id="392f" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated">常数<code class="fe lb lc ld le b">HAVE_ENOUGH_DATA</code>或数字<code class="fe lb lc ld le b">4</code>——有足够的数据可用，下载速率足够高，媒体可以不间断地播放到结束。</li></ul><p id="ad88" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以通过编写以下代码来获取视频元素的<code class="fe lb lc ld le b">readyState</code>属性:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3788" class="mq lg iq le b gy mr ms l mt mu">const video = document.getElementById('video');<br/>video.oncanplaythrough = (event) =&gt; {<br/>  console.log(event.target.readyState);<br/>}</span></pre><p id="6f0e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们的视频可以一直播放，我们应该有4个记录在<code class="fe lb lc ld le b">console.log</code>输出中。</p><h1 id="7e2e" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">onchange</h1><p id="7048" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">onchange</code>属性让我们给它分配一个事件处理程序来处理<code class="fe lb lc ld le b">change</code>事件。当用户提交表单控件的值更改时，触发<code class="fe lb lc ld le b">change</code>事件。这可以通过在控件外部单击或使用Tab键切换不同的控件来完成。例如，在用户向<code class="fe lb lc ld le b">input</code>输入一个值之后，我们可以使用它来获取<code class="fe lb lc ld le b">input</code>元素的输入值，然后将焦点移到输入之外。首先，我们可以添加以下HTML代码:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="ee45" class="mq lg iq le b gy mr ms l mt mu">&lt;input type="text" size="50" id='input' placeholder='Input'&gt;</span></pre><p id="aa32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在JavaScript代码中，我们添加:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="2ec8" class="mq lg iq le b gy mr ms l mt mu">const input = document.getElementById('input');<br/>input.onchange = (event) =&gt; {<br/>  console.log(event.target.value);<br/>}</span></pre><p id="758d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">input元素的<code class="fe lb lc ld le b">value</code>属性将包含我们在添加到HTML代码的input元素中输入的文本值。当用户在不同的输入和表单的不同部分之间移动时，这对于获取输入非常有帮助。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nj"><img src="../Images/cf37e46a0e2c18755790ffa715840b9d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*dauk7bcD4tI1s3OZ"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@aquatium?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Harpal Singh</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="6c1c" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">onclick</h1><p id="408a" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">我们可以给元素的<code class="fe lb lc ld le b">onclick</code>属性分配一个事件处理程序，当用户点击一个元素时做一些事情。<code class="fe lb lc ld le b">click</code>事件由<code class="fe lb lc ld le b">onclick</code>事件处理程序处理，当用户点击元素时触发。它按顺序在<code class="fe lb lc ld le b">mousedown</code>和<code class="fe lb lc ld le b">mouseup</code>事件之后触发。非鼠标或触摸屏设备不会触发<code class="fe lb lc ld le b">click</code>事件。为了适应这些用户，我们可以处理<code class="fe lb lc ld le b">keydown</code>事件。例如，我们可以使用它来获取浏览器选项卡的位置，该选项卡是用以下HTML代码单击的:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="966e" class="mq lg iq le b gy mr ms l mt mu">&lt;p&gt;Click anywhere in this example.&lt;/p&gt;<br/>&lt;div id='message'&gt;</span><span id="d01e" class="mq lg iq le b gy nk ms l mt mu">&lt;/div&gt;</span></pre><p id="8d31" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们将在<code class="fe lb lc ld le b">div</code>元素中添加跟踪鼠标位置的消息。</p><p id="4570" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后在我们的JavaScript代码中，我们可以写:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b7c3" class="mq lg iq le b gy mr ms l mt mu">const message = document.getElementById('message');<br/>document.onclick = (event) =&gt; {<br/>  message.innerHTML = `You click coordinate is x = ${event.clientX}, y = ${event.clientY}`;<br/>}</span></pre><p id="7879" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们获得了当鼠标点击页面时鼠标所在页面的位置。我们可以使用<code class="fe lb lc ld le b">Event</code>对象的<code class="fe lb lc ld le b">clientX</code>和<code class="fe lb lc ld le b">clientY</code>分别获取每次鼠标点击的x和y坐标。然后当我们运行代码时，我们可以看到鼠标被点击的地方的坐标。</p><h1 id="d05f" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">onclose</h1><p id="98c3" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated">为了处理<code class="fe lb lc ld le b">dialog</code>元素关闭时的情况，我们可以使用<code class="fe lb lc ld le b">onclose</code>事件处理程序，因为<code class="fe lb lc ld le b">close</code>事件是在它关闭时触发的。用<code class="fe lb lc ld le b">onclose</code>事件处理程序处理该事件可以防止它冒泡，所以父处理程序不会得到该事件的通知。一次只能给一个对象分配一个<code class="fe lb lc ld le b">onclose</code>处理器。然而，如果我们使用<code class="fe lb lc ld le b">addEventListener</code>将事件处理函数附加到我们的元素上，那么我们就可以避开这个限制。<code class="fe lb lc ld le b">close</code>和<code class="fe lb lc ld le b">cancel</code>事件的区别在于，无论对话框以何种方式关闭，都会触发关闭事件。<code class="fe lb lc ld le b"> </code>例如，我们可以在下面的代码中使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="3db7" class="mq lg iq le b gy mr ms l mt mu">const dialog = document.getElementById('dialog');<br/>const openButton = document.getElementById('open-button');<br/>openButton.onclick = () =&gt; {<br/>  dialog.showModal();<br/>};</span><span id="6aae" class="mq lg iq le b gy nk ms l mt mu">dialog.onclose = (event) =&gt; {<br/>  console.log('dialog closed');<br/>  console.log(event);<br/>}</span></pre><p id="0147" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们必须将<code class="fe lb lc ld le b">dialog</code>元素添加到我们的HTML代码中:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d124" class="mq lg iq le b gy mr ms l mt mu">&lt;button id='open-button'&gt;<br/>  Open Dialog<br/>&lt;/button&gt;<br/>&lt;dialog id="dialog"&gt;<br/>  &lt;form method="dialog"&gt;<br/>    &lt;p&gt;<br/>      Dialog<br/>    &lt;/p&gt;<br/>    &lt;menu&gt;<br/>      &lt;button id="cancel-button" value="cancel"&gt;Cancel&lt;/button&gt;<br/>      &lt;button id="confirmBtn" value="default"&gt;Confirm&lt;/button&gt;<br/>    &lt;/menu&gt;<br/>  &lt;/form&gt;<br/>&lt;/dialog&gt;</span></pre><p id="af3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在上面的代码中，我们在HTML中添加了一个<code class="fe lb lc ld le b">dialog</code>元素，并使用<code class="fe lb lc ld le b">getElementById</code>方法获取HTML <code class="fe lb lc ld le b">dialog</code>元素的DOM元素，这样我们就有了以下方法:</p><ul class=""><li id="098a" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe lb lc ld le b">close()</code> —关闭<code class="fe lb lc ld le b">dialog</code>元素的对话框实例方法。一个可选的字符串可以作为参数传入，它更新<code class="fe lb lc ld le b">dialog</code>的<code class="fe lb lc ld le b">returnValue</code>，这对于指示用户使用哪个按钮关闭它很有用。</li><li id="10cf" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe lb lc ld le b">show()</code> —无模式显示对话框的对话框实例方法，这意味着我们仍然允许来自外部的交互。这不需要争论。</li><li id="c8e5" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe lb lc ld le b">showModal()</code> —一个对话框实例方法，用于将对话框作为模态显示在任何其他对象之上。它与::background伪元素一起显示在顶层。与对话框外的元素的交互被阻止，并且不能与对话框外的内容进行交互。</li></ul><p id="9e1d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">dialog</code> DOM元素还具有以下值属性:</p><ul class=""><li id="8934" class="mv mw iq kf b kg kh kk kl ko mx ks my kw mz la na nb nc nd bi translated"><code class="fe lb lc ld le b">open</code> —一个反映<code class="fe lb lc ld le b">open</code> HTML属性的布尔属性，它指示一个对话框是否为交互而打开。</li><li id="1fee" class="mv mw iq kf b kg ne kk nf ko ng ks nh kw ni la na nb nc nd bi translated"><code class="fe lb lc ld le b">returnValue</code> —设置并返回对话框返回值的字符串属性。我们可以直接给它赋值，也可以向<code class="fe lb lc ld le b">close</code>方法传递一个参数来设置这个属性。</li></ul><p id="edb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们不需要调用<code class="fe lb lc ld le b">close()</code>方法来关闭对话框。有个按钮就够了。此外，我们不必单击按钮来关闭对话框，我们也可以按键盘上的Esc键来关闭对话框。</p><p id="847b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">请注意，Firefox默认情况下不启用<code class="fe lb lc ld le b">dialog</code>元素。要在Firefox中使用它，我们必须在<code class="fe lb lc ld le b">about:config</code>页面中将<code class="fe lb lc ld le b">dom.dialog_element.enabled</code>设置为<code class="fe lb lc ld le b">true</code>。Chrome默认启用了这个功能。然后，如果我们单击刚才制作的“打开对话框”按钮，我们将看到一个本机浏览器对话框。然后，如果我们按Esc键关闭对话框，那么<code class="fe lb lc ld le b">cancel</code>事件将被触发，我们分配给<code class="fe lb lc ld le b">dialog.oncancel</code>的事件处理函数将运行。事件处理函数的<code class="fe lb lc ld le b">event</code>参数将获得一个<code class="fe lb lc ld le b">Event</code>对象，其中包含关于<code class="fe lb lc ld le b">cancel</code>事件源的信息，也就是我们的<code class="fe lb lc ld le b">dialog</code>元素。因此，在我们的<code class="fe lb lc ld le b">console.log</code>输出中，我们将得到类似如下的内容:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="4bb4" class="mq lg iq le b gy mr ms l mt mu">bubbles: false<br/>cancelBubble: false<br/>cancelable: false<br/>composed: false<br/>currentTarget: null<br/>defaultPrevented: false<br/>eventPhase: 0<br/>isTrusted: true<br/>path: (5) [dialog#dialog, body, html, document, Window]<br/>returnValue: true<br/>srcElement: dialog#dialog<br/>target: dialog#dialog<br/>timeStamp: 3902.0349998027086<br/>type: "close"</span></pre><p id="06c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">属性让我们给它分配自己的事件处理函数来处理<code class="fe lb lc ld le b">canplaythrough</code>事件。当媒体下载完成时，触发<code class="fe lb lc ld le b">canplaythrough</code>事件，这样浏览器就不必停下来缓冲以从头到尾播放媒体。属性让我们给它分配一个事件处理器来处理<code class="fe lb lc ld le b">change</code>事件。当用户提交表单控件的值更改时，触发<code class="fe lb lc ld le b">change</code>事件。我们可以给元素的<code class="fe lb lc ld le b">onclick</code>属性分配一个事件处理程序，当用户点击一个元素时做一些事情。为了处理<code class="fe lb lc ld le b">dialog</code>元素关闭时的情况，我们可以使用<code class="fe lb lc ld le b">onclose</code>事件处理程序，因为<code class="fe lb lc ld le b">close</code>事件是在它关闭时触发的。<code class="fe lb lc ld le b">close</code>事件与<code class="fe lb lc ld le b">cancel</code>事件的不同之处在于<code class="fe lb lc ld le b">cancel</code>事件只有在按下Esc键关闭对话框时才会被触发，而<code class="fe lb lc ld le b">close</code>事件无论用户以何种方式关闭对话框都会被触发。</p></div></div>    
</body>
</html>