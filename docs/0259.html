<html>
<head>
<title>Replacing Redux with custom React Hooks for Global State Management</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">用定制的React钩子替换Redux进行全局状态管理</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/replacing-redux-with-custom-react-hooks-for-state-management-5d04592fd6d7?source=collection_archive---------3-----------------------#2019-09-07">https://javascript.plainenglish.io/replacing-redux-with-custom-react-hooks-for-state-management-5d04592fd6d7?source=collection_archive---------3-----------------------#2019-09-07</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="f716" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">对于管理跨组件状态来说，定制的React钩子可能是Redux的一个不太臃肿的替代方法。</h2></div></div><div class="ab cl kc kd hr ke" role="separator"><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh ki"/><span class="kf bw bk kg kh"/></div><div class="ig ih ii ij ik"><figure class="kk kl km kn gt ko gh gi paragraph-image"><div class="gh gi kj"><img src="../Images/f2831696dde05d414195a4de936eab96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1128/format:webp/1*Tp2jN72a_Zf7_N9gxQ-5Wg.jpeg"/></div></figure><figure class="kk kl km kn gt ko"><div class="bz fp l di"><div class="kr ks l"/></div></figure><h1 id="1c2c" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">定制的React钩子可以被证明是Redux和管理跨组件状态的一个不太臃肿的替代方法，可以避免钻柱等等。</h1><p id="353d" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">它还有助于通过使用已经可用的react挂钩来保持较小的应用程序大小，而不依赖于额外的依赖项，如redux npm。</p><h2 id="d4b3" class="mh ku in bd kv mi mj dn kz mk ml dp ld lu mm mn lf ly mo mp lh mc mq mr lj ms bi translated">1.创造一个类似商店的选择:</h2><p id="e0f7" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">在store.tsx文件中，使用在钩子外部实例化的全局状态、侦听器和操作创建自定义钩子useStore。这样，每次在组件中导入和使用useStore钩子时，钩子都可以访问相同范围的侦听器、全局状态和操作。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi mt"><img src="../Images/a8a35153c3d741b61a17a17e7a122ad7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JbmjnuPrSc-WaK4FE92vNQ.png"/></div></div></figure><p id="78bf" class="pw-post-body-paragraph ll lm in ln b lo my jo lq lr mz jr lt lu na lw lx ly nb ma mb mc nc me mf mg ig bi translated">useStore钩子必须返回一个由两个成员组成的数组:有状态值和一个更新它的函数。在useStore的情况下，这些将是<strong class="ln io">【全局状态，分派】。— </strong> dispatch —更新挂钩的函数将对标识符进行处理，以确定采取何种操作(添加、计数、删除等)。)应该执行并更新有状态值— globalState。dispatch还将接收任何相关的有效负载，以便有效地更新全局状态。在成功调度和全局状态更新后，各种组件中的所有侦听器都会接入该组件。换句话说，我们需要设置监听器来接入全局状态，并接受应用程序中其他地方所做的更改。</p><p id="d6c6" class="pw-post-body-paragraph ll lm in ln b lo my jo lq lr mz jr lt lu na lw lx ly nb ma mb mc nc me mf mg ig bi translated">useEffect with cleanup应该有助于在组件挂载时添加侦听器，然后在卸载时删除它。</p><h2 id="2e5c" class="mh ku in bd kv mi mj dn kz mk ml dp ld lu mm mn lf ly mo mp lh mc mq mr lj ms bi translated"><em class="nd">在进入useStore实现之前，所有useEffect挂钩组成部分的小图:</em></h2><p id="0e22" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated"><em class="ne"> useEffect是一个调用:——</em><strong class="ln io"><em class="ne">1。带功能</em> </strong> <em class="ne"> —任何逻辑或其他挂钩都可以在这里使用。— </em> <strong class="ln io"> <em class="ne"> 2。cleanup </em> </strong> <em class="ne"> —只是在卸载组件时执行的返回函数。——</em><strong class="ln io"><em class="ne">3。and dependencies</em></strong><em class="ne">—第二个参数，and数组，其中传递的任何参数确保useEffect只在那些变量改变时执行。因此，如果数组为空，useEffect会在每次发生变化时执行:</em></p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nf"><img src="../Images/520ca7b4bc3b34e0128a87187ec6a309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*KKEtiiobCZ5QFf5PYKmL-w.png"/></div></div></figure><h2 id="e305" class="mh ku in bd kv mi mj dn kz mk ml dp ld lu mm mn lf ly mo mp lh mc mq mr lj ms bi translated">回到我们的自定义useStore挂钩:</h2><p id="f5d2" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">为了确保我们想要的行为，我们需要确保useEffect dependancy数组包含setState——因为它不会在useStore的范围内改变——确保useEffect只执行一次。</p><p id="677f" class="pw-post-body-paragraph ll lm in ln b lo my jo lq lr mz jr lt lu na lw lx ly nb ma mb mc nc me mf mg ig bi translated">接下来，清理功能将在卸载时删除侦听器。</p><p id="1633" class="pw-post-body-paragraph ll lm in ln b lo my jo lq lr mz jr lt lu na lw lx ly nb ma mb mc nc me mf mg ig bi translated">最后，我们像任何钩子一样返回全局状态快照和分派。</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ng"><img src="../Images/118c044a6c112c72e30f40892dff3b7d.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*JPP5FyKIHJIiwuctcpYWzA.png"/></div></div></figure><p id="d563" class="pw-post-body-paragraph ll lm in ln b lo my jo lq lr mz jr lt lu na lw lx ly nb ma mb mc nc me mf mg ig bi translated">现在没有评论了😆：</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nh"><img src="../Images/e18413047eaec2da4944c73e73725e49.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*0BNG6y1XSvD-_QVJ5QFogg.png"/></div></div></figure><h2 id="6bf8" class="mh ku in bd kv mi mj dn kz mk ml dp ld lu mm mn lf ly mo mp lh mc mq mr lj ms bi translated">2.用操作和初始状态配置存储</h2><p id="eafa" class="pw-post-body-paragraph ll lm in ln b lo lp jo lq lr ls jr lt lu lv lw lx ly lz ma mb mc md me mf mg ig bi translated">接下来是设置基于上下文的数据存储区——configure dataStore——使用:</p><p id="9376" class="pw-post-body-paragraph ll lm in ln b lo my jo lq lr mz jr lt lu na lw lx ly nb ma mb mc nc me mf mg ig bi translated">—任何将标识符作为键、将函数作为值的操作，这些操作将在调度时调用</p><p id="1b66" class="pw-post-body-paragraph ll lm in ln b lo my jo lq lr mz jr lt lu na lw lx ly nb ma mb mc nc me mf mg ig bi translated">—作为对象的初始状态数据</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi ni"><img src="../Images/90ee0a25655410e9bd4494cae2c615fb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*AmVfeky0QoF-bRgBzFn1dQ.png"/></div></div></figure><p id="1db8" class="pw-post-body-paragraph ll lm in ln b lo my jo lq lr mz jr lt lu na lw lx ly nb ma mb mc nc me mf mg ig bi translated"><strong class="ln io"> 3。实例化特定于上下文的存储:</strong></p><p id="b097" class="pw-post-body-paragraph ll lm in ln b lo my jo lq lr mz jr lt lu na lw lx ly nb ma mb mc nc me mf mg ig bi translated">接下来，在足够高的(父)级别实例化configureDataStore。在这种情况下，使用Store globalState来填充组件:</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nj"><img src="../Images/a67a37d01c494b2da18dc737a8cac3da.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ztPKoGh6El4J10pKAvp6rg.png"/></div></div></figure><p id="f8ca" class="pw-post-body-paragraph ll lm in ln b lo my jo lq lr mz jr lt lu na lw lx ly nb ma mb mc nc me mf mg ig bi translated">最后，有趣的部分是，我们选择任何我们想要的组件来进入全局状态，并分派动作来更新它！</p><figure class="kk kl km kn gt ko gh gi paragraph-image"><div role="button" tabindex="0" class="mu mv di mw bf mx"><div class="gh gi nk"><img src="../Images/036d0f61de1c3d33cd2a6280d6d37144.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*127VeQt6211hmsFyAdwLag.png"/></div></div></figure><p id="0d0d" class="pw-post-body-paragraph ll lm in ln b lo my jo lq lr mz jr lt lu na lw lx ly nb ma mb mc nc me mf mg ig bi translated">任何组件都应该通过监听器接收状态更新，并且通过useStore自定义钩子调度操作创建有意义的数据更改！</p></div></div>    
</body>
</html>