<html>
<head>
<title>What is Hoisting in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的提升是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/https-medium-com-javascript-in-plain-english-what-is-hoisting-in-javascript-a63c1b2267a1?source=collection_archive---------0-----------------------#2018-08-27">https://javascript.plainenglish.io/https-medium-com-javascript-in-plain-english-what-is-hoisting-in-javascript-a63c1b2267a1?source=collection_archive---------0-----------------------#2018-08-27</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><figure class="im in gp gr io ip gh gi paragraph-image"><div role="button" tabindex="0" class="iq ir di is bf it"><div class="gh gi il"><img src="../Images/6d1c322f6041bc022fc6faed9bca36af.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*wAliNjZFGgKKock-ni844A.gif"/></div></div><figcaption class="iw ix gj gh gi iy iz bd b be z dk">Ahoy(st) there sailor!</figcaption></figure><div class=""/><div class=""><h2 id="9d34" class="pw-subtitle-paragraph jz jb jc bd b ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq dk translated">了解JavaScript中的提升意味着什么，并提供代码示例来帮助解释这一切</h2></div><p id="c305" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">JavaScript的许多怪癖之一就是所谓的提升。</p><p id="6638" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">现在，如果你是JavaScript编程新手，很可能你还没有写好你的代码。因此，很有可能你的吊装也不完美。😉</p><p id="e9e7" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><em class="ln">你觉得了解这类内容有用吗？如果有，通过</em> <a class="ae lo" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd"> <em class="ln">订阅我的YouTube频道</em> </strong> </a> <strong class="kt jd"> <em class="ln">获取更多类似内容！</em>T15】</strong></p><h2 id="b150" class="lp lq jc bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">但是什么是吊装呢？</h2><p id="e8f0" class="pw-post-body-paragraph kr ks jc kt b ku mi kd kw kx mj kg kz la mk lc ld le ml lg lh li mm lk ll lm ig bi translated">基本上，当JavaScript编译所有代码时，所有使用<code class="fe mn mo mp mq b"><em class="ln">var</em></code>的变量声明都被提升到它们的函数/局部作用域的顶部(如果在函数内声明)或全局作用域的顶部(如果在函数外声明)，而不管实际声明是在哪里进行的。这就是我们所说的<em class="ln">吊装</em>。请记住，这种“提升”的概念不会真的出现在您的代码中，而是象征性地出现，与JavaScript编译器如何读取您的代码有关。希望这对你有意义。不管怎样，请继续阅读，记住当我们想到“提升”时，我们可以直观地想象任何被提升的东西都被移动到顶部，但理论上，没有代码真正移动。</p><p id="2134" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">函数声明也会被提升，但是它们会在最上面，所以会位于所有变量声明之上。</p><p id="29b6" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">说够了，让我们给你看一些基本的代码例子来演示提升的影响。</p><p id="88f7" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">如果我们要在全局范围内编写以下内容:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="44fd" class="lp lq jc mq b gy mz na l nb nc">console.log(myName);<br/>var myName = ‘Sunil’;</span></pre><h2 id="dfbe" class="lp lq jc bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">突击测验！您认为console.log会输出什么？</h2><p id="e901" class="pw-post-body-paragraph kr ks jc kt b ku mi kd kw kx mj kg kz la mk lc ld le ml lg lh li mm lk ll lm ig bi translated"><strong class="kt jd"> <em class="ln"> 1。</em> </strong> <code class="fe mn mo mp mq b"><em class="ln">Uncaught ReferenceError: myName is not defined</em></code></p><p id="3d21" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><strong class="kt jd">T23】2。 </strong> <code class="fe mn mo mp mq b"><em class="ln">Sunil</em></code></p><p id="6b8c" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><strong class="kt jd"> 3。</strong> <code class="fe mn mo mp mq b">undefined</code></p><p id="b467" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">事实证明，这第三个选项其实才是正确答案。</p><p id="2b9c" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">正如我们前面提到的，当JavaScript在运行时编译时，变量被移动到其作用域的顶部(如果我们排除NodeJS的使用，在非常基本的层面上，这仅仅意味着当你的网页正在加载时)。然而，需要注意的一个关键点是，唯一移动到顶部的是变量声明，而不是赋予变量的实际值。</p><p id="c83d" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">为了澄清我们的意思，如果我们有一段代码，假设在第10行，我们有<code class="fe mn mo mp mq b">var myName = 'Sunil'</code>，当JavaScript被编译时，<code class="fe mn mo mp mq b">var myName</code>将被移动到它的作用域的顶部，而<code class="fe mn mo mp mq b">myName = 'Sunil' </code>将停留在第10行(或者如果<code class="fe mn mo mp mq b">var myName</code>被提升到第1行，现在可能是第11行)。</p><h2 id="048a" class="lp lq jc bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">让我们看看前面的相同代码块，但是看看JavaScript编译器将如何在运行时输出代码:</h2><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="34fc" class="lp lq jc mq b gy mz na l nb nc">var myName;<br/>console.log(myName);<br/>myName = ‘Sunil’;</span></pre><p id="e2ea" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">这就是为什么console.log能够输出'<strong class="kt jd"> undefined </strong>'，因为它识别出变量<strong class="kt jd"> myName </strong>存在，但是<strong class="kt jd"> myName </strong>直到第三行才被赋值。</p><h2 id="be4e" class="lp lq jc bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">顺便说一下…</h2><p id="ca4d" class="pw-post-body-paragraph kr ks jc kt b ku mi kd kw kx mj kg kz la mk lc ld le ml lg lh li mm lk ll lm ig bi translated">我们将变量命名为<code class="fe mn mo mp mq b">myName</code>，而不是简单的<code class="fe mn mo mp mq b">name</code>，因为浏览器中的“窗口”对象已经有了一个<code class="fe mn mo mp mq b">name</code>属性。如果我们要在浏览器中测试这一点，在全局范围内创建的任何变量实际上都是“窗口”对象的一部分。因此，创建<code class="fe mn mo mp mq b">var name = 'Sunil';</code>与执行<code class="fe mn mo mp mq b">window.name = 'Sunil';</code>相同，因此，创建<code class="fe mn mo mp mq b">var name = ‘Sunil';</code>也可以通过键入<code class="fe mn mo mp mq b">window.name</code>来引用。</p><p id="682b" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">因此，由于window.name已经存在(出于您的兴趣，window.name只是返回一个空字符串——至少在Chrome Dev工具中是这样),我们并没有真正理解提升是如何工作的。因此，我们选择使用<code class="fe mn mo mp mq b">myName</code>来代替！如果你只是一时糊涂，不要担心，吊装就是这样！</p><h2 id="a3bb" class="lp lq jc bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">当我们爬出兔子洞时…</h2><p id="01f0" class="pw-post-body-paragraph kr ks jc kt b ku mi kd kw kx mj kg kz la mk lc ld le ml lg lh li mm lk ll lm ig bi translated">我们之前也简单提到过，函数也被提升到顶部(就在顶部，在变量声明被提升的上方)。</p><h2 id="3e0e" class="lp lq jc bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">所以如果我们看下面的例子:</h2><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="12c0" class="lp lq jc mq b gy mz na l nb nc">function hey() {<br/>console.log('hey ' + myName);<br/>};<br/>hey();<br/>var myName = 'Sunil';</span></pre><p id="a7ce" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><strong class="kt jd"> hey() </strong>函数调用仍会返回undefined，因为实际上JavaScript解释器在运行时要编译到以下内容:</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="0faa" class="lp lq jc mq b gy mz na l nb nc">function hey() {<br/>console.log('hey ' + myName);<br/>};<br/>var myName;<br/>hey();<br/>myName = 'Sunil';</span></pre><p id="802d" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">所以当函数被调用时，它知道有一个名为<code class="fe mn mo mp mq b">myName</code>的变量，但是这个变量还没有被赋值。这有几个变体，当使用<strong class="kt jd">life的</strong>的变量表达式时会发生(<a class="ae lo" href="https://medium.com/javascript-in-plain-english/https-medium-com-javascript-in-plain-english-stop-feeling-iffy-about-using-an-iife-7b0292aba174" rel="noopener">如果你想阅读关于IIFEs </a>的早期文章，请单击此处)，但是试图一下子理解所有这些并不理想，所以我将让你自己研究关于<strong class="kt jd">函数表达式</strong>和<strong class="kt jd">life的</strong>的提升。</p><p id="562c" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">话虽如此，上面提到的其他一切应该有助于你更好地理解起重是如何工作的。</p><p id="8f3f" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">提升的概念就是为什么你有时会遇到其他人的代码，在这些代码中变量被声明在最上面，然后在后面被赋值。这些人只是试图让他们的代码非常类似于解释器将如何编译它，以帮助他们最小化任何可能的错误。</p><h2 id="364c" class="lp lq jc bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">但是Let和Const呢？</h2><p id="002b" class="pw-post-body-paragraph kr ks jc kt b ku mi kd kw kx mj kg kz la mk lc ld le ml lg lh li mm lk ll lm ig bi translated">它们也被提升了——事实上，<code class="fe mn mo mp mq b">var</code>、<code class="fe mn mo mp mq b">let</code>、<code class="fe mn mo mp mq b">const</code>、<code class="fe mn mo mp mq b">function</code>和<code class="fe mn mo mp mq b">class</code>声明都被提升了——但是我们必须记住，托管的概念不是一个字面上的过程(也就是说，声明本身不会移动到文件的顶部——它只是JavaScript编译器首先读取它们以便为它们在内存中创建空间的一个过程)。</p><p id="0d02" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><code class="fe mn mo mp mq b">var</code>、<code class="fe mn mo mp mq b">let</code>和<code class="fe mn mo mp mq b">const</code>声明之间的区别在于它们的<strong class="kt jd">初始化</strong> — <strong class="kt jd"> </strong>简单来说，这仅仅意味着它们被赋予的开始值。</p><p id="9b3f" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">可以在没有值的情况下初始化<code class="fe mn mo mp mq b">var</code>和<code class="fe mn mo mp mq b">let</code>的实例，而如果你试图声明一个而没有同时给它赋值的话，<code class="fe mn mo mp mq b">const</code>会抛出一个<code class="fe mn mo mp mq b">Reference error</code>。所以<code class="fe mn mo mp mq b">const myName = 'Sunil'</code>可以工作，但是<code class="fe mn mo mp mq b">const myName; myName = 'Sunil';</code>不行。使用<code class="fe mn mo mp mq b">var</code>和<code class="fe mn mo mp mq b">let</code>，你可以在赋值之前尝试使用一个<code class="fe mn mo mp mq b">var</code>值，它将返回<code class="fe mn mo mp mq b">undefined</code>。然而，如果你对<code class="fe mn mo mp mq b">let</code>做了同样的事情，你会得到一个<code class="fe mn mo mp mq b">Reference Error</code>。</p><h2 id="eae9" class="lp lq jc bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">那么var、<code class="fe mn mo mp mq b">let</code>和<code class="fe mn mo mp mq b">const</code>在吊装方面有区别吗？</h2><p id="6199" class="pw-post-body-paragraph kr ks jc kt b ku mi kd kw kx mj kg kz la mk lc ld le ml lg lh li mm lk ll lm ig bi translated">是的，如果你在顶层(全局层)创建一个<code class="fe mn mo mp mq b">var</code>，它会在全局对象上创建一个属性——在浏览器的情况下，这可能是窗口对象。所以创建<code class="fe mn mo mp mq b">var myName = 'Sunil';</code>也可以通过调用<code class="fe mn mo mp mq b">window.myName</code>来引用。</p><p id="5e38" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">然而，如果你写了<code class="fe mn mo mp mq b">let newName = 'Sunny';</code>，这将不能在全局窗口对象中访问——因此，你将不能使用<code class="fe mn mo mp mq b">window.newName</code>作为对<code class="fe mn mo mp mq b">'Sunny'</code>的引用。</p><h2 id="b486" class="lp lq jc bd lr ls lt dn lu lv lw dp lx la ly lz ma le mb mc md li me mf mg mh bi translated">下面的问题也是理解提升如何影响你的代码库的基础。</h2><p id="fb91" class="pw-post-body-paragraph kr ks jc kt b ku mi kd kw kx mj kg kz la mk lc ld le ml lg lh li mm lk ll lm ig bi translated">用<code class="fe mn mo mp mq b">var</code>做的声明可以从它们的初始范围之外访问，而用<code class="fe mn mo mp mq b">let</code>和<code class="fe mn mo mp mq b">const</code>做的声明则不能。</p><p id="0a41" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated">正如我们在下面的例子中看到的，用<code class="fe mn mo mp mq b">var</code>做的声明返回<code class="fe mn mo mp mq b">undefined</code>，而用<code class="fe mn mo mp mq b">let</code>和<code class="fe mn mo mp mq b">const</code>做的声明返回错误(用<em class="ln">贷记</em><a class="nd ne ep" href="https://medium.com/u/d3f5beae318?source=post_page-----a63c1b2267a1--------------------------------" rel="noopener" target="_blank"><em class="ln">gvlachos</em></a><em class="ln">)来产生和写入下面的</em>):</p><pre class="mr ms mt mu gt mv mq mw mx aw my bi"><span id="82bb" class="lp lq jc mq b gy mz na l nb nc">console.log(‘1a’, myName1); // undefined<br/>if (1) {<br/> console.log(‘1b’, myName1); // undefined<br/> var myName1 = ‘Sunil’;<br/>}</span><span id="b387" class="lp lq jc mq b gy nf na l nb nc">console.log('2a', myName2); // error: myName2 is not defined<br/>if (1) {<br/>    console.log('2b', myName2); // undefined<br/>    let myName2 = 'Sunil';<br/>}</span><span id="70ea" class="lp lq jc mq b gy nf na l nb nc">console.log('3a', myName3); // error: myName3 is not defined<br/>if (1) {<br/>    console.log('3b', myName3); // undefined<br/>    const myName3 = 'Sunil';<br/>}</span></pre><h1 id="6032" class="ng lq jc bd lr nh ni nj lu nk nl nm lx ki nn kj ma kl no km md ko np kp mg nq bi translated">我们做到了！</h1><p id="a563" class="pw-post-body-paragraph kr ks jc kt b ku mi kd kw kx mj kg kz la mk lc ld le ml lg lh li mm lk ll lm ig bi translated">如果你喜欢这篇文章，我们也已经开始创建视频内容！通过<a class="ae lo" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kt jd">订阅我们的YouTube频道</strong> </a> <strong class="kt jd">来表达爱意吧！</strong></p><p id="3f59" class="pw-post-body-paragraph kr ks jc kt b ku kv kd kw kx ky kg kz la lb lc ld le lf lg lh li lj lk ll lm ig bi translated"><em class="ln">文章于2019年3月28日更新，以进一步解释let和const方面的提升，并修复文章中我引用“name”而不是“myName”的错别字。这篇文章于2019年9月22日再次更新，因为其中一个代码块中有一个关于let使用的错误。增加了一段额外的文字来解释“吊装”的概念确实是一个概念，而不是一个字面上的过程。</em></p></div></div>    
</body>
</html>