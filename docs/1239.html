<html>
<head>
<title>What does a Worker do in JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">一个工人用JavaScript做什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-does-a-worker-do-in-javascript-25b9449f22f1?source=collection_archive---------0-----------------------#2020-02-17">https://javascript.plainenglish.io/what-does-a-worker-do-in-javascript-25b9449f22f1?source=collection_archive---------0-----------------------#2020-02-17</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><h2 id="93ac" class="io ip iq bd b dl ir is it iu iv iw dk ix translated" aria-label="kicker paragraph">Java Script语言</h2><div class=""/><div class=""><h2 id="337a" class="pw-subtitle-paragraph jw iz iq bd b jx jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn dk translated">一个让你摆脱代码阻塞的新线程</h2></div><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi ko"><img src="../Images/fd1d2cf1a5d22424c7a450184f54d0ac.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*EjmEaZOI2ocDmtxK"/></div></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Photo by <a class="ae le" href="https://unsplash.com/@kevnbhagat?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Kevin Bhagat</a> on <a class="ae le" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="8685" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">多年来，JavaScript最不方便的特性之一是，一旦某个任务耗时太长，其余的代码就会被阻止执行。JavaScript是一种单线程编程语言，它总是让你等待代码按顺序执行。但是实际上有一个解决方法——工人。我将在这篇文章中讨论如何使用它。</p><h1 id="37c0" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">先前阅读</h1><p id="7c66" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">要知道JavaScript是单线程语言。如果你不熟悉这个事实，在开始这篇文章之前，你应该阅读这篇文章。</p><h1 id="8598" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">同步码</h1><p id="8238" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">让我们看看大家可能都知道的JavaScript代码的常见情况。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="6d70" class="nd mc iq mz b gy ne nf l ng nh">let cnt = 0;<br/>for (let i = 0; i &lt; 10e8; i += 1) {<br/>  cnt += 1;<br/>}<br/>console.log(cnt);</span></pre><p id="84fa" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe ni nj nk mz b">cnt</code>在for-loop的代码块中为10e8倍增加1。并且<code class="fe ni nj nk mz b">console.log</code>不会被执行，直到for循环完成增加<code class="fe ni nj nk mz b">cnt</code>。</p><p id="66b7" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在Chrome浏览器的控制台中，这需要相当长的时间。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nl"><img src="../Images/3c4b8c7ad907f63c58a1b57dfd5ba639.png" data-original-src="https://miro.medium.com/v2/resize:fit:996/format:webp/1*Gcd1JifZIESJ1-gLPj7mZg.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">It took almost 3 seconds</figcaption></figure><p id="9ecd" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe ni nj nk mz b">cnt</code>无论如何都不会打印，直到for-loop完成。</p><p id="552f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">许多开发人员被困在这个问题中，因为它的用户必须等到当前正在执行的任务已经完成。</p><h1 id="823a" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">异步代码</h1><p id="c843" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">对于可怜的我们来说，伟大的JavaScript设计者给了我们特殊的函数，这些函数不会阻塞流程。它们在不同于正常任务的队列中等待。基本上，它们可以在所有正常任务完成后执行。我们称之为异步任务。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="3f94" class="nd mc iq mz b gy ne nf l ng nh">let cnt = 0;<br/>setTimeout(() =&gt; {<br/>  for (let i = 0; i &lt; 10e8; i += 1) {<br/>    cnt += 1;<br/>  }<br/>  console.log(cnt);<br/>});<br/>console.log(cnt);</span></pre><p id="436b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这段代码的结果与上面的第一个不同。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/673deea1a370d876fe49f8c7209758ef.png" data-original-src="https://miro.medium.com/v2/resize:fit:1076/format:webp/1*-nPDnDZQOnHbhXELfGnpLw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">But this still takes quite a long time</figcaption></figure><p id="4249" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">for循环在<code class="fe ni nj nk mz b">setTimeout</code>。<code class="fe ni nj nk mz b">setTimeout</code>在所有正常任务执行完毕后执行。</p><p id="5714" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">但是，这不是阻止代码流的最佳解决方案。即使<code class="fe ni nj nk mz b">setTimeout</code>是一个不阻塞正常流程的异步函数，这里所改变的只是函数运行的顺序。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="781f" class="nd mc iq mz b gy ne nf l ng nh">let cnt = 0;<br/>setTimeout(() =&gt; {<br/>  for (let i = 0; i &lt; 10e8; i += 1) {<br/>    cnt += 1;<br/>  }<br/>  console.log(cnt);<br/>});<br/>setTimeout(() =&gt; {<br/>  console.log(cnt);<br/>});<br/>console.log(cnt);</span></pre><p id="e4f4" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">看一下这个例子。现在有第二个<code class="fe ni nj nk mz b">setTimeout</code>包含了一个函数，它立即打印<code class="fe ni nj nk mz b">cnt</code>。但是，第二个<code class="fe ni nj nk mz b">setTimeout</code>总是在第一个<code class="fe ni nj nk mz b">setTimeout</code>运行完for-loop后运行<code class="fe ni nj nk mz b">console.log(cnt)</code>。如果第一个<code class="fe ni nj nk mz b">setTimeout</code>运行一些耗时太长的任务，第二个就没有机会运行代码。</p><p id="454a" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">为什么？因为JavaScript是单线程的。异步函数在不同的任务队列中，但是它们仍然遵循单线程规则。</p><p id="3b91" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我在这篇文章中写了更多关于异步故事的细节，如果你感兴趣的话可以看看这个。</p><div class="nn no gp gr np nq"><a href="https://medium.com/better-programming/be-the-master-of-the-event-loop-in-javascript-part-1-6804cdf6608f" rel="noopener follow" target="_blank"><div class="nr ab fo"><div class="ns ab nt cl cj nu"><h2 class="bd ja gy z fp nv fr fs nw fu fw iz bi translated">成为JavaScript中事件循环的主人(第1部分)</h2><div class="nx l"><h3 class="bd b gy z fp nv fr fs nw fu fw dk translated">宏任务、微任务、执行上下文、事件队列和rAF</h3></div><div class="ny l"><p class="bd b dl z fp nv fr fs nw fu fw dk translated">medium.com</p></div></div><div class="nz l"><div class="oa l ob oc od nz oe ky nq"/></div></div></a></div><h1 id="74a8" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">工人</h1><p id="2fd0" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">Web Worker是一个Web API。这意味着工作人员根本不能访问或操作DOMs。工人生活在一个完全不同的线程中，它从不打扰主线程。它所能做的是从创建新工人的地方接收消息，并向其发送消息。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="f5b5" class="nd mc iq mz b gy ne nf l ng nh">let worker;<br/>if ('Worker' in window) {<br/>  worker = new Worker('file_name');<br/>}</span></pre><p id="d5fe" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">我们如何创建一个新的Worker实例非常简单。<code class="fe ni nj nk mz b">new Worker</code>将字符串或URL作为第一个参数。它通常应该是如下所示的文件名。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="98d7" class="nd mc iq mz b gy ne nf l ng nh">new Worker('/worker.js');</span></pre><p id="db18" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">创建实例后，可以向线程的另一端发送消息。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="bdc7" class="nd mc iq mz b gy ne nf l ng nh">worker.postMessage('From Main Thread');</span></pre><p id="ba42" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">当然，您可以在工作线程中收到这条消息。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="724e" class="nd mc iq mz b gy ne nf l ng nh">// worker.js</span><span id="370f" class="nd mc iq mz b gy of nf l ng nh">this.addEventListener('message', event =&gt; {<br/>  console.log(event.data);<br/>});</span></pre><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi og"><img src="../Images/50b05bfe77c84da3ca872caf97e74cf3.png" data-original-src="https://miro.medium.com/v2/resize:fit:832/format:webp/1*zlJ1khR3Wm3rIXQ9m7rNDA.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">The worker got the message successfully</figcaption></figure><p id="6f45" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">如果你看好日志，你会发现文件名是<code class="fe ni nj nk mz b">worker.js</code>，而不是什么<code class="fe ni nj nk mz b">main.js</code>或者<code class="fe ni nj nk mz b">app.js</code>。这意味着工人可以很好地接收信息。</p><p id="916c" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">现在，让我们命令工作线程一收到来自主线程的消息就向主线程发送另一条消息。</p><pre class="kp kq kr ks gt my mz na nb aw nc bi"><span id="de2c" class="nd mc iq mz b gy ne nf l ng nh">// main.js<br/>worker.addEventListener('message', event =&gt; {<br/>  console.log(event.data);<br/>});</span><span id="e6c4" class="nd mc iq mz b gy of nf l ng nh">// worker.js<br/>this.addEventListener('message', event =&gt; {<br/>  ...<br/>  this.postMessage('From Worker Thread');<br/>});</span></pre><p id="1156" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">代码看起来相当多余。我会给你看工作流程，但在此之前，我们先看看结果。</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div class="gh gi oh"><img src="../Images/f99d22e03273cc934beb33111c5adb07.png" data-original-src="https://miro.medium.com/v2/resize:fit:1112/format:webp/1*mj9DQtZbvoDs1Y9ZNT_ykw.png"/></div><figcaption class="la lb gj gh gi lc ld bd b be z dk">Now we can see two messages</figcaption></figure><p id="899b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这是如何运作的呢？</p><figure class="kp kq kr ks gt kt gh gi paragraph-image"><div role="button" tabindex="0" class="ku kv di kw bf kx"><div class="gh gi oi"><img src="../Images/8680daf8dd4ee45912baed430ecf6157.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*-UziNmbzA1PtgG86ermckg.png"/></div></div></figure><p id="293b" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated"><code class="fe ni nj nk mz b">onMessage</code>是你可以接收到来自线程另一端的消息的事件，而<code class="fe ni nj nk mz b">postMessage</code>是你可以将消息发送到线程另一端的事件，如此而已！</p><h1 id="c733" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">代码测试</h1><figure class="kp kq kr ks gt kt"><div class="bz fp l di"><div class="oj ok l"/></div></figure><p id="a230" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">在这个测试中，你可以看到两件事。</p><ul class=""><li id="4251" class="ol om iq lh b li lj ll lm lo on ls oo lw op ma oq or os ot bi translated">运行for循环的总时间。</li><li id="eea5" class="ol om iq lh b li ou ll ov lo ow ls ox lw oy ma oq or os ot bi translated">代码阻塞</li></ul><p id="5295" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">这个例子是用React做的。状态消息应该像预期的那样打印出来，但是同步和异步操作除了总运行时间之外不打印任何消息。因为在React中，改变状态也是一个异步动作。因此，它们也应该等待正常任务和其他预先排序的异步任务。</p><p id="313f" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">相反，Worker不需要等待任何东西，因为它在不同的线程中。For循环在工作线程中，异步任务在主线程中，所以它们不会互相中断。</p><h1 id="0690" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">结论</h1><p id="c4a5" class="pw-post-body-paragraph lf lg iq lh b li mt ka lk ll mu kd ln lo mv lq lr ls mw lu lv lw mx ly lz ma ij bi translated">通常，工人是用于一些需要大量CPU资源的东西，例如2D画布或SVG图形。由于Workers生活在一个不同的线程中，它不会阻塞主线程中的任何东西，比如UI渲染。如果你用得好，这是非常强大的。而且浏览器支持也不错——支持event IE10。</p><p id="3069" class="pw-post-body-paragraph lf lg iq lh b li lj ka lk ll lm kd ln lo lp lq lr ls lt lu lv lw lx ly lz ma ij bi translated">下一次，我将介绍新的神奇的技术，特别是为PWA，一名服务人员。</p><h1 id="d4e4" class="mb mc iq bd md me mf mg mh mi mj mk ml kf mm kg mn ki mo kj mp kl mq km mr ms bi translated">资源</h1><ul class=""><li id="fcee" class="ol om iq lh b li mt ll mu lo oz ls pa lw pb ma oq or os ot bi translated"><a class="ae le" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker" rel="noopener ugc nofollow" target="_blank">工人— MDN </a></li></ul></div></div>    
</body>
</html>