<html>
<head>
<title>How to handle User Registration in Node.js with JWT</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何用JWT处理Node.js中的用户注册</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/node-js-api-user-registration-with-jwt-b6b74fe599e9?source=collection_archive---------1-----------------------#2020-09-18">https://javascript.plainenglish.io/node-js-api-user-registration-with-jwt-b6b74fe599e9?source=collection_archive---------1-----------------------#2020-09-18</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/47466920f940137c505f0df1b924bf9a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*XkmnsJ6Joa6EDFVGUw0tfA.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Cover Image</figcaption></figure><p id="7a83" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">JWT是在双方之间安全传输数据的开放标准。它与身份验证系统一起使用，以发出经过身份验证的请求。它包括<code class="fe la lb lc ld b">header</code>、<code class="fe la lb lc ld b">payload</code>和<code class="fe la lb lc ld b">signature</code>。JWT是一种无状态认证机制，即它在客户端维护会话，而不是将其存储在服务器中。</p><p id="53af" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">JWT的工作流程非常简单。JWT是用一个秘密密钥创建的，这个秘密密钥将被秘密保存在你的应用程序中。当您的应用程序从任何客户端接收到JWT密钥时，您的应用程序会用私钥验证该密钥。从客户端修改公钥将导致身份验证失败。JWT由用点分隔的三个不同部分组成。最初的部分是标题。第二部分是有效载荷，第三部分是签名。JWT令牌的语法是</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="2ff3" class="lm ln iq ld b gy lo lp l lq lr">HEADER + '.' + PAYLOAD + '.' + SIGNATURE</span></pre><div class="ls lt gp gr lu lv"><a href="https://jwt.io/" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">JWT。超正析象管(Image Orthicon)</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">JSON Web Token (JWT)是一种简洁的、URL安全的方式，用于表示要在双方之间传输的声明。的…</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">jwt.io</p></div></div><div class="me l"><div class="mf l mg mh mi me mj jw lv"/></div></div></a></div><h2 id="9755" class="lm ln iq bd mk ml mm dn mn mo mp dp mq kn mr ms mt kr mu mv mw kv mx my mz na bi translated"><strong class="ak">使用JWT的优势</strong></h2><ol class=""><li id="f0a8" class="nb nc iq ke b kf nd kj ne kn nf kr ng kv nh kz ni nj nk nl bi translated">JWT确保了饼干和会话。</li><li id="a537" class="nb nc iq ke b kf nm kj nn kn no kr np kv nq kz ni nj nk nl bi translated">他们帮助我们使用第三方认证服务。甚至帮助创建自己的认证服务，如谷歌，脸书。(单点登录)</li><li id="cd37" class="nb nc iq ke b kf nm kj nn kn no kr np kv nq kz ni nj nk nl bi translated">验证JWT令牌很容易。</li><li id="39a0" class="nb nc iq ke b kf nm kj nn kn no kr np kv nq kz ni nj nk nl bi translated">提供无状态身份验证。</li></ol></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h2 id="1895" class="lm ln iq bd mk ml mm dn mn mo mp dp mq kn mr ms mt kr mu mv mw kv mx my mz na bi translated"><strong class="ak">目录</strong></h2><ol class=""><li id="15c9" class="nb nc iq ke b kf nd kj ne kn nf kr ng kv nh kz ni nj nk nl bi translated"><a class="ae ny" href="#20ff" rel="noopener ugc nofollow">创建节点JS项目</a></li><li id="0387" class="nb nc iq ke b kf nm kj nn kn no kr np kv nq kz ni nj nk nl bi translated"><a class="ae ny" href="#22f5" rel="noopener ugc nofollow">用户注册</a></li><li id="9e20" class="nb nc iq ke b kf nm kj nn kn no kr np kv nq kz ni nj nk nl bi translated"><a class="ae ny" href="#0cf6" rel="noopener ugc nofollow">哈希密码</a></li><li id="68ab" class="nb nc iq ke b kf nm kj nn kn no kr np kv nq kz ni nj nk nl bi translated"><a class="ae ny" href="#3c0a" rel="noopener ugc nofollow">注册后生成JWT令牌</a></li><li id="9fd3" class="nb nc iq ke b kf nm kj nn kn no kr np kv nq kz ni nj nk nl bi translated"><a class="ae ny" href="#12fa" rel="noopener ugc nofollow">模式验证</a></li></ol></div><div class="ab cl nr ns hu nt" role="separator"><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw nx"/><span class="nu bw bk nv nw"/></div><div class="ij ik il im in"><h2 id="20ff" class="lm ln iq bd mk ml mm dn mn mo mp dp mq kn mr ms mt kr mu mv mw kv mx my mz na bi translated"><strong class="ak"> 1。创建一个Node.js项目</strong></h2><p id="e97c" class="pw-post-body-paragraph kc kd iq ke b kf nd kh ki kj ne kl km kn nz kp kq kr oa kt ku kv ob kx ky kz ij bi translated">让我们从创建一个新的Node js项目开始。创建一个名为nodeJWT的新文件夹，并用命令<code class="fe la lb lc ld b">npm init -y</code>初始化它。</p><p id="22f1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">初始化后，安装本演示所需的所有软件包。</p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="c805" class="lm ln iq ld b gy lo lp l lq lr">mkdir nodeJWT<br/>cd nodeJWT<br/>npm init -y</span><span id="a2d2" class="lm ln iq ld b gy oc lp l lq lr">npm install <!-- -->nodemon<!-- --> express express-validator body-parser bcryptjs jsonwebtoken mongoose</span><span id="4286" class="lm ln iq ld b gy oc lp l lq lr">touch index.js</span></pre><p id="a23f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在让我们使用Express创建我们的服务器。创建<code class="fe la lb lc ld b">index.js</code>文件后，添加这段代码。</p><p id="a427" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">index.js</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="72d6" class="lm ln iq ld b gy lo lp l lq lr">const express = require('express')<br/>const bodyparser = require('body-parser');<br/>const mongoose = require('mongoose')<br/>var app = express()</span><span id="fe7b" class="lm ln iq ld b gy oc lp l lq lr">//<strong class="ld ir">Routes</strong><br/>app.use(bodyparser.json())<br/>app.get('/', function(req,res){<br/>  res.send('Hello world')<br/>})</span><span id="d0cf" class="lm ln iq ld b gy oc lp l lq lr"><strong class="ld ir">//MongoDb connection<br/></strong>mongoose.connect('mongodb://localhost/test', {useNewUrlParser: true});<br/>mongoose.connection.once('open',function(){<br/>  console.log('Database connected Successfully');<br/>}).on('error',function(err){<br/>  console.log('Error', err);<br/>})</span><span id="8a7a" class="lm ln iq ld b gy oc lp l lq lr">//<strong class="ld ir">Server </strong><br/>app.listen('8000',function(req,res){<br/>  console.log('Serve is up and running at the port 8000')<br/>})</span></pre><p id="17c1" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在上面的代码中，我们做了三件事。首先，我们创建了一个运行在端口8000上的服务器。接下来，我们使用mongoose实例将node js项目与MongoDb连接起来。最后，我们创建了一条简单的路线。</p><p id="8104" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在输入<code class="fe la lb lc ld b">nodemon index.js</code>时，你应该看到浏览器上显示hello world。</p><p id="1684" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在我在根目录下创建四个名为<code class="fe la lb lc ld b">Controller, Middleware, Models, Routes</code>的文件夹。确保您的项目结构如下所示。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div class="gh gi od"><img src="../Images/a2c41d9a9a4cc3269a6c8063ee47cf48.png" data-original-src="https://miro.medium.com/v2/resize:fit:1152/format:webp/1*kcUsGm2iQdUUpT4XfRDeyw.png"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Project Structure</figcaption></figure><p id="913b" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在Models文件夹中创建一个名为<code class="fe la lb lc ld b">user.mode.js</code>的新文件。下面的代码使用mongoose实例创建了一个用户模式。用户模式由三个实体组成(名称、电子邮件和密码)。</p><p id="3ba5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">Models/user.model.js</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="57b2" class="lm ln iq ld b gy lo lp l lq lr">const mongoose = require('mongoose')</span><span id="4656" class="lm ln iq ld b gy oc lp l lq lr">const userSchema = new mongoose.Schema(<strong class="ld ir">{<br/>  name: {<br/>    type: String,<br/>    required: true,<br/>    max: 200,<br/>  },</strong></span><span id="d47d" class="lm ln iq ld b gy oc lp l lq lr"><strong class="ld ir">  email: {<br/>    type: String,<br/>    required: true,<br/>    unique: true,<br/>  },</strong></span><span id="ae29" class="lm ln iq ld b gy oc lp l lq lr"><strong class="ld ir">  password: {<br/>    type: String,<br/>    required: true,<br/>    min: 5<br/>  },<br/>},{timestamps: true}</strong><br/>)</span><span id="9001" class="lm ln iq ld b gy oc lp l lq lr">module.exports = mongoose.model('User',userSchema)</span></pre><h2 id="22f5" class="lm ln iq bd mk ml mm dn mn mo mp dp mq kn mr ms mt kr mu mv mw kv mx my mz na bi translated">2.<strong class="ak">用户注册</strong></h2><p id="2a03" class="pw-post-body-paragraph kc kd iq ke b kf nd kh ki kj ne kl km kn nz kp kq kr oa kt ku kv ob kx ky kz ij bi translated">现在让我们开始创建注册API。为此，我在Routes文件夹中创建了一个名为<code class="fe la lb lc ld b">auth.route.js</code>的新文件，其中保存了所有用于认证的路由。</p><p id="2bab" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">Routes/auth.route.js</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="7171" class="lm ln iq ld b gy lo lp l lq lr">const router = require('express').Router()<br/>const signup = require('../Controller/auth.controller')</span><span id="5aaf" class="lm ln iq ld b gy oc lp l lq lr"><strong class="ld ir">router.post('/signup',signup.signup)</strong></span><span id="dce8" class="lm ln iq ld b gy oc lp l lq lr">module.exports = router</span></pre><p id="7bc5" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">创建一个名为<code class="fe la lb lc ld b">signup</code>的新函数，接收来自客户端的请求和响应。现在用所有需要的参数创建一个用户对象。创建后，只需使用关键字<code class="fe la lb lc ld b">save</code>将用户文档插入数据库。</p><p id="3fff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">Controller/auth.controller.js</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="5d5a" class="lm ln iq ld b gy lo lp l lq lr">const User = require('../Models/user.model')</span><span id="b408" class="lm ln iq ld b gy oc lp l lq lr"><strong class="ld ir">async function signup(req,res,next) {<br/>  const user =  new User({<br/>    name: req.body.name,<br/>    email: req.body.email,<br/>    password: req.body.password<br/>  })<br/>  try{<br/>    const userSignup = await user.save()<br/>    res.send(userSignup)<br/>  }catch(err){<br/>    res.send(400).send(err) <br/>  }<br/>}</strong></span><span id="221e" class="lm ln iq ld b gy oc lp l lq lr">module.exports = {<br/>  signup,<br/>}</span></pre><p id="58c2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">最后，在<code class="fe la lb lc ld b">index.js</code>文件中包含授权路径。</p><p id="0cff" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">index.js</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="a643" class="lm ln iq ld b gy lo lp l lq lr">const router = require('./Routes/auth.route')</span><span id="7c7c" class="lm ln iq ld b gy oc lp l lq lr">//<strong class="ld ir">Router</strong><br/>app.use('/account/api',router)</span></pre><p id="ade6" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用所需的参数向<a class="ae ny" href="http://localhost:8000/account/api/signup" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/account/API/sign up</a>发出post请求。数据将被插入到MongoDB中。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oe"><img src="../Images/4ed0c9ca51b0232147abe252d1ebd580.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*mOsljVdavah4poflfLVeHw.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">User Registrations</figcaption></figure><h2 id="0cf6" class="lm ln iq bd mk ml mm dn mn mo mp dp mq kn mr ms mt kr mu mv mw kv mx my mz na bi translated">3.<strong class="ak">哈希密码</strong></h2><p id="57a5" class="pw-post-body-paragraph kc kd iq ke b kf nd kh ki kj ne kl km kn nz kp kq kr oa kt ku kv ob kx ky kz ij bi translated">散列密码是注册用户时要做的最重要的部分，因为如果密码没有散列，任何人都可以查看您的密码。哈希密码不会消耗很多时间。</p><p id="63a3" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了在Node js中散列密码，我们使用了一个叫做Bycrypt JS的包，它是开源的，并且易于使用。</p><p id="f879" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">Controller/auth.controller.js</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="90b3" class="lm ln iq ld b gy lo lp l lq lr">const User = require('../Models/user.model')<br/><strong class="ld ir">const bycrypt = require('bcryptjs')</strong></span><span id="48be" class="lm ln iq ld b gy oc lp l lq lr">async function signup(req,res,next) {</span><span id="7454" class="lm ln iq ld b gy oc lp l lq lr"><strong class="ld ir">  const salt = await bycrypt.genSalt(10);<br/>  hashpassword = await bycrypt.hash(req.body.password, salt)</strong></span><span id="6c48" class="lm ln iq ld b gy oc lp l lq lr"><strong class="ld ir">  </strong>const user =  new User({<br/>    name: req.body.name,<br/>    email: req.body.email,<br/>    password: <strong class="ld ir">hashpassword</strong><br/>  })<br/>  try{<br/>    const userSignup = await user.save()<br/>    res.send(userSignup)<br/>  }catch(err){<br/>    res.send(400).send(err) <br/>  }<br/>}</span><span id="94cf" class="lm ln iq ld b gy oc lp l lq lr">module.exports = {<br/>  signup,<br/>}</span></pre><p id="3644" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">现在用所需的参数向<a class="ae ny" href="http://localhost:8000/account/api/signup" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/account/API/sign up</a>发出post请求。这一次，您将看到密码字段已经被散列，普通用户永远无法读取。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi of"><img src="../Images/d838cb16d78ca4253a533dd398f88495.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*eTdHfG8Unm-jdAxjM0N-kg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Hashing Password</figcaption></figure><h2 id="3c0a" class="lm ln iq bd mk ml mm dn mn mo mp dp mq kn mr ms mt kr mu mv mw kv mx my mz na bi translated">4.<strong class="ak">注册后生成JWT令牌</strong></h2><p id="3488" class="pw-post-body-paragraph kc kd iq ke b kf nd kh ki kj ne kl km kn nz kp kq kr oa kt ku kv ob kx ky kz ij bi translated">在这一节中，让我们看看如何生成JWT令牌。生成一个JWT令牌是如此简单。只需将有效载荷和一些参数传递给<code class="fe la lb lc ld b">jwt.sign</code>函数，就可以获得一个新的JWT令牌。</p><p id="bac8" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">Controller/aut.controller.js</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="2793" class="lm ln iq ld b gy lo lp l lq lr"><strong class="ld ir">const jwt = require("jsonwebtoken");</strong></span><span id="ada9" class="lm ln iq ld b gy oc lp l lq lr">async function signup(req,res,next) {</span><span id="5bc8" class="lm ln iq ld b gy oc lp l lq lr"><strong class="ld ir">  const emailExist = await User.findOne({email: req.body.email})<br/>  if(emailExist){<br/>     res.status(400).json({"error":'Email already Exist'}) <br/>  }</strong></span><span id="4bd1" class="lm ln iq ld b gy oc lp l lq lr">  const salt = await bycrypt.genSalt(10);<br/>  hashpassword = await bycrypt.hash(req.body.password, salt)<br/>  const user =  new User({<br/>    name: req.body.name,<br/>    email: req.body.email,<br/>    password: hashpassword<br/>  })<br/>  try{<br/>    const userSignup = await user.save()<br/><strong class="ld ir">    const payload = {<br/>      user: {<br/>        id: userSignup.id<br/>      }<br/>    };<br/>    jwt.sign(payload,"anystring",{expiresIn: 10000},function(err, token)<br/>    {<br/>      if(err){<br/>        res.send(err)<br/>      }<br/>      res.status(200).json({<br/>        token,<br/>        userSignup<br/>      })<br/>    })</strong><br/>  } <br/>  catch(err){<br/>    res.status(400).json({'error':err})<br/>  }<br/>}</span></pre><p id="df41" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">使用所需的参数向<a class="ae ny" href="http://localhost:8000/account/api/signup" rel="noopener ugc nofollow" target="_blank">http://localhost:8000/account/API/sign up</a>发出post请求。这一次，您可以看到一个名为token的新字段正在生成。这个令牌帮助我们向服务器发出经过身份验证的请求。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/3a8ac9a0d4807e9bb8ec471673df9ad2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6yd1vrsdN6jTdoKMMfWiPg.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Generating JWT token</figcaption></figure><h2 id="12fa" class="lm ln iq bd mk ml mm dn mn mo mp dp mq kn mr ms mt kr mu mv mw kv mx my mz na bi translated">5.<strong class="ak">模式验证</strong></h2><p id="f9cf" class="pw-post-body-paragraph kc kd iq ke b kf nd kh ki kj ne kl km kn nz kp kq kr oa kt ku kv ob kx ky kz ij bi translated">验证是任何API的重要组成部分，因为它让用户知道发送的请求中是否有错误。</p><p id="f595" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">为了验证请求，这里我们使用了<code class="fe la lb lc ld b">express-validators</code>。在文件夹中间件中创建一个名为<code class="fe la lb lc ld b">validation.js</code>的新文件，并将下面的代码添加到其中。</p><p id="2be2" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">Middleware/validation.js</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="2de1" class="lm ln iq ld b gy lo lp l lq lr">const {check, validationResult} = require('express-validator');</span><span id="c8c1" class="lm ln iq ld b gy oc lp l lq lr">exports.validateUser = [<br/><strong class="ld ir">  check('name')<br/>    .trim()<br/>    .escape()<br/>    .not()<br/>    .isEmpty()<br/>    .withMessage('User name can not be empty!')<br/>    .bail()<br/>    .isLength({min: 3})<br/>    .withMessage('Minimum 3 characters required!')<br/>    .bail(),</strong></span><span id="7059" class="lm ln iq ld b gy oc lp l lq lr"><strong class="ld ir">  check('email')<br/>    .trim()<br/>    .normalizeEmail()<br/>    .not()<br/>    .isEmpty()<br/>    .withMessage('Invalid email address!')<br/>    .bail(),</strong></span><span id="69e2" class="lm ln iq ld b gy oc lp l lq lr"><strong class="ld ir">  check('password')<br/>    .not()<br/>    .isEmpty()<br/>    .withMessage('Password cannot be empty')<br/>    .isLength({min: 6})<br/>    .withMessage('Password must be more that 6 charecters'),</strong></span><span id="aa19" class="lm ln iq ld b gy oc lp l lq lr">  (req, res, next) =&gt; {<br/>    const errors = validationResult(req);<br/>    if (!errors.isEmpty())<br/>      return res.status(422).json({errors: errors.array()});<br/>    next();<br/>  },<br/>];</span></pre><p id="9dfb" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">将上述中间件导入到路由器文件中，调用<code class="fe la lb lc ld b">signup</code>路由中的中间件。</p><p id="1611" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><code class="fe la lb lc ld b">Route/auth.route.js</code></p><pre class="le lf lg lh gt li ld lj lk aw ll bi"><span id="cb6a" class="lm ln iq ld b gy lo lp l lq lr">const {validateUser} = require('../Middleware/validation');</span><span id="c36a" class="lm ln iq ld b gy oc lp l lq lr">router.post('/signup',<strong class="ld ir">validateUser</strong>,signup.signup)</span></pre><p id="ce97" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">这将自动验证我们的请求并返回错误。</p><figure class="le lf lg lh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/56d738e0954fafb81e1cd6575d434ab9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Q4OM2q5s6QbRF87CMgzzow.png"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Validation</figcaption></figure><p id="9fa0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">请访问我之前的博客，在那里我解释了如何用Node JS执行CRUD。</p><p id="434f" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">在下一篇博客中，我们将讨论JWT令牌的登录功能。保持联系。</p><p id="af9e" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如有任何疑问，请随时联系我。电子邮件:sjlouji10@gmail.com。领英:<a class="ae ny" href="https://www.linkedin.com/in/sjlouji/" rel="noopener ugc nofollow" target="_blank">https://www.linkedin.com/in/sjlouji/</a></p><p id="12ae" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">我的GitHub上的完整代码:</p><div class="ls lt gp gr lu lv"><a href="https://github.com/sjlouji/Node-js-JWT-auth---Medium" rel="noopener  ugc nofollow" target="_blank"><div class="lw ab fo"><div class="lx ab ly cl cj lz"><h2 class="bd ir gy z fp ma fr fs mb fu fw ip bi translated">sjlouji/Node-js-JWT-授权-介质</h2><div class="mc l"><h3 class="bd b gy z fp ma fr fs mb fu fw dk translated">在GitHub上创建一个帐户，为sjlouji/Node-js-JWT-auth-Medium开发做贡献。</h3></div><div class="md l"><p class="bd b dl z fp ma fr fs mb fu fw dk translated">github.com</p></div></div><div class="me l"><div class="oi l mg mh mi me mj jw lv"/></div></div></a></div><p id="ebd0" class="pw-post-body-paragraph kc kd iq ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">编码快乐！</p></div></div>    
</body>
</html>