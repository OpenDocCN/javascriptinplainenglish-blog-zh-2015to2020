<html>
<head>
<title>Handling Async Operations in Node.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">在Node.js中处理异步操作</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-nodejs-works-event-loop-handling-async-operation-4bfc2781110f?source=collection_archive---------6-----------------------#2020-11-05">https://javascript.plainenglish.io/how-nodejs-works-event-loop-handling-async-operation-4bfc2781110f?source=collection_archive---------6-----------------------#2020-11-05</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/534749ab9513b13e01860a4a53c2f333.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*RiJ5ZjZIoi9-oBaq"/></div></div><figcaption class="jv jw gj gh gi jx jy bd b be z dk">Photo by <a class="ae jz" href="https://unsplash.com/@claybanks?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clay Banks</a> on <a class="ae jz" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="9271" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">经过大量的挖掘，我了解了node.js是如何在内部工作的。这个博客是基于我的研究，保持耐心深入！😁</p><p id="da0e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">好吧。让我们先了解一下Node.js是什么🐘。<em class="ky">文档说:“Node.js是一个基于</em> <a class="ae jz" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank"> <em class="ky"> Chrome的V8 JavaScript引擎</em> </a> <em class="ky">构建的JavaScript运行时。”</em></p><p id="37ac" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里有很多花言巧语🤯。让我们一起把它分解💪首先，什么是运行时，为什么node.js是运行时？？？</p><p id="d22a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">运行时是为使代码工作而执行的任何代码。我们编写的代码将由运行时执行。运行时可以由编译器、解释器、执行代码的引擎、为代码进程提供线程的线程池组成。</p><p id="c9b6" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">引擎是负责执行程序的实际代码。<strong class="kc io">它将您的代码转换成机器代码，以便您的计算机(CPU)执行。</strong></p><p id="f7d1" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在JavaScript中——JavaScript引擎<strong class="kc io"/>将您的脚本翻译成可运行的机器代码指令，这样它就可以被CPU执行。</p><p id="7dfc" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io"> JavaScript运行时环境</strong>就像一个大容器，里面包含了其他小容器，比如引擎、堆、堆栈、web API、事件循环、回调队列。当JS引擎解析代码时，它开始将代码片段放入不同的容器中。</p><p id="0cbb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">重要的是<strong class="kc io">JAVAScript引擎的实现完全独立于运行时环境。</strong>发动机的开发没有考虑任何特定的环境。</p><p id="f95c" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">例如Chrome Browser和node.js使用相同的引擎——V8，但是它们的运行时间不同:在Chrome中，你有窗口、DOM对象等，而node给你缓冲区和进程。</p><p id="f2d8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">想象一个机器人正在烹饪食物:</p><ul class=""><li id="cf60" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated">你的代码将是机器人烹饪食物的指令。</li><li id="9693" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">发动机将是能够理解指令并对其采取行动的机器人。</li><li id="9342" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">运行时间将是液化石油气炉和用具。</li></ul><h2 id="6a49" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">Node.js是一个运行时环境，因为它有V8引擎、libuv threadpool和OS Async Helpers。所有这些都让您能够在服务器上编写JavaScript代码。</h2><p id="e8da" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">换句话说:“V8发动机”🦋</p><p id="fff7" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">文档上写着:<em class="ky">“V8是谷歌的开源高性能JavaScript和WebAssembly引擎，用C++编写。”</em></p><p id="4dfe" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">嗯，这意味着，V8是一个C++程序，它接收JavaScript代码，编译并执行它。V8的职责:</p><ol class=""><li id="999c" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx ml lf lg lh bi translated">编译并执行JS代码。</li><li id="6427" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx ml lf lg lh bi translated">处理调用堆栈，以某种顺序运行您的JS函数</li><li id="9aaf" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx ml lf lg lh bi translated">管理对象的内存分配—内存堆</li><li id="2a76" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx ml lf lg lh bi translated">不再使用的对象的垃圾收集</li><li id="e9db" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx ml lf lg lh bi translated">提供所有数据类型、运算符、对象和函数</li></ol><h2 id="b9ab" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated"><strong class="ak">注意:-V8对文档对象模型(DOM)一无所知——它是由浏览器提供的</strong></h2><p id="7abf" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">在理解事件循环之前，让我们先理解线程和进程。</p><p id="711f" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">你的计算机所做的任何事情都是使用进程来完成的。例如，文件由文本编辑器进程打开。音乐由音乐播放器进程播放。</p><p id="806e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">同样，为了运行您的节点程序，需要一个进程。当您在终端中运行<code class="fe mm mn mo mp b">node</code>时，就会创建这个过程。</p><p id="c6a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个进程都有线程，这些线程实际上执行进程程序内部的代码。线程使用你的CPU核心来执行代码。一个进程可以有多个线程。</p><p id="0a20" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">因此，当您使用<code class="fe mm mn mo mp b">node</code> : <code class="fe mm mn mo mp b">const mul= 4*2;</code>运行下面的代码时，会创建一个进程，并为该进程分配线程来执行代码。</p><h2 id="aed4" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated"><em class="mq"> NodeJS进程不是“单线程”的。“事件循环”是单线程的</em></h2><h1 id="ea47" class="mr lo in bd lp ms mt mu ls mv mw mx lv my mz na ly nb nc nd mb ne nf ng me nh bi translated">事件循环</h1><p id="fa1c" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">考虑以下代码:</p><pre class="ni nj nk nl gt nm mp nn no aw np bi"><span id="08f1" class="ln lo in mp b gy nq nr l ns nt">console.log("This is the first statement");</span><span id="89f7" class="ln lo in mp b gy nu nr l ns nt">setTimeout(<strong class="mp io">function</strong>(){<br/>console.log("This is the second statement");<br/>}, 5000);</span><span id="9c3c" class="ln lo in mp b gy nu nr l ns nt">console.log("This is the third statement");</span></pre><p id="15a8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出</p><pre class="ni nj nk nl gt nm mp nn no aw np bi"><span id="87ad" class="ln lo in mp b gy nq nr l ns nt">This is the first statement<br/>This is the third statement<br/>This is the second statement</span></pre><p id="78f9" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">Node.js不会为第二条语句等待5秒，而是执行第三条语句，同时等待5秒的计时器超时，尽管它是单线程的。怎么会？事件循环救援！</p><p id="dccf" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“事件循环”就是一个类似于<code class="fe mm mn mo mp b">for</code>循环或<code class="fe mm mn mo mp b">while</code>循环的循环。当您通过运行<code class="fe mm mn mo mp b">node app.js</code>启动节点流程时，会发生以下步骤:</p><ol class=""><li id="3c20" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx ml lf lg lh bi translated">V8引擎执行app.js中的代码</li><li id="b192" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx ml lf lg lh bi translated">V8发动机立即启动“事件循环”</li></ol><h2 id="f79c" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">现在有一点应该非常清楚了——事件循环不执行您的代码，V8引擎负责执行您的代码。</h2><p id="d42c" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">“事件循环”是循环中的一段代码，它从“作业/任务队列”中提取任务，并将其发送到<a class="ae jz" href="https://medium.com/swlh/in-depth-introduction-to-call-stack-in-javascript-a07b8513bcc3" rel="noopener">调用堆栈</a>中执行。</p><p id="353a" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">等等！坚持住！哪些任务和什么是“作业队列”？</p><p id="6d01" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以作业队列是FIFO数据结构。首先推送的任务将首先被作业队列拾取。</p><p id="6e16" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">这里的任务是函数内部需要执行的任何代码。当I/O操作、setTimeout、setInterval、setImmediate或OS任务完成时，回调函数被调用，然后进入作业队列。它将“等待”直到堆栈完全清空。当堆栈为空时，它会将队列开头的回调函数发送到堆栈。</p><p id="5e26" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">正如我上面提到的，事件循环类似于for或while循环。它通过某些阶段进行迭代，这被称为“事件循环迭代”。</p><p id="bc17" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个阶段都有自己的队列/堆，事件循环使用它们来推送/存储要执行的回调(Node.js中有一个误解，即只有一个全局队列，回调在其中排队等待执行，这是不正确的。).</p><p id="b75d" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">阶段包括:</p><h2 id="af98" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">1.计时器</h2><p id="d3e6" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">JavaScript中计时器的回调(setTimeout、setInterval)一直保存在堆内存中，直到它们过期。如果堆中有任何过期的计时器，事件循环将拾取与它们相关联的回调，并将其带到调用堆栈。</p><p id="75d3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">从技术上讲，计时器回调的执行是由事件循环的轮询阶段控制的(我们将在本文后面看到这一点)。</p><h2 id="120e" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">2.待定回调</h2><p id="ebd3" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">在这个阶段，会执行某些系统级回调。你真的不需要担心这个阶段(老实说，没有太多关于它的信息)，但我想让你知道它是存在的。</p><h2 id="4401" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">3.空闲/准备</h2><p id="8716" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">在这个阶段，事件循环不做任何事情。它处于闲置状态，准备进入下一阶段。</p><h2 id="83f9" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated">4.投票阶段</h2><p id="ae8d" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">这个阶段使Node.js变得独一无二。在这个阶段，事件循环会监视新的异步I/O回调，并执行挂起的I/O(fs.read file())回调。除了setTimeout、setInterval、setImmediate和closing回调之外，几乎所有的回调都被执行。</p><p id="1a88" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">轮询阶段有两个主要功能:</p><ol class=""><li id="f1d5" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx ml lf lg lh bi translated">计算它应该阻塞和轮询I/O多长时间，然后</li><li id="237c" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx ml lf lg lh bi translated">处理轮询队列中的事件。</li></ol><p id="3aba" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">当事件循环进入轮询阶段<em class="ky">并且没有定时器(setTimeout，setInterval)被调度</em>时，将发生以下两种情况之一:</p><ul class=""><li id="f932" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx le lf lg lh bi translated"><em class="ky">如果轮询队列不为空</em>，事件循环将遍历其回调队列并同步执行它们，直到队列耗尽或达到系统相关的硬限制。</li><li id="b3e4" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated"><em class="ky">如果轮询队列为空</em>，将会发生以下两种情况之一:</li><li id="023a" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">如果脚本已经由<code class="fe mm mn mo mp b">setImmediate()</code>调度，事件循环将结束轮询阶段并继续检查阶段以执行那些调度的脚本。</li><li id="6de3" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx le lf lg lh bi translated">如果脚本没有被<code class="fe mm mn mo mp b">setImmediate()</code>调度，事件循环将等待回调被添加到队列中，然后立即执行它们。</li></ul><p id="4719" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦轮询队列为空，事件循环将检查定时器<em class="ky">，其时间阈值已达到</em>。如果一个或多个计时器准备好了，事件循环将返回到计时器阶段来执行这些计时器的回调。</p><h2 id="b7b5" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated"><strong class="ak"> 5。立即检查/设置</strong></h2><p id="1d68" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated"><code class="fe mm mn mo mp b">setImmediate()</code>实际上是一个特殊的计时器，运行在事件循环的一个独立阶段。它使用一个libuv API(将会谈到它),该API在轮询阶段完成后调度回调来执行。</p><h2 id="1c19" class="ln lo in bd lp lq lr dn ls lt lu dp lv kl lw lx ly kp lz ma mb kt mc md me mf bi translated"><strong class="ak"> 6。结束回调</strong></h2><p id="2915" class="pw-post-body-paragraph ka kb in kc b kd mg kf kg kh mh kj kk kl mi kn ko kp mj kr ks kt mk kv kw kx ig bi translated">在这个阶段，事件循环执行与关闭事件相关的回调，如<code class="fe mm mn mo mp b">socket.on('close', fn)</code>或<code class="fe mm mn mo mp b">process.exit()</code>。</p><p id="3c89" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“libuv”是一个库，它为NodeJS运行时提供了一组线程(线程池)来执行长时间运行的任务，比如基于<code class="fe mm mn mo mp b">fs</code>模块的任务。默认情况下，它为每个节点进程提供4个线程，但是您可以通过将<code class="fe mm mn mo mp b">process.env.UV_THREADPOOL_SIZE</code>设置为您想要的任何值来更改线程池的大小。</p><p id="7eab" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">“操作系统异步助手”在任何低级操作系统操作发生时使用。例如，使用<code class="fe mm mn mo mp b">http</code>或<code class="fe mm mn mo mp b">https</code>模块的REST API调用或使用<code class="fe mm mn mo mp b">http.createServer()</code>创建web服务器。这些操作从不使用线程池，只要有CPU内核可供操作，就会立即执行。</p><p id="1b11" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一旦“libuv”或“OS Async Helpers”完成了它们的任务，它们就将回调放入“作业队列”中，以便“事件循环”拾取它们，然后将它们发送给“V8引擎”来执行。</p><h1 id="aefb" class="mr lo in bd lp ms mt mu ls mv mw mx lv my mz na ly nb nc nd mb ne nf ng me nh bi translated">例子</h1><figure class="ni nj nk nl gt jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi nv"><img src="../Images/3ed6083126857613c23dde7761d8d3f6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*foHH4bJeQVU_FP2p7Auesw.png"/></div></div></figure><p id="1da3" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">输出</p><pre class="ni nj nk nl gt nm mp nn no aw np bi"><span id="8eac" class="ln lo in mp b gy nq nr l ns nt"><strong class="mp io">2<br/>1</strong></span></pre><p id="63e8" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">让我们看看Node.js是如何执行这段代码的:</p><ol class=""><li id="a1c4" class="kz la in kc b kd ke kh ki kl lb kp lc kt ld kx ml lf lg lh bi translated">当调用main()时，首先会遇到带有回调的fs.readfile()。它的回调被推入I/O阶段队列，因为fs操作是I/O操作。</li><li id="afcf" class="kz la in kc b kd li kh lj kl lk kp ll kt lm kx ml lf lg lh bi translated">当事件循环看到文件读取操作完成时，它开始执行回调，<strong class="kc io">之后，它进入检查(setImmediate)阶段。</strong></li></ol><p id="cebb" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="kc io">检查</strong>相位是否在<strong class="kc io">定时器</strong>相位之前。因此，在I/O阶段，<code class="fe mm mn mo mp b">setImmediate</code>的回调将总是在<code class="fe mm mn mo mp b">setTimeout(fn, 0)</code>之前运行。</p><p id="dcb5" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用<code class="fe mm mn mo mp b">setImmediate()</code>优于<code class="fe mm mn mo mp b">setTimeout()</code>的主要优势在于，如果在一个I/O周期内进行调度，则<code class="fe mm mn mo mp b">setImmediate()</code>将始终在任何定时器之前执行，而与有多少定时器无关。</p><p id="c16e" class="pw-post-body-paragraph ka kb in kc b kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">感谢您的阅读！可以在Medium和<a class="ae jz" href="https://www.linkedin.com/in/prachi-singh-0369b1196/" rel="noopener ugc nofollow" target="_blank"> LinkedIn </a>上关注我。欢迎在评论中提问。🌼🌼🌼</p></div></div>    
</body>
</html>