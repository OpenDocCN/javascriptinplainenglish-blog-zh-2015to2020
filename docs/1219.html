<html>
<head>
<title>What Is ‘this’ In JavaScript?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的‘this’是什么？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/what-is-this-in-javascript-a64c754695e6?source=collection_archive---------9-----------------------#2020-02-13">https://javascript.plainenglish.io/what-is-this-in-javascript-a64c754695e6?source=collection_archive---------9-----------------------#2020-02-13</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="d81f" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解JavaScript中的<strong class="ak"> this </strong></h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/de59cff42e2c718e7748bfe01c2fcf9b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*ZIPSAve4bT5MZXRR"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@prateekkatyal?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Prateek Katyal</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="7266" class="kw kx iq bd ky kz la lb lc ld le lf lg jw lh jx li jz lj ka lk kc ll kd lm ln bi translated">JavaScript中的<strong class="ak"> this </strong>是什么？</h1><p id="8399" class="pw-post-body-paragraph lo lp iq lq b lr ls jr lt lu lv ju lw lx ly lz ma mb mc md me mf mg mh mi mj ij bi translated">它是执行当前函数的对象。所以在没有任何上下文的情况下，<strong class="lq ir">这个</strong>指的是浏览器中的全局对象，也就是窗口。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mk"><img src="../Images/4d449274808a584853766c39ebff9cfe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Y3YFTLWHKyO5WsBiafFblw.png"/></div></div></figure><p id="7f4d" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在标准函数中呢？<strong class="lq ir">该</strong>再次引用全局对象窗口，因为该功能是从全局对象执行的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi mq"><img src="../Images/ac2497ec6e337a89856037b9c7157c36.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BhbXeTvDzI0jC0-PD-hwbw.png"/></div></div></figure><p id="1512" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">如果我们将<code class="fe mr ms mt mu b">use strict</code>添加到我们的代码中，那么我们将会阻止<strong class="lq ir">这个</strong>在函数中的绑定。但是注意，在函数之外，<strong class="lq ir">这个</strong>仍然引用全局窗口对象。</p><p id="4b4f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在，让我们看一个对象方法。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/544d5e1c10c0a247f23ce19b6ab32120.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*V6hdQ9IijAWKdBa1ph7auA.png"/></div></figure><p id="8af0" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这里我们有一个使用<code class="fe mr ms mt mu b">fullName</code>方法的用户对象。在对象中，<strong class="lq ir">这个</strong>现在指的是它被调用的对象。在第一个console.log中，我们获取整个对象，在第二个日志中，我们使用模板字符串获取名字和姓氏。</p><p id="17db" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">记住这个将要引用的<strong class="lq ir">的一个简单方法是查看调用函数或方法的那一行。函数或方法左边的东西就是这个</strong>将要绑定的<strong class="lq ir">(参考<code class="fe mr ms mt mu b">user.fullName()</code>)。</strong></p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mv"><img src="../Images/ce0671bb8af691463f0be721e157d2e1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1244/format:webp/1*i5AusLpwPvv0rPQusPoYFQ.png"/></div></figure><p id="9a62" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这是编写相同方法的另一种方式。这里我们定义了函数，但是如果我们使用一个箭头函数呢？理解箭头函数如何工作以及何时使用和不使用它们是很重要的。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mw"><img src="../Images/dacdf49812f27e3d1abb2e111f288acb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1260/format:webp/1*5PB4WH05dao6O_dhV5WWsw.png"/></div></figure><p id="4e4a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这种情况下，我们不会使用arrow函数，因为arrow函数总是绑定到全局对象。这一次，在我们的第一个console.log中，我们得到了<code class="fe mr ms mt mu b">window</code>对象，在第二个日志中，我们得到了<code class="fe mr ms mt mu b">undefined</code>。</p></div><div class="ab cl mx my hu mz" role="separator"><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc nd"/><span class="na bw bk nb nc"/></div><div class="ij ik il im in"><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ne"><img src="../Images/1046f02d8e583edef9a2af0c94816cdf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1060/format:webp/1*sEoOub4KlO8LG2m2YhsoNA.png"/></div></figure><p id="446f" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">现在让我们在用户对象中添加一个宠物数组，然后添加一个新方法来列出每只宠物。因为我们现在知道在这个上下文中<strong class="lq ir">这个</strong>将指对象，我们可以使用<code class="fe mr ms mt mu b">this.pets.foreach()</code>。然后我们将创建一个函数并记录每只宠物。</p><p id="d7c9" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">但是现在如果我们也想在宠物前面加上用户名呢？所以我们想让它说“艾曼的猫/狗/鱼”。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/701ff1ce5e5fe5809b97357e5d50bcc6.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*PKeFPCfhaQdRbDFlqCbe0w.png"/></div></figure><p id="cc05" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">在这个上下文中，在<code class="fe mr ms mt mu b">foreach</code>方法中，我们有另一个函数，它不绑定到原始对象，而是绑定到全局对象。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi nf"><img src="../Images/78d014e530973f0bfbe8a2ef9be7de96.png" data-original-src="https://miro.medium.com/v2/resize:fit:1160/format:webp/1*d1zXf0Q-m_BD1WHPs3RepQ.png"/></div></figure><p id="ecde" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">所以在这个例子中，因为我们使用了<code class="fe mr ms mt mu b">foreach</code>，我们可以传递一个参数。所以我们将传入原始的<strong class="lq ir"> this </strong>，它引用了对象，现在它像预期的那样工作了。</p><p id="adfd" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">需要注意的是，并不是每个方法都支持参数。</p><p id="67ba" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">最后，让我们看一个构造函数。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi ng"><img src="../Images/2dc2dd9dc8ffa6a8cf05ffb74c718813.png" data-original-src="https://miro.medium.com/v2/resize:fit:958/format:webp/1*bbuFvIh2p_IkPQNEG99KkA.png"/></div></figure><p id="8b14" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">这里我们有一个<strong class="lq ir">用户</strong>函数，它接受一个名称参数，然后将<code class="fe mr ms mt mu b">this.name</code>赋给这个名称。然后它记录<strong class="lq ir">这个</strong>。为了初始化构造函数，我们创建了一个新用户的常量，它等于<code class="fe mr ms mt mu b">new User()</code>，我们给它传递了一个名字。</p><p id="9a2a" class="pw-post-body-paragraph lo lp iq lq b lr ml jr lt lu mm ju lw lx mn lz ma mb mo md me mf mp mh mi mj ij bi translated">通过使用<code class="fe mr ms mt mu b">new</code>，我们创建了一个对象，它用我们传递给它的名字返回这个对象。</p></div></div>    
</body>
</html>