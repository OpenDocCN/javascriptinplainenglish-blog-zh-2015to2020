<html>
<head>
<title>Object Instantiation Patterns in JavaScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript中的对象实例化模式</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/object-instantiation-patterns-in-javascript-37b4bd97b884?source=collection_archive---------7-----------------------#2020-05-04">https://javascript.plainenglish.io/object-instantiation-patterns-in-javascript-37b4bd97b884?source=collection_archive---------7-----------------------#2020-05-04</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><p id="4fba" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">对象是JavaScript中的一种复杂数据类型。就语法而言，对象被封装在花括号中，并被设置为等于变量。在花括号中，有一个无序的属性列表，每个属性都由逗号分隔的键值对组成。虽然键总是字符串，但相应的值可以是任何数据类型。</p><p id="55af" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">要创建一个对象(或创建一个对象的实例)，我们将从最简单的对象创建方法开始:对象文字的硬编码。从这里开始，我们将讨论更复杂的实例化类型(即函数实例化、函数共享实例化、原型实例化和伪经典实例化)。每个实例化模式都有自己的优缺点，这将在每个实例化类型的描述和代码示例中讨论。最后，我们将以伪经典实例化中ES6的实现来结束讨论。</p><h1 id="06db" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">对象文字的创建</h1><p id="8a11" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">创建对象最直接的方法是硬编码，创建一个对象文字。下面是一个对象文字的例子，遵循JavaScript中对象的标准语法。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/0f7beef32d855a2fb333ae761717e37a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*rEl0-WKsoaOzsp6j5s2fpQ.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Object Literal Creation</figcaption></figure><h2 id="d9e6" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">对象字面意义的利弊</h2><p id="fad7" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">创建一个对象文字是一个非常直接的实现，因为如果你只是在程序中创建一个特定对象的实例，它是清晰易读的。但是，在程序需要对象的多个实例的情况下，创建一个对象文本并不理想，因为如果您要创建一个不同的动物，就必须完整地编写整个对象。这是非常低效的。</p><h1 id="68f6" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">功能实例化模式</h1><p id="5cff" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">创建对象的函数实例化模式正如其标题所暗示的那样:它通过使用函数来创建对象的实例。命名约定要求在函数名的开头使用大写字母，因此对于这个实例化模式，我们的函数将被称为Animal。该函数包含某种存储对象，以包含对象的属性(以及本质上是具有函数值的键的方法)。在下面的例子中，第47行创建了与上面的对象文字(goblin)相同的对象文字。每次调用Animal函数时都会创建一个新对象。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mq"><img src="../Images/22ea556d201d1f73bdae5eca147bb187.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*ApI64KYOHL3aDUrCniRHZg.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Functional Instantiation Pattern</figcaption></figure><h2 id="6432" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">功能实例化的利弊</h2><p id="e555" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">使用函数实例化模式来创建对象的一个好处是，它非常易读和易于理解，这意味着即使是对对象和函数没有太多了解的人也能够理解在创建和调用函数时正在做什么。此外，函数实例化使您可以轻松地创建同一对象的多个实例，甚至使用新的参数。这提高了创建object literal的效率，因为要为一个新的动物创建一个animal对象，您只需再次调用animal函数，如上面第48行所示，而不必为girlKitty完全重写object literal。</p><p id="d570" class="pw-post-body-paragraph jn jo iq jp b jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk ij bi translated">尽管使用函数实例化模式比创建对象文字更有效，但代码是不可共享的，这意味着方法在每次实例化时都被复制到新对象中。</p><h1 id="aff0" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">功能共享实例化模式</h1><p id="e8dd" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">功能共享实例化模式与功能实例化模式的相似之处在于，它也创建一个对象实例作为运行功能的结果。然而，在函数共享模式中，方法存储在一个独立的容器中，该容器存在于函数之外。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mr"><img src="../Images/97619daa50f8f54ff7abaf9258109fc1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*WhBr8_wYlHJN50E_gojLuw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Functional Shared Instantiation Pattern</figcaption></figure><h2 id="d484" class="me km iq bd kn mf mg dn kr mh mi dp kv jy mj mk kz kc ml mm ld kg mn mo lh mp bi translated">功能共享实例化的利弊</h2><p id="d598" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">由于在上面的animalMethods示例(第60–75行)中，方法存储在函数之外，因此与函数实例化相比，效率得到了提高，因为方法是在一个独立的、可重用的对象中，而不是与对象的新实例一起创建的。然而，如果方法在任何时候被修改，这可能导致这种实例化方法容易出错。</p><h1 id="eb3c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">原型实例化模式</h1><p id="bf4b" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">对象创建的原型实例化模式使用Object.create()创建一个新对象，允许它访问原型链，从而允许对象的新实例在每次调用函数时访问对象的方法。在方法创建期间(第91–104行)，使用了animal的原型属性。此外，可以在用于创建方法的函数中使用关键字this代替animalObj，而不必从对象调用animalObj。这种实例化模式是我们已经讨论过的对象创建模式中最有效和最不容易出错的。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi ms"><img src="../Images/b9b6a857a84c1e8da0973489581e3d1a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6LDqVhEB-nXu65hx-2r5xA.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Prototypal Instantiation Pattern</figcaption></figure><h1 id="005b" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">伪经典实例化模式</h1><p id="d9b4" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">用于对象创建的伪经典实例化模式是比原型模式更有效的对象实例化模式，因为代码行更少。在Animal函数中，我们不再需要包含Object.create()或return语句的行；这些语句隐含在伪经典模式中，这是由于在Animal函数时在第131行实现了关键字new。因为animalObj不在Animal函数中，所以我们依赖关键字this来创建每个对象属性和方法。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mt"><img src="../Images/168561b50f6a400aeddae9687f05faee.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*IsJNo5QY6eStc20XAn6Y1Q.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">Pseudoclassical Instantiation Pattern</figcaption></figure><h1 id="87f8" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">将ES6用于伪经典实例化模式</h1><p id="d634" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">当实现ES6语法时，伪经典的实例化模式有一些变化。首先，第138行使用了关键字class。此外，第139行使用了constructor关键字来创建构造函数。在方法的实现中，不再需要使用prototype属性，因为我们现在是在类范围内工作。注意，第162行仍然使用了new关键字。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi mu"><img src="../Images/bc00625e5ecea20e0ea1c21b4953c3b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*UzM-0qESGnx2teYfjwobLw.png"/></div></div><figcaption class="ma mb gj gh gi mc md bd b be z dk">ES6 Pseudoclassical Instantiation Pattern</figcaption></figure><h1 id="e33c" class="kl km iq bd kn ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li bi translated">结论</h1><p id="f7fe" class="pw-post-body-paragraph jn jo iq jp b jq lj js jt ju lk jw jx jy ll ka kb kc lm ke kf kg ln ki kj kk ij bi translated">上面我们已经讨论了JavaScript中现存的所有对象实例化模式。虽然后一种方法对于新手来说在实现和语法上可能看起来更加晦涩，但是它们允许您提高效率，减少程序的冗长和冗余。</p></div></div>    
</body>
</html>