<html>
<head>
<title>Utility Types in TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">TypeScript中的实用工具类型</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/utility-types-in-typescript-feafcc18433?source=collection_archive---------1-----------------------#2019-12-09">https://javascript.plainenglish.io/utility-types-in-typescript-feafcc18433?source=collection_archive---------1-----------------------#2019-12-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="7253" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">适合各种场合的灵活类型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4fd85664394542afa39dab9846e25cf7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*cIHPCO7uJ48lY_B4"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://unsplash.com/@ugmonk?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jeff Sheldon</a> on <a class="ae kv" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="548f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我最近参与了一个项目，在这个项目中，我必须用JSON编写一大堆数据。让我们不要太深入为什么——只要说我在寻求一个问题的最简单的解决方案就够了。</p><p id="e960" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">许多记录都有共同点——有些字段我不想重复，因为大量记录都有相同的值。我还想计算某些字段，比如ID(让我们不要分析这是否是一个好主意——为了这篇文章，我简化了这个问题)。所以我决定变得聪明一点，尝试这样做:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="7bbb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">想法是创建一个不完整记录的数组，然后映射数组的每一项以包含额外的字段。</p><p id="ce64" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这在减少重复方面非常有效，但是我最终失去了类型安全性，因为为了声明我的部分数据数组，我必须使用<code class="fe lu lv lw lx b">any</code>类型。</p><p id="aded" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我本可以通过在变量名后使用一个问号来使界面中缺少的字段成为可选的，但是由于这些字段在最终输出中是必需的，这看起来像是错误的解决方案。</p><p id="38bc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">或者，我可以声明一个描述部分数据的新类型，但这感觉有点太辛苦了，因为比我上面的例子中有更多的字段。另外，给事物命名很难，所以我不想为一个局部类型想出一个笨拙的名字，我只是为了减少重复而发明的。</p><p id="e4d9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以我决定:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="6f3e" class="mc md iq lx b gy me mf l mg mh">const INFANTRY_DATA: any[]</span></pre><p id="e988" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">由于<code class="fe lu lv lw lx b">any</code>类型的工作方式，编译器不会检查任何丢失的字段，也不会查看我是否试图分配了错误的类型。这很成问题。如果我拼错了一张唱片的<code class="fe lu lv lw lx b">name</code>怎么办？可能有一百条记录，我可能不会发现错误，直到用户向我报告。</p><p id="d9d0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在遇到这个问题的时候，我被困在没有互联网的长途火车旅行中，我唯一可以支配的资源是<a class="ae kv" href="https://kapeli.com/dash" rel="noopener ugc nofollow" target="_blank"> Dash </a>。我下载了一堆我认为会有用的文档，包括TypeScript文档。如果你没有尝试过Dash，我强烈推荐它。我倾向于寻找第一个堆栈溢出的答案来解决我的技术难题，但是Dash允许/鼓励我使用文档来代替。谁会想到文档真的有用呢？</p><p id="afe0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我搜索“部分类型”，幸运的是，这正是我得到的。</p><h1 id="3e16" class="mi md iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">部分类型</h1><p id="37e1" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这是TypeScript的“实用类型”之一，它为使用<code class="fe lu lv lw lx b">any</code>提供了一个很好的替代方案。分部类型可以包含基类型的任何属性，但不能包含其他任何属性。</p><p id="17df" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是很好的第一步，因为这意味着我的属性名中不会有任何拼写错误，并且还可以防止我分配错误的值。但是它没有覆盖丢失的字段，因为分部类型只是使每个属性都是可选的。因此，如果我忘记为单个记录包含<code class="fe lu lv lw lx b">cost</code>，我仍然会有一个在编译时会被忽略的问题，如下所示:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="ecc1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这还有一个问题。正如我所说的，<code class="fe lu lv lw lx b">Partial&lt;Unit&gt;</code>只是让<code class="fe lu lv lw lx b">Unit</code>中的每个字段都是可选的。这意味着它不能再分配给<code class="fe lu lv lw lx b">Unit</code>，因为类型不同。所以我不得不在最后做一个尴尬的回转型到<code class="fe lu lv lw lx b">Unit</code>，这可以很容易地掩盖错误，否则会在编译期间被捕获。毕竟，我可以将任何东西强制转换为type <code class="fe lu lv lw lx b">Unit</code>，TypeScript将会假设我知道自己在做什么。</p><h1 id="b6f4" class="mi md iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">挑选</h1><p id="8163" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">结果证明这非常接近我所需要的。<code class="fe lu lv lw lx b">Pick</code>允许您指定类型，并选择您想要使用的字段，如下所示:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="647a" class="mc md iq lx b gy me mf l mg mh">let partialData: Pick&lt;OriginalType, ‘field1’ | ‘field2’ | ‘field3’&gt;;</span></pre><p id="9ffc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">所以对于我之前的例子，我能够指定哪些字段应该出现在分部类型中:</p><figure class="kg kh ki kj gt kk"><div class="bz fp l di"><div class="ls lt l"/></div></figure><p id="291f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">您甚至会注意到，我能够通过声明一次分部类型，然后对每个数据子集重用它来减少重复。这使我恢复了一些类型安全，但在我的例子中，这相当麻烦，因为虽然我的例子只有几个字段，但我的原始数据有几十个，我只想删除2-3个字段。</p><p id="8b2c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果有办法<em class="ne">省略</em>字段而不是<em class="ne">选择</em>字段就好了……哦，等等，有办法！</p><h1 id="c304" class="mi md iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">省略</h1><p id="0131" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">这与Pick相反。后者让您选择想要保留的字段，而Omit会询问您想要删除哪些字段。因此，我能够省略掉我想要丢失的两个字段，保留其余的字段。</p><p id="edea" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">最终得到的分部类型看起来像这样:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="65de" class="mc md iq lx b gy me mf l mg mh">type PartialUnit = Omit&lt;Unit, ‘id’ | ‘experience’&gt;;</span></pre><h1 id="aaca" class="mi md iq bd mj mk ml mm mn mo mp mq mr jw ms jx mt jz mu ka mv kc mw kd mx my bi translated">结论</h1><p id="05f3" class="pw-post-body-paragraph kw kx iq ky b kz mz jr lb lc na ju le lf nb lh li lj nc ll lm ln nd lp lq lr ij bi translated">直到大约一个月前，我才知道实用程序类型的存在。现在我这样做了，它们是TypeScript提供的使我更有效率的令人敬畏的事物的常规武库的一部分。这些只是我最终使用的三个工具，但是浏览其他工具可以展示一些用于创建自描述代码的有用工具，这毕竟是TypeScript的真正目标。</p><p id="0d41" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我不会告诉你TypeScript必须提供的每种实用程序类型，因为这就是文档的用途。去看看吧，你可能会在里面找到有用的东西。</p></div></div>    
</body>
</html>