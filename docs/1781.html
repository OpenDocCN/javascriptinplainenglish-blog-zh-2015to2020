<html>
<head>
<title>Two situations where to avoid Arrow Functions</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">避免箭头功能的两种情况</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/you-should-never-use-an-arrow-function-in-any-of-these-two-situations-8bc2fbbc39b8?source=collection_archive---------0-----------------------#2020-04-22">https://javascript.plainenglish.io/you-should-never-use-an-arrow-function-in-any-of-these-two-situations-8bc2fbbc39b8?source=collection_archive---------0-----------------------#2020-04-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="fbb9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中箭头函数的良好实践</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/62949496b794d913a3933e9117560afe.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*jcUfwCF3lhmJyv7fYDpEAQ.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Photo by <a class="ae kv" href="https://www.pexels.com/@braydenlaw?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Brayden Law</a> from <a class="ae kv" href="https://www.pexels.com/photo/photo-of-woman-sitting-on-rooftop-1738975/?utm_content=attributionCopyText&amp;utm_medium=referral&amp;utm_source=pexels" rel="noopener ugc nofollow" target="_blank">Pexels</a></figcaption></figure><p id="2eed" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">箭头函数表达式很棒，它们是函数中最小的语法，但是当它们用在这两个比你想象的要频繁得多的地方时，我被咬了一口。</p><h1 id="7180" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">测试框架</h1><p id="8632" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">编写比测试框架超时阈值更长的测试用例是很常见的，这就是为什么测试框架允许您指定测试超时的原因；例如，Mocha允许您灵活地提供自己的每次测试超时。</p><p id="cd3f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">将自己置于以下简化的场景中:</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="4e33" class="mu lt iq mq b be mv mw l mx my">describe('Your suite', () =&gt; {<br/>  it('Your test', (done) =&gt; {<br/>    setTimeout(done, 2005);<br/>    assert.ok(true); // default timeout for Mocha is 2000ms<br/>  });<br/>});</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/b02482c548c3dd7c6f4d9718f3f66bcf.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*AiZ1wc77fo17KbGD.gif"/></div></figure><p id="21ae" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这个测试将返回:<code class="fe na nb nc mq b">Error: Timeout of 2000ms exceeded.</code>，Mocha允许您做的是设置<code class="fe na nb nc mq b">this.timeout</code>来控制测试用例超时阈值，就像这样:</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="e778" class="mu lt iq mq b be mv mw l mx my">describe('Your suite', () =&gt; {<br/>  it('Your test', (done) =&gt; {<br/>    this.timeout(3000); // set timeout threshold<br/>    setTimeout(done, 2005);<br/>    assert.ok(true); // default timeout for Mocha is 2000ms<br/>  });<br/>});</span></pre><p id="b2b7" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这样测试就通过了:</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/cf3f15db9b9956d69b8a5781f8951f33.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*vI_dBKBm6l4VI9xW.gif"/></div></figure><p id="d56b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe na nb nc mq b">TypeError: this.timeout is not a function</code>等等，什么？</p><p id="bc03" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">像Mocha这样的测试框架依赖于bind，通过<code class="fe na nb nc mq b">this</code>，即:<code class="fe na nb nc mq b">this.skip</code> <code class="fe na nb nc mq b">this.timeout(1000)</code>传递配置，但是Arrow函数表达式不能是bind，这意味着我们需要编写一个函数表达式。</p><p id="e0ba" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这是一个如此普遍的痛点，以至于<a class="ae kv" href="https://mochajs.org/#arrow-functions" rel="noopener ugc nofollow" target="_blank">摩卡文档有一个章节</a>阻止你使用箭头函数。</p><blockquote class="nd ne nf"><p id="5e57" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated">不鼓励将<a class="ae kv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" rel="noopener ugc nofollow" target="_blank">箭头函数</a>(又名“lambdas”)传递给Mocha。Lambdas词汇绑定<code class="fe na nb nc mq b"><em class="iq">this</em></code>并且不能访问Mocha上下文。</p></blockquote><p id="8ce8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">让我们用关键字<code class="fe na nb nc mq b">function</code>再试一次:</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="0d84" class="mu lt iq mq b be mv mw l mx my">describe('Your suite', () =&gt; {<br/>  it('Your test', function (done) { // &lt;- function keyword<br/>    this.timeout(3000); // set timeout threshold<br/>    setTimeout(done, 2005);<br/>    assert.ok(true); // and it finally passes the test!! 👏<br/>  });<br/>});</span></pre><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mz"><img src="../Images/0ffaf7f0a6d2366b135ed97570f31f42.png" data-original-src="https://miro.medium.com/v2/resize:fit:960/0*r5MO6gfb5cNzCZrU.gif"/></div></figure><p id="8449" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">值得庆幸的是，并非所有的框架都是一样的，其他测试框架将超时阈值作为第三个参数，省去了您记住这个微小但令人讨厌的细微差别的麻烦。</p><p id="7811" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我给你的建议是:用函数表达式编写所有的测试用例函数，如果你处于类似的情况，这带来三个主要的好处:</p><ol class=""><li id="9c0d" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated">你忘记了这个案例，你已经有太多的领域边缘案例了，为什么还要增加一个额外的编程边缘案例呢？</li><li id="beae" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">你的代码更加统一，所有的测试用例都会写成函数表达式，而不是只写那些需要<code class="fe na nb nc mq b">this</code>的；统一的好处超过少写4个字符的好处。</li><li id="9011" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated">当你需要这些特性时，避免改变语法，然后再考虑第二点。</li></ol><h1 id="95a8" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated"><strong class="ak">预计吊装位置</strong></h1><p id="7f43" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">你可能用过这种模式，顺便说一下，这很有趣:</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="cfb4" class="mu lt iq mq b be mv mw l mx my">function bigFn(arg) {<br/>  const quickFn = (...) =&gt; (...); // keep the one line outside for clean code<br/>  const goodName = quickFn(...);<br/>}</span></pre><p id="7e69" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那很好，不是吗？它允许你命名所有这些一行程序，并给你的代码带来更多的意义，+1来清理代码，你做得很好，我是认真的💛。</p><p id="6f7a" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我要向你展示的是当我们严重依赖这种模式而不是使用函数表达式时会发生什么，你可能自己也经历过。</p><p id="4542" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当编写JavaScript时，我们可能会如此习惯于提升，以至于我们不再注意它拯救我们的所有情况，当它不这样做时，可能需要一段时间才能理解发生了什么。如果你想知道什么是提升，我将提供一个快速的定义:</p><blockquote class="nd ne nf"><p id="b393" class="kw kx ng ky b kz la jr lb lc ld ju le nh lg lh li ni lk ll lm nj lo lp lq lr ij bi translated"><strong class="ky ir">提升</strong>是代码执行前将所有声明移动到作用域顶部的默认行为。</p></blockquote><p id="a05f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">提升允许你编写和使用函数表达式，而不用考虑什么先来，这是JavaScript最好的部分之一。</p><p id="c68f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">看一下下面的场景:</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="a94e" class="mu lt iq mq b be mv mw l mx my">function bigFn(arg) {<br/>  // ....<br/>  const goodName2 = quickFn2(args); // quickFn2 is not defined at this point 😕<br/>  // ....<br/>  const quickFn2 = (...) =&gt; (...);<br/>}</span></pre><p id="7dd8" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">用这种模式声明的函数对于一行程序来说很好，但是它们失去了JavaScript的部分动力。</p><p id="36db" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">碰巧用<code class="fe na nb nc mq b">const</code>关键字声明的变量确实被提升了，但是它们没有被初始化，当它们的词法绑定在运行时被评估时，它们将被初始化，英语:</p><p id="01dd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript引擎必须计算赋值操作符(<code class="fe na nb nc mq b">=</code>)的右边，并将其赋值给左边，这样引用才被认为是初始化的并且可用。这只会在运行时发生，按顺序，最终迫使你在声明变量之后使用用<code class="fe na nb nc mq b">const</code>关键字声明的变量，否则，你会得到一个引用错误，因为你正在访问一个未初始化的变量。</p><p id="b7dc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><strong class="ky ir">这种模式在遗留代码、意大利面条式代码或大文件中尤其危险</strong>，这些代码倾向于使用在任何时间任何地方声明的函数，严重依赖于JavaScript函数性质，你将增加另一个可能出错的东西。</p><p id="0d90" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这些情况下的一个经验法则是:坚持使用你可以在任何地方使用的普通函数，不要担心在运行时可能发生的引用错误，这种错误在非常罕见的情况下，在最烦人的时候，比如星期五下午离开办公室之前。</p><p id="8194" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">严重依赖这种模式会将您的代码库带回到顺序编程，迫使您在顶层定义所有函数以便以后使用。</p><p id="6530" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">JavaScript已经努力让你使用在文件中任何地方定义的函数表达式，为什么还要担心函数初始化呢？不要因为在合适或有疑问的时候使用好的旧函数表达式而不使用箭头函数，就认为自己是个自食其果的人。</p><h1 id="0ea6" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">奖金</h1><h2 id="8320" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">关于箭头函数表达式的主体</h2><p id="8937" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">箭头函数表达式不需要有主体，它们可以直接计算表达式并返回它的值，而不需要<code class="fe na nb nc mq b">return</code>关键字，所以你可以写这样的东西:</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="9a36" class="mu lt iq mq b be mv mw l mx my">const sum = (a, b) =&gt; a + b;</span></pre><p id="8995" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">雄伟，不是吗？有效的代码。直到它不存在。最糟糕的是，它可能会失败。实际上，我们在这里谈论的是JavaScript，一切都可能失败。</p><p id="23a4" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">当某些东西不能相加时(双关语)，您需要在函数体中放置工具，它变成这样:</p><pre class="kg kh ki kj gt mp mq mr bn ms mt bi"><span id="4609" class="mu lt iq mq b be mv mw l mx my">const sum = (a, b) =&gt; { // &lt;- we need to add body<br/>  console.log(a, b); // Please, consider that production is 1000x times more complex<br/>  return a + b; // &lt;- we need to use the return keyword<br/>}</span></pre><p id="d689" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这里发生的情况是，我们现在处于一种需要我们重构语法的情况，从立即返回一个表达式变成一系列语句，使用<code class="fe na nb nc mq b">return</code>关键字返回一个表达式。</p><p id="01e6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在您完成调试并最终修复错误之后，您将删除主体并再次创建一个一行程序。<strong class="ky ir">这个过程重复了很多次</strong>。当有人忘记返回到一行程序时，它甚至可能是您repo中的一个持续差异。</p><p id="3026" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你最终调试了一个单行的Arrow函数表达式:<strong class="ky ir">保留body </strong>，不要再费心去移除它，你所经历的将会再次发生，由你或你的一个队友来完成，为什么要浪费时间和为此制造分歧。它可能看起来紧凑而时尚，但是如果不断地添加和移除身体会降低你的团队的生产力，那就不要这样做。</p><p id="fa56" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果您的Arrow函数是一个复杂的表达式，容易受到调试工具的影响，不要偷懒，只写整个函数体，也不要过于主动，在调试后删除函数体，这样您就可以不用担心，为您的团队节省那些不断的更改。</p><h2 id="8768" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">箭头函数表达式的完美位置</h2><p id="6744" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><strong class="ky ir">箭头函数表达式的最佳位置是不可重用的特定位置函数</strong>，比如<code class="fe na nb nc mq b">array.map</code> <code class="fe na nb nc mq b">array.filter</code>的谓词。</p><p id="aa60" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">每个工具都可能被滥用，带来更多的伤害，你发现过其他不好的箭头函数表达式吗？请在下面留下评论👇</p><h2 id="de81" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">无耻的插头</h2><p id="0d79" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我希望我的旅程能对你有所帮助。如果你喜欢这篇文章，也许你也会喜欢其他的:</p><ol class=""><li id="210c" class="nk nl iq ky b kz la lc ld lf nm lj nn ln no lr np nq nr ns bi translated"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/narrated-by-test-cases-redux-action-retry-b2e004c4c823" rel="noopener">由测试用例叙述:Redux动作重试</a>。</li><li id="3d12" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><a class="ae kv" href="https://medium.com/javascript-in-plain-english/the-6tools-that-changed-javascript-for-me-3ee1faf40585" rel="noopener">为我改变JavaScript的6个工具</a>。</li><li id="bee8" class="nk nl iq ky b kz nt lc nu lf nv lj nw ln nx lr np nq nr ns bi translated"><a class="ae kv" href="https://medium.com/better-programming/how-management-is-limiting-your-potential-as-a-developer-abb46f18e097" rel="noopener">管理层如何限制你作为开发人员的潜力</a>。</li></ol><p id="ade0" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如果你喜欢这篇文章，请<a class="ae kv" href="http://eepurl.com/hg7AeP" rel="noopener ugc nofollow" target="_blank">订阅我的时事通讯</a>，在<a class="ae kv" href="https://www.instagram.com/codingedgar/" rel="noopener ugc nofollow" target="_blank"> Instagram @codingedgar </a>上关注我，我会在那里发布关于编程概念的漂亮图片，在<a class="ae kv" href="https://twitter.com/codingedgar" rel="noopener ugc nofollow" target="_blank"> Twitter @codingedgar </a>上关注我，我会在那里谈论……事情。测试你的代码，刷牙，留下一些掌声和美好的评论💬</p><h2 id="9d95" class="ny lt iq bd lu nz oa dn ly ob oc dp mc lf od oe me lj of og mg ln oh oi mi oj bi translated">用简单英语写的JavaScript的注释</h2><p id="6b31" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">我们已经推出了三种新的出版物！请关注我们的新出版物:<a class="ae kv" href="https://medium.com/ai-in-plain-english" rel="noopener"> <strong class="ky ir"> AI in Plain English </strong> </a>，<a class="ae kv" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="ky ir">UX in Plain English</strong></a>，<a class="ae kv" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="ky ir">Python in Plain English</strong></a><strong class="ky ir"/>——谢谢，继续学习！</p><p id="ac6b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">我们也一直有兴趣帮助推广高质量的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kv" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="ky ir">submissions @ plain English . io</strong></a><strong class="ky ir"/>，使用您的Medium用户名，我们会将您添加为作者。另外，请让我们知道您想加入哪个/哪些出版物。</p></div></div>    
</body>
</html>