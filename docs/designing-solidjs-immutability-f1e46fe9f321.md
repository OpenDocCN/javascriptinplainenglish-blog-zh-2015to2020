# 设计固体:不变性

> 原文：<https://javascript.plainenglish.io/designing-solidjs-immutability-f1e46fe9f321?source=collection_archive---------7----------------------->

## 反应式状态管理可以既是不可变的又是最高效的吗？

![](img/a09031af77e3603ba3b7b7193d064462.png)

Space Ice Wall from Wallpaper Abyss wall.alphacoders.com

[*SolidJS*](https://github.com/ryansolid/solid) *是一个高性能的 JavaScript UI 库。本系列文章深入探讨了设计该库的技术和决策。使用 Solid 不需要了解这些内容。今天的文章主要关注 Solid 的不可变反应状态管理。*

这总是那些有分歧的话题之一。可变性与不可变性，OOP 与函数式编程，命令式与声明式。我之前在我的二元性文章中提到过它并不是那么非黑即白。但是我发现这是我在用 Solid 谈论 API 时最需要捍卫的地方。我将探究为什么 Solid 似乎是唯一不可变的细粒度反应式库，为什么我如此坚持这样做，以及为什么这种方法优于任何不可变的系统。

请注意，我可能会在这篇文章中触及一些固执己见的话题，并分享我的想法。

# 被动

反应式库有几种形状和大小，当试图定义术语时，这往往是无穷无尽的混乱来源。一方面，你有 Rx，比如 RxJS，它基于布线流。这些库在数据管道流上操作，本质上很容易不可变，因为它们可以在每个转换步骤创建新的对象。另一方面，你有我所说的基于创建反应图或树的细粒度反应库。您有一个类似的可观察原语作为起点，但不同之处在于每个节点都有一个值。通过创建计算表达式，包装读取这些节点的值以生成新的节点，您可以编写行为。后一种方法用于固体、MobX、Vue、苗条、击倒等..

在这两种方法中，核心原子是不变的。这些库基于控制变化。如果某些东西可以改变他们系统之外的数据，他们不会知道某些东西已经改变。反应式库的运行循环是基于级联数据传播的(它反应…)，所以它没有机会区分值，除非它为此目的而连接。它期望控制所有的数据交互。

所以反应式库是不可变的？不是细粒度的。我想强调的是，虽然它们是基于这些外部不变的原子，但如果你把系统作为一个整体来看，有几个数据点，这些数据点组成了树，而树本身也不是不变的。虽然 atom 的内部是，但是您需要保留引用来跟踪变化并通知订阅者。数据与反应图位于同一位置。你不能每次改变就把它扔掉。所以不，这些系统是建立在突变基础上的。

# 变更传播

就像把石头扔进湖里，有时更像把炮弹扔进游泳池，做出改变会对你的系统产生一连串的影响。反应式库使得编写行为和构建依赖关系网变得如此容易。我的意思是，交互是什么并不重要，我们可以将其连接起来并自动化。没有从上到下，没有从左到右。这些链可以在任何时候从图中的任何节点开始。如果看起来很混乱，你是对的。

看，反应式库在 2010 年初风靡一时，但在差不多一年半的时间里，它们完全被 React 压制了。如果你没有在那种混乱中经历过开发，可能很难理解像单向流这样的东西。我之所以提到这一点，是因为反应式库正在再次兴起，重要的是不要忘记过去的教训。

对他们有利的是，这一代库已经通过批量变更和图形隔离解决了大多数问题。他们以多种不同的方式实现这些目标。Solid 使用显式同步批处理，在提交更改并将相应的节点标记为过时或潜在过时之前收集所有更改。在当前上下文完成其周期之前，不会执行下游更改。从那里，我们使用推/拉机制来确定重新计算任何过时的值。这种方法非常类似于 MobX 中使用的事务处理方法。没有下游过程看到部分改变的状态。

但我更想利用的是图形隔离。大多数库都采用了强组件模型。像 MobX 或 Vue 这样的库，它们的活性原子由组件决定生死。Svelte 的反应系统基本上是编译到你的组件代码中的。相比之下，Solid 实际上是那些早期库的倒退，所以维护控制必须以不同的方式完成。

如果不使用虚拟 DOM 或 React 或 Vue 之类的自顶向下的渲染方法，并且不希望抛弃 Svelte 之类的可移植性，组件隔离不会给我们带来好处。我们不要抱有任何幻想。所有这些库都有一些进行全局存储的方法，这将我们带回到一个共享的上下文中。所以他们需要用稍微不同的方法来解决这个问题。

对于一个反应式库，难道没有一个简单的状态解决方案吗？React 早期让我们习惯于为本地和全球状态提供不同的解决方案，但这完全没有必要。

# 不变性 FTW！

嗯，这里真正的目标是重新获得对系统的一些控制。这些年来，我发现自己使用这些反应库的模式是 Flux 的一些变化。基本上强制明确的单向流动。除非通过明确提供的方法，否则存储将保护它们的反应原子不被写入。你不需要 Redux 和 reducers 来实现这种隔离，但它总是需要一些工作。

大多数反应库被设计成传递这些你可以读写的反应原子。这是可以观察到的。在你随意传递它的时候，不利用像双向绑定这样的东西是没有意义的，因为这实际上和给一个子组件一个可观察值没有什么不同。你仍然有这个经典的问题:

```
const data = {/* some data*/}
fn(data);// do I know with certainty what data looks like at this point?
const value = data.someProperty;
```

即使 OOP 在这里也帮不了你。你可以把你的班级和装修工人留在家里。当然，你可能已经建立了一个合同，但你仍然给孩子改变你的数据的能力，这次是以可预见的方式，但仍然是他们认为合适的。这不一定是一件坏事，但也不总是人们想要的。与网络安全一样，最安全的系统是这样一种系统，其中您只授予每个节点最低限度需要的访问权限。

尽管解决方案非常简单。把你的读和写分开。拥有不可变的数据，用显式的 setters 来处理更新。它不一定只适用于全球商店。如 React 所示，这也是管理本地状态的一个很好的模式。它不能很好地与面向对象相结合，但是我认为 UI 本质上是一种形式的数据转换`view = fn(data)`函数式方法正是这项工作的合适工具。这样做，你就消除了这类问题的全部机会。

# 固态

所以在反应库中强制单向流动。这本身就是一个挑战，因为这些是建立在突变基础上的文库。我们不能只使用典型的不可变模式。通常，当一些嵌套数据发生变化时，您会沿着变化的路径进行浅层克隆，同时保持对未变化分支的引用。例如，图片将用户的街道号码从 101 更改为 102:

```
const state = {
  ...prevState,
  user: {
    ...prevState.user,
    address: {
      ...prevState.user.address
      streetNumber: 102
    }
  }
}
```

从树根克隆树将丢失所有反应引用。还有其他反应节点订阅了该树上的点，因此我们不能将其丢弃。在这一点上，在欣赏了不变性的好处之后，您可能想知道为什么还要坚持使用反应式库的希望。但是有一个简单的解决方案。

如果你看看那个不可改变的例子，你会发现还有很多需要改进的地方。做一些在突变情况下会变得简单的事情可能会很乏味:

```
state.user.address.streetNumber = 102;
```

幸运的是，多年来，图书馆一直在努力寻找使使用不可变数据结构更容易的方法。大多数情况下，他们使用的方法是把树变回小路。在 basic 中，他们试图给不可变的数据结构一个可变的 API。然而，由于不可变数据需要从根本上进行控制，他们必须提出一些有趣的 API，我们可以模仿这些 API，因为它们看起来是可变的，但仍然提供这种级别的控制。

因此，固态对象的关键在于它是一个 ES2015 代理对象。和 MobX 可观测的没什么区别。它跟踪访问并将孩子包装在他们自己的代理中。所以我们可以追踪树中所有的活性原子。然而，对于 Solid，我特意将代理设为只读。当您在 Solid 中创建状态时，它被分成代理和设置器:

```
const [state, setState] = createState({/* some data */});
```

无论任何人单独对那个状态做什么，它都不会改变。你可以放心地把它传给后代，而不担心它会改变。只有`setState`方法有能力改变它。您可以创建专门的更新方法来包装它，并精确地赋予您选择的组件更新对它们重要的状态的能力。这是全球状态模式，但却是本地化的。

那么`setState`是如何工作的呢？我用我最喜欢的不可变库实现了不可变范式和可变范式。不可变的简洁，类似于 React 和 immutableejs`setIn`:

```
//top level
setState({ count: state.count + 1 });//function setter on path returning new state
setState("count", c => c + 1)://nested path
setState("user", "address", "streetNumber", 102);
```

易变的那个像伊梅尔。函数提供的状态被包装在一个不同的代理中，该代理允许突变。但是您只能在函数的上下文中改变该状态或它的任何后代。

```
setState(produce(s => { s.user.address.streetNumber = 102; }))
```

真正的关键是这两种方法都在可变系统上使用了 Solid 的内置批处理。这意味着性能比任何不可变的系统都要好得多。没有克隆，也没有真正的不变性。您获得了不可变性的所有好处，您愿意使用不可变的 API，而没有任何性能下降。

# 结论

不变性是反应式库的一个强大工具，尽管它不是最容易的。我对为什么要有 setter 感到有些困惑。为什么不把一切变得简单些呢？

所以我想让你们思考一下另一种选择。事实上，你可能听说过。这叫 Vue。这两个库都把自己定位在 UI 库范围的中间。这两个库都有一个反应系统，并且大量借用 React，但是完全相反的部分。Vue 值使用可变赋值和双向绑定比其他任何东西都容易，但是使用像 React 这样的虚拟 DOM 技术来确保严格的呈现。坚实的价值观反应了保持事物严格的哲学，但拒绝了它的技术以获得更好的性能和更简单的抽象。在某种程度上，垂直反应和角度可能是对立的，固体是反 Vue 的排序。就好像我和埃文看到了同样的事情，却得出了完全相反的结论。当你想到 Vue 可能是最受欢迎的 UI 库时，你会想到哪个有趣的地方呢？我是说，你怎么能否认这一点呢？

嗯，我尽力了。

[](https://github.com/ryansolid/solid) [## 瑞安固体/固体

### 一个用于构建用户界面的声明式、高效且灵活的 JavaScript 库。-瑞安固体/固体

github.com](https://github.com/ryansolid/solid) [](https://itnext.io/designing-solidjs-reactivity-75180a4c74b4) [## 设计固体:反应性

### 2019 年前端开发的热点按钮话题。这很大程度上归功于苗条而富有的哈里斯…

itnext.io](https://itnext.io/designing-solidjs-reactivity-75180a4c74b4) [](https://medium.com/@ryansolid/designing-solidjs-dualities-69ee4c08aa03) [## 设计固体:二元性

### 看对立面能否帮助我们重新定义看待整体问题空间的方式？

medium.com](https://medium.com/@ryansolid/designing-solidjs-dualities-69ee4c08aa03) [](https://medium.com/swlh/designing-solidjs-components-8f1ebb88d78b) [## 设计 SolidJS:组件

### 组件是现代 Web UI 开发的基础。本文探讨了固体的独特方法…

medium.com](https://medium.com/swlh/designing-solidjs-components-8f1ebb88d78b)