<html>
<head>
<title>Taming long and nested if/else statements</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">驯服长的和嵌套的if/else语句</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/taming-long-and-nested-if-else-statements-5a1e483dc777?source=collection_archive---------8-----------------------#2020-12-11">https://javascript.plainenglish.io/taming-long-and-nested-if-else-statements-5a1e483dc777?source=collection_archive---------8-----------------------#2020-12-11</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="db95" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">回到基础——编写条件句</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/c36dfd4107654380d88c7fe19ffe2585.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*FZ_XgVN2GgyHpCZgp_gJJg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Image by <a class="ae ks" href="https://pixabay.com/users/stevepb-282134/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1580168" rel="noopener ugc nofollow" target="_blank">Steve Buissinne</a> from <a class="ae ks" href="https://pixabay.com/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=1580168" rel="noopener ugc nofollow" target="_blank">Pixabay</a></figcaption></figure><h1 id="bd13" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">案例一。简单的if / else if / else块</h1><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="7a37" class="lq ku in lm b gy lr ls l lt lu"><strong class="lm io">if</strong> (mode === "A") {<br/>  <strong class="lm io">return</strong> { isDisabled: true };<br/>} <strong class="lm io">else if</strong> (mode === "B") {<br/>  <strong class="lm io">return</strong> { isDisabled: true };<br/>} <strong class="lm io">else</strong> {<br/>  <strong class="lm io">return</strong> { isDisabled: false };<br/>}</span></pre><p id="5ceb" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">这是我们在应用程序中常见的模式。然而，未来类似意大利面的更新时机已经成熟。让我们看看如何驯服它。</p><h2 id="cc28" class="lq ku in bd kv mr ms dn kz mt mu dp ld me mv mw lf mi mx my lh mm mz na lj nb bi translated">备选方案1。丢掉别的</h2><p id="85c7" class="pw-post-body-paragraph lv lw in lx b ly nc jo ma mb nd jr md me ne mg mh mi nf mk ml mm ng mo mp mq ig bi translated">我们将尝试删除else关键字。事实上，这是多余的。</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="f266" class="lq ku in lm b gy lr ls l lt lu"><strong class="lm io">if</strong> (mode === "A") {<br/>  <strong class="lm io">return</strong> { isDisabled: true };<br/>}<br/><strong class="lm io">if</strong> (mode === "B") {<br/>  <strong class="lm io">return</strong> { isDisabled: true };<br/>} <br/><strong class="lm io">return</strong> { isDisabled: false };</span></pre><h2 id="e022" class="lq ku in bd kv mr ms dn kz mt mu dp ld me mv mw lf mi mx my lh mm mz na lj nb bi translated">选项2。使用switch语句</h2><p id="477a" class="pw-post-body-paragraph lv lw in lx b ly nc jo ma mb nd jr md me ne mg mh mi nf mk ml mm ng mo mp mq ig bi translated">前面的解决方案不那么混乱，但是为什么不在这里使用switch语句呢？</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="118a" class="lq ku in lm b gy lr ls l lt lu"><strong class="lm io">switch</strong>(mode) {<br/>  <strong class="lm io">case</strong> "A":<br/>    <strong class="lm io">return</strong> { isDisabled: true };<br/>  <strong class="lm io">case</strong> "B":<br/>    <strong class="lm io">return</strong> { isDisabled: true };<br/>  <strong class="lm io">default</strong>:<br/>    <strong class="lm io">return</strong> { isDisabled: false };<br/>}</span></pre><p id="7d7c" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">如果和<strong class="lx io">开关</strong>块的<strong class="lx io">具有大致相同的代码密度。Switch语句因意外的case失败和被遗忘的缺省值而臭名昭著。</strong></p><h2 id="7010" class="lq ku in bd kv mr ms dn kz mt mu dp ld me mv mw lf mi mx my lh mm mz na lj nb bi translated">选项3。三元怎么样？</h2><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="4fa2" class="lq ku in lm b gy lr ls l lt lu">return mode === "A" <br/>  <strong class="lm io">?</strong> { isDisabled: true }<br/>  <strong class="lm io">:</strong> mode === "B"<br/>  <strong class="lm io">?</strong> { isDisabled: true }<br/>  <strong class="lm io">:</strong> { isDisabled: false };</span></pre><p id="844a" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">如果你不习惯这些术语，它们可能看起来很陌生，但是如果有适当的格式(使用更漂亮的)，读起来会容易得多，它们比命令式的<strong class="lx io"> if/else </strong>语句要少得多。然而，对象模式可能是这里最好的方法。</p><h2 id="5e51" class="lq ku in bd kv mr ms dn kz mt mu dp ld me mv mw lf mi mx my lh mm mz na lj nb bi translated">选项4:对象模式</h2><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="0edb" class="lq ku in lm b gy lr ls l lt lu">const status = {<br/>  ["A"]: { isDisabled: true },<br/>  ["B"]: { isDisabled: true },<br/>}<br/>return status[mode] || { isDisabled: false };</span></pre><p id="7321" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">好多了！添加新案例应该和在对象中添加新地图一样简单。然而，我们不能用object模式替换嵌套表达式，让我们看另一个例子。</p><h1 id="ffd6" class="kt ku in bd kv kw kx ky kz la lb lc ld jt le ju lf jw lg jx lh jz li ka lj lk bi translated">案例二。嵌套的if else块</h1><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="8a64" class="lq ku in lm b gy lr ls l lt lu"><strong class="lm io">const</strong> getMessage = (selected, mode, action) =&gt; {<br/>  <strong class="lm io">if</strong> (selected.length === 0) {<br/>    <strong class="lm io">return</strong> "Empty List";<br/>  }<br/>  <strong class="lm io">if</strong> (selected.length &gt; 1 <strong class="lm io">&amp;&amp;</strong> action !== "edit") {<br/>    <strong class="lm io">return</strong> "Multi edit";<br/>  }<br/>  <strong class="lm io">if</strong> (selected.accessible <strong class="lm io">&amp;&amp;</strong> mode === "A") {<br/>    <strong class="lm io">if</strong> (action === "edit") {<br/>      <strong class="lm io">return</strong> "Multi select A Edit";<br/>    }<br/>    <strong class="lm io">return</strong>  "Multi select A View";<br/>  }<br/>  <strong class="lm io">return</strong> "No OP";<br/>}</span></pre><p id="c99d" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">在代码评审期间，这种风格被认为是一种代码味道。随着应用程序的老化，这个无辜的小函数将随着更多的条件而成长为一个庞然大物。由于组合的数量众多，单元测试也很困难；就其本质而言，没有人会完全理解它来更新任何现有的测试。如果我们幸运的话，作者会包括一些评论。</p><p id="b335" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">我们不能在这里仅仅创建一个对象模型。ternaries怎么样？</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="3e88" class="lq ku in lm b gy lr ls l lt lu">const getMessage = (selected, mode, action) =&gt; {<br/>  <strong class="lm io">return</strong> (selected.length === 0) {<br/>    ? "Empty List"<br/>    : (selected.length &gt; 1 &amp;&amp; action !== "edit") <br/>    ? "Multi edit"<br/>    : (selected.accessible &amp;&amp; mode === "A")<br/>    ? (action === "edit")<br/>      ? "Multi select A Edit"<br/>      : "Multi select A View"<br/>    : "No OP";<br/>}</span></pre><p id="9422" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">嵌套ternaries可能不那么罗嗦，但令人困惑，对我来说，它是一个不可读的代码块，破译它需要的精神体操不是微不足道的。代码应该尽可能地自我记录，以下是我的建议:</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="800d" class="lq ku in lm b gy lr ls l lt lu"><strong class="lm io">const</strong> emptyListMessage = (selected) =&gt;<br/>  selected.length === 0 ? "Empty List" : null;</span><span id="22be" class="lq ku in lm b gy nh ls l lt lu"><strong class="lm io">const</strong> multiSelectEditMessage = (selected, action) =&gt;<br/>  selected.length &gt; 1 &amp;&amp; action !== "edit" ? "Multi edit" : null;</span><span id="1db4" class="lq ku in lm b gy nh ls l lt lu"><strong class="lm io">const</strong> multiSelectModeAMessage = (action) =&gt;<br/>  action === "edit" ? "Multi select A Edit" : "Multi select A View";</span><span id="8884" class="lq ku in lm b gy nh ls l lt lu"><strong class="lm io">const</strong> accessibleModeMessage = (selected, mode, action) =&gt; <br/>  selected.accessible &amp;&amp; mode === "A"<br/>    ? multiSelectModeAMessage(action) <br/>    : null;</span><span id="cd78" class="lq ku in lm b gy nh ls l lt lu"><strong class="lm io">const</strong> defaultMessage = () =&gt; "No OP";</span><span id="0b00" class="lq ku in lm b gy nh ls l lt lu"><strong class="lm io">const</strong> getMessage = (selected, mode, action) =&gt;<br/>  emptyListMessage(selected)<br/>    || multiSelectEditMessage(selected, action)<br/>    || accessibleModeMessage(selected, mode, action)<br/>    || defaultMessage();</span></pre><p id="85ab" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">我们现在的代码主要是<em class="ni">函数和表达式，</em>函数式编程的精髓，它们具有数学性质；一旦经过适当的单元测试，它们往往会保持强大，并变得对错误有弹性。在这里，我们几乎已经将代码表面翻了一倍，它读起来相当不错。逻辑的每个部分都是自我记录的，这在条件复杂的情况下非常有用。我们可以<strong class="lx io">单元测试</strong>这些更小的功能更容易，它们有时甚至会被重用。对我来说，这里最大的挑战是给它们命名，以便它们有效地传达意图。</p><p id="99d5" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated"><strong class="lx io">提示:</strong>如果你有复杂的条件表达式，把它们移到自己的函数里。将这个应用到我们上面的例子中，我们得到了一个这样的函数，一个可爱的小liner，可以简单地进行单元测试。</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="8dbb" class="lq ku in lm b gy lr ls l lt lu"><strong class="lm io">const</strong> isAccssibleModeA = (accessible, mode) =&gt; accessible &amp;&amp; mode === “A”;</span></pre></div><div class="ab cl nj nk hr nl" role="separator"><span class="nm bw bk nn no np"/><span class="nm bw bk nn no np"/><span class="nm bw bk nn no"/></div><div class="ig ih ii ij ik"><h1 id="d8dd" class="kt ku in bd kv kw nq ky kz la nr lc ld jt ns ju lf jw nt jx lh jz nu ka lj lk bi translated">命令式if/else控制块</h1><p id="ee81" class="pw-post-body-paragraph lv lw in lx b ly nc jo ma mb nd jr md me ne mg mh mi nf mk ml mm ng mo mp mq ig bi translated">到目前为止，我们只看了纯函数/表达式，代码本身没有副作用，它们只是返回一些值而没有改变其他任何东西。然而，有些情况下，我们必须编写命令式嵌套逻辑控制块，这将包含某种副作用。</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="f5cc" class="lq ku in lm b gy lr ls l lt lu">  <strong class="lm io">if</strong> (condition1) {<br/>    X();<br/>  } <strong class="lm io">else if</strong> (condition2) {<br/>    <strong class="lm io">if</strong> (condition3) {<br/>      Y1();<br/>    } <strong class="lm io">else</strong> {<br/>      Y2();<br/>    }<br/>  } <strong class="lm io">else</strong> {<br/>    Z();<br/>  }</span></pre><h2 id="0df7" class="lq ku in bd kv mr ms dn kz mt mu dp ld me mv mw lf mi mx my lh mm mz na lj nb bi translated"><strong class="ak">尝试1 </strong></h2><p id="9a9e" class="pw-post-body-paragraph lv lw in lx b ly nc jo ma mb nd jr md me ne mg mh mi nf mk ml mm ng mo mp mq ig bi translated">我真的没有什么好的建议，但是重构的一个尝试是立即从一个<strong class="lx io"> if </strong>块中<strong class="lx io">返回</strong>。</p><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="285c" class="lq ku in lm b gy lr ls l lt lu">  <strong class="lm io">if</strong> (condition1) {<br/>    X();<br/>    <strong class="lm io">return</strong>;<br/>  }</span><span id="5019" class="lq ku in lm b gy nh ls l lt lu">  <strong class="lm io">if</strong> (condition2) {<br/>    <strong class="lm io">if </strong>(condition3) {<br/>      Y1();<br/>      <strong class="lm io">return</strong>;<br/>    }<br/>    Y2();<br/>    <strong class="lm io">return</strong>;<br/>  }</span><span id="6582" class="lq ku in lm b gy nh ls l lt lu">  Z();</span></pre><p id="ccb8" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">它仍然不理想，因为我们不能在if块中逻辑地分离不同的代码块。它也容易出错，有可能忘记返回。对于这样的代码，我真的没有一个好的解决方案，但是，这里有另一个选择。</p><h2 id="25eb" class="lq ku in bd kv mr ms dn kz mt mu dp ld me mv mw lf mi mx my lh mm mz na lj nb bi translated">尝试2</h2><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="7411" class="lq ku in lm b gy lr ls l lt lu">  <strong class="lm io">const</strong> doX = () =&gt; {<br/>    if (condition1) {<br/>      X();<br/>      <strong class="lm io">return true;</strong><br/>    }<br/>  };</span><span id="7ea0" class="lq ku in lm b gy nh ls l lt lu">  <strong class="lm io">const</strong> doY1 = () =&gt; { <br/>    if (condition3) {<br/>      Y1();<br/>      <strong class="lm io">return true;</strong><br/>    }<br/>  }</span><span id="a3db" class="lq ku in lm b gy nh ls l lt lu">  <strong class="lm io">const</strong> doY2 = () =&gt; {<br/>      Y2();<br/>      <strong class="lm io">return true;</strong><br/>  };</span><span id="f0b5" class="lq ku in lm b gy nh ls l lt lu">  <strong class="lm io">const</strong> doY = () =&gt; {<br/>    <strong class="lm io">if</strong> (condition2)  {<br/>      <strong class="lm io">return </strong>doY1() || doY2();<br/>    }<br/>  }<br/>  <br/>  doX() || doY() || Z();</span></pre><p id="c6d9" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">这样做的工作是将逻辑分成更小的功能。然而，解决方案是强制的，我们必须总是<strong class="lx io">返回</strong> true/undefined来指示它是否执行了某件事情，我们现在也有了一个未使用的表达式，一些linters肯定会抱怨它。它仍然不是单元可测试的，也不是更具可读性；我想我们只是让事情变得更糟了。我宁愿选择尝试1。</p><h2 id="04fd" class="lq ku in bd kv mr ms dn kz mt mu dp ld me mv mw lf mi mx my lh mm mz na lj nb bi translated">最后的努力</h2><pre class="kd ke kf kg gt ll lm ln lo aw lp bi"><span id="b6fd" class="lq ku in lm b gy lr ls l lt lu"><strong class="lm io">  const</strong> doY = () =&gt; {<br/>    <strong class="lm io">if</strong> (condition3) {<br/>      Y1();<br/>      <strong class="lm io">return</strong>;<br/>    }<br/>    Y2();<br/>  }</span><span id="2f9b" class="lq ku in lm b gy nh ls l lt lu">  <strong class="lm io">if</strong> (condition1) {<br/>    X();<br/>    <strong class="lm io">return</strong>;<br/>  }</span><span id="21a4" class="lq ku in lm b gy nh ls l lt lu">  <strong class="lm io">if</strong> (condition2) {<br/>    doY();<br/>    <strong class="lm io">return</strong>;<br/>  }</span><span id="0648" class="lq ku in lm b gy nh ls l lt lu">  Z();</span></pre><p id="d779" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">当我们将嵌套的、缩进的块移出到另一个函数时，一点理智就出现了，这是我要停止的地方。有没有更好的方法驯服嵌套的if/else控制块？请在评论中让我知道。</p><p id="e9e7" class="pw-post-body-paragraph lv lw in lx b ly lz jo ma mb mc jr md me mf mg mh mi mj mk ml mm mn mo mp mq ig bi translated">你可以在这里试一下上面的代码:<a class="ae ks" href="https://codesandbox.io/s/refactor-if-else-8ws1x?file=/src/index.js:758-1226" rel="noopener ugc nofollow" target="_blank">https://codesandbox.io/s/refactor-if-else-8ws1x?file=/src/index.js:758-1226 </a></p><h2 id="a8a0" class="lq ku in bd kv mr ms dn kz mt mu dp ld me mv mw lf mi mx my lh mm mz na lj nb bi translated">写给下一个人</h2><p id="d867" class="pw-post-body-paragraph lv lw in lx b ly nc jo ma mb nd jr md me ne mg mh mi nf mk ml mm ng mo mp mq ig bi translated">将大的函数和逻辑表达式分割成小块看起来似乎是一项很大的工作，但是，下一个从事这项工作的人会感谢你的，尤其是当你用单元测试来陪伴他们的时候。当所有的场景都被恰当地描述出来时，测试有助于非常有效地记录代码。</p></div></div>    
</body>
</html>