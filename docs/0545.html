<html>
<head>
<title>Common Mistakes Developers Made While Writing JavaScript Apps</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">开发人员在编写JavaScript应用程序时的常见错误</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/common-mistakes-people-made-writing-javascript-apps-3602030d90c0?source=collection_archive---------3-----------------------#2019-11-06">https://javascript.plainenglish.io/common-mistakes-people-made-writing-javascript-apps-3602030d90c0?source=collection_archive---------3-----------------------#2019-11-06</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/5eb0753e64c75b5be8df9ac1c319ea90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*_aIgcY_kDpa3wLxU"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@osomax?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Gabriel Gabriel</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="daa3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">每个开发人员在编写应用程序时都会犯一些错误。这是开发过程的正常部分。有些错误比其他错误更容易犯。意识到这些问题是有好处的，这样就可以在问题产生之前纠正它们。一旦我们能够做到这一点，那么我们就可以更容易地开发应用程序，并成为一名熟练的JavaScript开发人员，因为我们可以开发出错误更少的应用程序。我们将讨论一些更常见的错误，这样我们可以在这里避免它们</p><h1 id="35e4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">混淆平等</h1><p id="3fb6" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在JavaScript中，single equal、double equal和tripe equal都有各自的含义。单等号是赋值运算符，它将右边的值赋给左边的变量。双等号是相等检查运算符，它检查对象的内容是否相等，而不检查其类型。三重等于运算符检查对象的内容和类型是否相等。</p><p id="6403" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们使用单个相等赋值运算符，如下所示:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="7c6c" class="mn lc iq mj b gy mo mp l mq mr">let a = 1</span></pre><p id="d751" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是用来设置变量值的，所以我们在不应该使用的地方使用了single equal，比如:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="209f" class="mn lc iq mj b gy mo mp l mq mr">if (a = 1){ ... }</span></pre><p id="4087" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们将把1赋给<code class="fe ms mt mu mj b">a</code>，它总是<code class="fe ms mt mu mj b">true</code>。这意味着<code class="fe ms mt mu mj b">if</code>语句中的代码总是运行的。这绝对不是我们想要的。</p><p id="22d5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">双等号不应该太多，因为它在检查相等性时不检查对象的类型，所以类似于:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="31c5" class="mn lc iq mj b gy mo mp l mq mr">1 == '1'</span></pre><p id="b5eb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果<code class="fe ms mt mu mj b">true</code>。这就产生了问题，因为如果我们只检查数字1，而我们得到的是包含1的字符串，它仍然是真的。我们希望将它们转换成相同的类型，然后与<code class="fe ms mt mu mj b">===</code>进行比较，以检查是否相等，从而避免歧义。因此，如果我们想要比较1的所有形式是否都相等，我们首先使用以下公式将它们转换为数字:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="0fc8" class="mn lc iq mj b gy mo mp l mq mr">Number(1) === Number('1')</span></pre><p id="58a2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe ms mt mu mj b">1</code>不等于<code class="fe ms mt mu mj b">'1'</code>，因为它们是不同的类型。这会让事情变得更清楚。如果我们想确定某些东西彼此不相等，那么我们可以使用<code class="fe ms mt mu mj b">!==</code>来检查它们是否具有相同的内容或相同的类型，所以:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="e4d3" class="mn lc iq mj b gy mo mp l mq mr">1 !== '1'</span></pre><p id="021b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">会是<code class="fe ms mt mu mj b">true</code>。</p><h1 id="7fce" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">括号不匹配</h1><p id="2878" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">相互嵌套的语句和函数意味着每个文件中有多层括号。通常情况下，应用程序非常复杂，所以级别会增加。这意味着，如果您使用的文本编辑器不支持语法高亮显示或检查不匹配的括号，那么不匹配的括号很容易出现。使用Visual Studio Code、Atom和Sublime等现代文本编辑器可以很容易地避免这种情况。如果我们想使用更简单的文本编辑器，那么就使用linters和代码格式化工具，比如ESLint和Prettier，来检测这些问题。它们还允许我们自动格式化代码，并检测可能出现的常见样式问题，如引用样式不一致、一行中的字符数、可以缩短的函数等。</p><h1 id="06fc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">不匹配的报价</h1><p id="0d99" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript允许我们对字符串使用单引号、双引号和反引号。它们是等价的。但是，我们应该以同样的性格来打开和关闭。所以如果我们用单引号开始一个字符串，然后用单引号结束一个字符串，如果我们用双引号或反勾号开始，然后分别用它们结束字符串。此外，在某些情况下，像引号这样的特殊字符必须转义才能包含在字符串中。如果你用单引号打开一个字符串，那么如果你在一个字符串中使用单引号，那么你必须对它进行转义，以将它包含在字符串中。这也适用于双引号和反斜线。如果你在双引号字符串中使用双引号，那么你必须对它进行转义。如果你在模板字符串中使用反勾号，那么你必须对反勾号进行转义。</p><h1 id="48e4" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">圆括号</h1><p id="0cef" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在<code class="fe ms mt mu mj b">if</code>语句中，圆括号总是必须包围整个条件。例如，类似于:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="9538" class="mn lc iq mj b gy mo mp l mq mr">if (x &gt; y) &amp;&amp; (y &lt; 10) {...}</span></pre><p id="0d44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">行不通。写这句话的正确方法是:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="5074" class="mn lc iq mj b gy mo mp l mq mr">if ((x &gt; y) &amp;&amp; (y &lt; 10)) {...}</span></pre><p id="7e34" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想检查两个条件是否都为真。</p><h1 id="3823" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">分号</h1><p id="ee58" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">分号在JavaScript行尾是可选的。然而，为了让其他人更清楚，我们应该包括它，这样人们就知道一行在哪里结束。我们可以使用一个代码linter或者格式化程序，比如ESLint或者更漂亮的来自动完成这个任务。许多文本编辑器也有插件来自动修复它。</p><h1 id="5c2f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">资本化</h1><p id="c9ed" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript代码是区分大小写的，所以大小写不同的东西即使拼写相同也会被认为是不同的。引用它们的任何内容也必须正确大写。例如，<code class="fe ms mt mu mj b">getElementsByTagName</code>应该总是用完全相同的大写字母拼写。JavaScript中的一般惯例是，我们用camel大小写拼写变量和函数名，所以如果我们定义自己的变量，我们应该坚持这样做以保持一致性。</p><figure class="me mf mg mh gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mv"><img src="../Images/f1c06a850356e80ff5f5e8b85f34820e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*OB-W18_DrKDNG_-g"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@clemhlrdt?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Clément H</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="34a3" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">引用尚未加载的代码</h1><p id="352b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">为了使用代码，我们参考已经预先定义和加载的代码是很重要的。如果我们使用脚本标签，那么在引用代码之前，我们必须先加载代码。因此，引用包含我们想要使用的变量的脚本的脚本标记应该在引用包含我们想要引用的代码的脚本的脚本标记之前。</p><p id="a9ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">幸运的是，如今JavaScript模块更加普遍，所以我们只需记住导出您想要在另一个模块中使用的代码，并在引用变量之前将导出的变量导入到您想要使用的模块中。JavaScript模块解决了很多脚本标签的问题。全局变量不再需要使用太多来让不同的脚本引用同一个变量，而且我们可以在不使用闭包的情况下使变量私有，因为我们只需要导出其他地方需要的变量。</p><h1 id="826f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">变量名</h1><p id="65f1" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">在JavaScript中，有许多保留字不能用作变量名。它们不应该用作变量名，因为它们与保留字的名称冲突，给JavaScript解释器造成混乱。为了避免这种情况，我们应该使用描述性的名字，比如<code class="fe ms mt mu mj b">firstName</code>、<code class="fe ms mt mu mj b">lastName</code>等等。</p><h1 id="5864" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">范围</h1><p id="85a5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们不应该尽可能使用全局变量。这意味着我们声明的所有变量应该分别使用<code class="fe ms mt mu mj b">let</code>或<code class="fe ms mt mu mj b">const</code>关键字作为变量和常量。这避免了全局变量范围和覆盖全局变量数据的问题。它还可以让我们避免错误，不要给应该是常量的实体赋值，也不要意外地给全局赋值。</p><h1 id="e73f" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">缺少或意外的参数</h1><p id="d6e2" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当调用缺少预期参数的函数时，可能会返回意外的结果，因为您向函数传递了意外的输入。我们必须确保将正确的参数传递给函数，这样才能得到正确的结果。如果函数用在很多地方，比如库中的函数，检查意外参数也是一个好主意，这样我们就可以优雅地处理意外参数，比如当传入的参数是无效类型或<code class="fe ms mt mu mj b">null</code>或<code class="fe ms mt mu mj b">undefined</code>时，结束函数的执行。</p><h1 id="6659" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">索引错误</h1><p id="95a9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">JavaScript数组从索引0开始，所以数组的最后一个索引总是比数组的<code class="fe ms mt mu mj b">length</code>小1。当你传入一个超出长度或者像负数一样无效的索引时，我们得到<code class="fe ms mt mu mj b">undefined</code>，所以如果我们试图获取无效的条目并对其进行处理，我们会得到ReferenceErrors。</p><h1 id="c181" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">空且未定义</h1><p id="2865" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe ms mt mu mj b">null</code>和<code class="fe ms mt mu mj b">undefined</code>是往往是变量值的东西。这意味着当我们通过遍历对象的嵌套属性或循环数组来获取某些东西时，我们必须检查这些。当我们遇到<code class="fe ms mt mu mj b">null</code>或<code class="fe ms mt mu mj b">undefined</code>时，我们希望优雅地处理它们。这意味着我们应该经常检查它们。因此，如果我们有一个名为<code class="fe ms mt mu mj b">foo</code>的对象，我们想访问其中的深层嵌套属性，那么我们应该在每个级别检查<code class="fe ms mt mu mj b">null</code>或<code class="fe ms mt mu mj b">undefined</code>，就像这样:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="f86e" class="mn lc iq mj b gy mo mp l mq mr">if (foo &amp;&amp; foo.bar &amp;&amp; foo.bar.baz){ ... }</span></pre><p id="01ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样我们就知道所有的属性都被定义了，这样我们就可以访问<code class="fe ms mt mu mj b">baz</code>属性。对于数组，如果我们想访问索引<code class="fe ms mt mu mj b">i</code>，我们应该检查它是否是通过写:</p><pre class="me mf mg mh gt mi mj mk ml aw mm bi"><span id="59cb" class="mn lc iq mj b gy mo mp l mq mr">if (arr[i]){...}</span></pre><p id="392f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这样我们就不会遇到意外的未定义错误。</p><p id="b113" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">可选的链接操作符(<code class="fe ms mt mu mj b">?.</code>)正在开发中，所以希望它能很快完成，我们可以用它来访问一个对象中深度嵌套的属性，并且我们不再需要处理未定义的属性。此外，Lodash有一个<code class="fe ms mt mu mj b">get</code>函数，它可以尝试访问数组和对象的深层属性，并获取值(如果它存在),或者返回<code class="fe ms mt mu mj b">null</code>(如果在对象的层次结构中间有任何未定义的内容)。这比一长串的<code class="fe ms mt mu mj b">undefined</code>或<code class="fe ms mt mu mj b">null</code>检查要好得多。</p></div></div>    
</body>
</html>