<html>
<head>
<title>Rxjs Operators — Calculation and Aggregation</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">rjs运算符—计算和聚合</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/rxjs-operators-calculation-and-aggregation-fe01e139d714?source=collection_archive---------4-----------------------#2020-03-07">https://javascript.plainenglish.io/rxjs-operators-calculation-and-aggregation-fe01e139d714?source=collection_archive---------4-----------------------#2020-03-07</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/636298e4ed0de8c48c36760cdbbc406e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*2_VMsmqSFJgQHW0d"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@fasbytes?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Fas Khan</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="d296" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">rjs是一个进行反应式编程的库。创建运算符对于从各种数据源生成要由观察者订阅的数据非常有用。</p><p id="09e8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将了解一些计算和聚合运算符，包括<code class="fe lb lc ld le b">count</code>、<code class="fe lb lc ld le b">max</code>、<code class="fe lb lc ld le b">min</code>和<code class="fe lb lc ld le b">reduce</code>。</p><h1 id="ea8b" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">数数</h1><p id="7abc" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">count</code>运算符返回一个可观测值，该值计算源上的发射数量，并在源完成时发射该数量。</p><p id="766d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它采用一个可选的<code class="fe lb lc ld le b">predicate</code>函数，该函数返回一个带有计数条件的布尔值。</p><p id="32f7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">predicate</code>有3个参数，即源可观测值发出的<code class="fe lb lc ld le b">value</code>、<code class="fe lb lc ld le b">index</code>是源可观测值从零开始的“索引”,以及<code class="fe lb lc ld le b">source</code>是源可观测值本身。</p><p id="c5b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它来计算发射值的总数:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="6885" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { count } from "rxjs/operators";</span><span id="65e6" class="mq lg iq le b gy mv ms l mt mu">const of$ = of(1, 2, 3, 4, 5, 6);<br/>const result = of$.pipe(count());<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="fea3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有传递<code class="fe lb lc ld le b">predicate</code>功能的<code class="fe lb lc ld le b">count</code>操作员将计算可观察源的所有排放。</p><p id="11b7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这应该得到我们6，因为我们在<code class="fe lb lc ld le b">of$</code>可观察到6个值。</p><p id="fadd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们也可以传入一个<code class="fe lb lc ld le b">predicate</code>函数，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d0ec" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { count } from "rxjs/operators";</span><span id="d21c" class="mq lg iq le b gy mv ms l mt mu">const of$ = of(1, 2, 3, 4, 5, 6);<br/>const result = of$.pipe(count(val =&gt; val % 2 === 0));<br/>result.subscribe(x =&gt; console.log(x));</span></pre><p id="b8a4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们应该得到3，因为我们只是从<code class="fe lb lc ld le b">of$</code>发出的偶数。</p><h1 id="f4d3" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">最大</h1><p id="930f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">max</code>运算符从发出可与<code class="fe lb lc ld le b">comparer</code>函数比较的数字或项目的可观察源获取值，从中获取最大的一个，并与返回的可观察值一起发出。</p><p id="0e32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它带有一个可选的<code class="fe lb lc ld le b">comparer</code>功能，我们可以用它来比较两个项目的值。</p><p id="a64e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以用它来获得可观测值发出的最高数值，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="33d2" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { max } from "rxjs/operators";</span><span id="4609" class="mq lg iq le b gy mv ms l mt mu">of(2, 3, 4, 100)<br/>  .pipe(max())<br/>  .subscribe(x =&gt; console.log(x));</span></pre><p id="1a32" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们应该得到100，因为100是<code class="fe lb lc ld le b">of(2, 3, 4, 100)</code>可观察到的最大数字。</p><p id="8bdc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，我们还可以将一个函数传递给<code class="fe lb lc ld le b">max</code>运算符，以便从对象列表中获得最大值，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="e85d" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { max } from "rxjs/operators";</span><span id="200f" class="mq lg iq le b gy mv ms l mt mu">const people = [<br/>  { age: 17, name: "Joe" },<br/>  { age: 25, name: "Jane" },<br/>  { age: 19, name: "Mary" }<br/>];</span><span id="5aae" class="mq lg iq le b gy mv ms l mt mu">of(...people)<br/>  .pipe(max((a, b) =&gt; a.age - b.age))<br/>  .subscribe(x =&gt; console.log(x));</span></pre><p id="96aa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们应该得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b25b" class="mq lg iq le b gy mr ms l mt mu">{age: 25, name: "Jane"}</span></pre><p id="3169" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">来自<code class="fe lb lc ld le b">console.log</code>。</p><p id="15b8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">comparer</code>函数的工作方式类似于数组的<code class="fe lb lc ld le b">sort</code>方法的回调。如果<code class="fe lb lc ld le b">comparer</code>返回负数，我们保留订单。如果<code class="fe lb lc ld le b">comparer</code>返回一个正数，我们就改变顺序。否则，他们是一样的。然后从末端挑出最大的一个。</p><figure class="mi mj mk ml gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi mw"><img src="../Images/c26f2a298e2a8945b3ed97b394f39206.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*s57kl4m-uXexlDdE"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@markusspiske?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Markus Spiske</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h1 id="770d" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">部</h1><p id="550f" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">min</code>运算符与<code class="fe lb lc ld le b">max</code>运算符相反。它从源可观测值中获得最小值。</p><p id="ba11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">参数与<code class="fe lb lc ld le b">max</code>操作符相同。</p><p id="7b30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以像使用<code class="fe lb lc ld le b">max</code>操作符一样使用它，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="b76f" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { min } from "rxjs/operators";</span><span id="e370" class="mq lg iq le b gy mv ms l mt mu">of(2, 3, 4, 100)<br/>  .pipe(min())<br/>  .subscribe(x =&gt; console.log(x));</span></pre><p id="ff86" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">那么我们得到2。</p><p id="e046" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<code class="fe lb lc ld le b">max</code>操作符一样，我们可以使用带有<code class="fe lb lc ld le b">comparer</code>功能的<code class="fe lb lc ld le b">min</code>操作符，如下所示:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="0b5a" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { min } from "rxjs/operators";<br/>const people = [<br/>  { age: 17, name: "Joe" },<br/>  { age: 25, name: "Jane" },<br/>  { age: 19, name: "Mary" }<br/>];<br/>of(...people)<br/>  .pipe(min((a, b) =&gt; a.age - b.age))<br/>  .subscribe(x =&gt; console.log(x));</span></pre><p id="ca0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="659a" class="mq lg iq le b gy mr ms l mt mu">{age: 17, name: "Joe"}</span></pre><p id="d0d1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">comparer</code>函数的工作方式与我们传递给<code class="fe lb lc ld le b">max</code>操作符的方式相同，除了选择第一个而不是最后一个。</p><h1 id="fc72" class="lf lg iq bd lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc bi translated">减少</h1><p id="2bef" class="pw-post-body-paragraph kd ke iq kf b kg md ki kj kk me km kn ko mf kq kr ks mg ku kv kw mh ky kz la ij bi translated"><code class="fe lb lc ld le b">reduce</code>操作符对源可观察对象发出的所有值应用一个累加器函数，将它们组合成一个值，由返回的可观察对象发出。</p><p id="996b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它最多需要两个参数。第一个是<code class="fe lb lc ld le b">accumulator</code>函数，这是我们用来组合值的函数。</p><p id="a82b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">第二个参数是可选的<code class="fe lb lc ld le b">seed</code>值，它是累加的初始值。</p><p id="b733" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mi mj mk ml gt mm le mn mo aw mp bi"><span id="d70b" class="mq lg iq le b gy mr ms l mt mu">import { of } from "rxjs";<br/>import { reduce } from "rxjs/operators";<br/>of(2, 3, 4, 100)<br/>  .pipe(reduce((a, b) =&gt; a + b, 0))<br/>  .subscribe(x =&gt; console.log(x));</span></pre><p id="85ed" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">上面的代码将对来自<code class="fe lb lc ld le b">of(2, 3, 4, 100)</code>的可观察值求和，并发出109，这是2、3、4和100的和。</p><p id="a5a0" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">a</code>和<code class="fe lb lc ld le b">b</code>是从可观测源发出的值。</p><p id="9ba4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">count</code>操作符返回一个可观察值，根据我们指定的条件计算源可观察值发出或源可观察值发出某种值的次数。</p><p id="c797" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">min</code>和<code class="fe lb lc ld le b">max</code>用于根据一个排序函数或从分别发出的一组数中得到最小值和最大值。</p><p id="eb6c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><code class="fe lb lc ld le b">reduce</code>操作符返回一个可观察对象，它从源可观察对象中获取值，并按照我们在传递给它的函数中指定的方式将它们组合成一个。</p></div></div>    
</body>
</html>