<html>
<head>
<title>Reactivity in Web Frameworks (Part 1)</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">Web框架中的反应性(第1部分)</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reactivity-in-web-frameworks-part-1-ef1f7bde9c02?source=collection_archive---------3-----------------------#2020-01-09">https://javascript.plainenglish.io/reactivity-in-web-frameworks-part-1-ef1f7bde9c02?source=collection_archive---------3-----------------------#2020-01-09</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><h1 id="1900" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么是反应性</h1><p id="6039" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">反应性是web框架在应用程序状态改变时更新视图的能力。</p><p id="62b0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">它是任何现代web框架的核心。</p><figure class="lp lq lr ls gt lt gh gi paragraph-image"><div role="button" tabindex="0" class="lu lv di lw bf lx"><div class="gh gi lo"><img src="../Images/0a95bce032b4098159fc5bcab9fe57a2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*afRR68rb-4nBzVQi.png"/></div></div></figure><p id="6988" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">为了理解什么是反应性，让我们看一个计数器应用程序的例子。</p><p id="0cf7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这就是用普通JavaScript编写的方式:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="b4d3" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在Vue中，您可以这样做:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="2959" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">…这在反应中:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="4863" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">请注意，使用web框架，您的代码更关注于根据业务需求更新应用程序状态的<em class="mc"/>和使用模板语言或JSX表达式描述视图外观的<em class="mc">。该框架将在应用程序状态和视图之间架起一座桥梁，每当应用程序状态改变时就更新视图。</em></p><p id="46f0" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">不再有烦人的DOM操作语句(<code class="fe md me mf mg b">span.innerText = counter</code>)伴随着状态更新语句(<code class="fe md me mf mg b">counter ++;</code>)。当一个人在更新应用程序状态时忘记更新视图时，不再有难以捉摸的视图和应用程序状态不同步的错误。</p><p id="58c4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">所有这些问题现在都是过去式了，因为web框架现在默认以反应方式发布，总是确保视图是应用程序状态变化的最新版本。</p><p id="2988" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">所以我们接下来要讨论的主要观点是，</p><blockquote class="mh mi mj"><p id="977e" class="kl km mc kn b ko lj kq kr ks lk ku kv mk ll ky kz ml lm lc ld mm ln lg lh li ij bi translated">web框架如何实现反应性？</p></blockquote><h1 id="a97f" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">时间和内容</h1><p id="6681" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了实现反应性，该框架必须回答两个问题</p><ul class=""><li id="b8a7" class="mn mo iq kn b ko lj ks lk kw mp la mq le mr li ms mt mu mv bi translated">应用程序状态何时改变？</li><li id="0f1d" class="mn mo iq kn b ko mw ks mx kw my la mz le na li ms mt mu mv bi translated">应用程序状态发生了什么变化？</li></ul><p id="8f1f" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">WHEN</strong>回答框架何时需要开始更新视图。知道<strong class="kn ir">是什么</strong>，允许框架优化它的工作，只更新视图中已经改变的部分。</p><p id="2245" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们将讨论不同的策略来确定<strong class="kn ir">何时</strong>和<strong class="kn ir">什么</strong>，以及每个策略的代码片段。你可以组合不同的策略来决定什么时候和什么时候<strong class="kn ir"/>，但是某些组合可能会让你想起一些流行的web框架。</p><h1 id="2cc9" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">什么时候</h1><p id="3040" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">WHEN通知框架应用程序状态已经更改，因此框架知道它需要完成更新视图的工作。</p><p id="4809" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">不同的框架采用不同的策略来检测应用程序状态何时改变，但本质上，通常归结为在框架中调用一个<code class="fe md me mf mg b">scheduleUpdate()</code>。<code class="fe md me mf mg b">scheduleUpdate</code>通常是框架的一个去抖<code class="fe md me mf mg b">update</code>功能。因为应用程序状态的改变可能导致派生状态的改变，或者框架用户可能连续改变应用程序状态的不同部分。如果框架在每次状态改变时更新视图，它可能会过于频繁地改变视图，这可能是低效的，或者它可能会有不一致的视图(<a class="ae nb" href="https://techterms.com/definition/screen_tearing" rel="noopener ugc nofollow" target="_blank">可能会导致撕裂</a>)。</p><p id="988e" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">想象一下这个做作的React例子:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a236" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果框架同步更新视图中的todos，然后更新todos总数，可能会有一瞬间todos和总数不同步。<em class="mc">(虽然在这个做作的例子中，这似乎是不可能的，但你明白了。)</em></p><blockquote class="mh mi mj"><p id="ffce" class="kl km mc kn b ko lj kq kr ks lk ku kv mk ll ky kz ml lm lc ld mm ln lg lh li ij bi translated"><em class="iq">对了，你不应该设置</em> <code class="fe md me mf mg b"><em class="iq">totalTodos</em></code> <em class="iq">这种方式，你应该从</em> <code class="fe md me mf mg b"><em class="iq">todos.length</em></code> <em class="iq">中派生出来，参见</em> <a class="ae nb" href="https://kentcdodds.com/blog/dont-sync-state-derive-it" rel="noopener ugc nofollow" target="_blank"> <em class="iq">【不同步状态】。衍生出来！”肯特·c·多兹。</em> </a></p></blockquote><p id="93a5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">那么，您如何知道应用程序状态何时发生了变化呢？</p><h1 id="998d" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">突变跟踪</h1><p id="3cb4" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">所以我们想知道应用程序状态什么时候改变了？让我们追踪它！</p><p id="12fc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">首先，为什么叫变异追踪？那是因为我们只能追踪突变。</p><p id="89e8" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">通过单词mutation，它推断出我们的应用程序状态必须是一个对象，因为您不能改变一个原语。</p><p id="60f9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">像数字、字符串、布尔这样的原语是通过值传递给函数的。因此，如果您将原语重新赋值给另一个值，则在函数中永远无法观察到这种重新赋值:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="c0f2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">另一方面，对象是通过引用传递的。因此，可以从内部观察到同一对象的任何变化:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="a0b7" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这也是为什么大多数框架的应用程序状态是通过<code class="fe md me mf mg b">this</code>来访问的，因为<code class="fe md me mf mg b">this</code>是一个对象，对<code class="fe md me mf mg b">this.appState</code>的改变可以被框架观察/跟踪。</p><p id="5c6d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">现在我们明白了为什么叫变异跟踪，让我们来看看变异跟踪是如何实现的。</p><p id="5a6d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们将看看JavaScript中两种常见的对象类型，普通对象和数组。</p><p id="ba76" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><em class="mc">(虽然如果你</em> <code class="fe md me mf mg b"><em class="mc">typeof</em></code> <em class="mc">对于两个对象或者数组，它们都是</em> <code class="fe md me mf mg b"><em class="mc">"object"</em></code> <em class="mc"> ) </em>。</p><p id="a128" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">随着ES6代理的引入，变异跟踪方法变得更加简单。但是，让我们看看如何在有/没有ES6代理的情况下实现突变跟踪。</p><h1 id="8079" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">先前代理</h1><p id="18ab" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">为了在没有代理的情况下跟踪变异，我们可以为对象的所有属性定义一个自定义的getters和setters。因此，每当框架用户更改属性的值时，都会调用自定义setter，我们会知道有些事情发生了变化:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Inspired by <a class="ae nb" href="https://paper.dropbox.com/doc/Reactivity-in-Web-Frameworks--Aroey0wh9iZRE8dm9lC4Ulo0AQ-D6CkkTTpH1AqGvBlKcQ85" rel="noopener ugc nofollow" target="_blank">Vue.js 2.0’s observer</a>.</figcaption></figure><p id="a5a5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">但是，您可能会注意到，如果我们在对象的现有属性上定义getters和setters，我们可能会错过通过添加或删除对象属性所做的更改。</p><p id="106d" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果没有更好的JavaScript API，这是无法解决的问题，因此对此警告的一个可能的解决方法是提供一个助手函数。比如在Vue中，你需要使用辅助函数<code class="fe md me mf mg b"><a class="ae nb" href="https://vuejs.org/v2/guide/reactivity.html#Change-Detection-Caveats" rel="noopener ugc nofollow" target="_blank">Vue.set(object, propertyName, value)</a></code>而不是<code class="fe md me mf mg b">object[propertyName] = value</code>。</p><p id="c355" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">跟踪数组的突变类似于跟踪对象的突变。但是除了可以通过赋值改变数组项之外，还可以通过数组的变异方法对数组进行变异，例如:<code class="fe md me mf mg b">push</code>、<code class="fe md me mf mg b">pop</code>、<code class="fe md me mf mg b">splice</code>、<code class="fe md me mf mg b">unshift</code>、<code class="fe md me mf mg b">shift</code>、<code class="fe md me mf mg b">sort</code>、<code class="fe md me mf mg b">reverse</code>。</p><p id="e3eb" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">要跟踪这些方法所做的更改，您必须修补它们:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Inspired by <a class="ae nb" href="https://github.com/vuejs/vue/blob/22790b250cd5239a8379b4ec8cc3a9b570dac4bc/src/core/observer/array.js" rel="noopener ugc nofollow" target="_blank">Vue.js 2.0’s array observer</a>.</figcaption></figure><blockquote class="mh mi mj"><p id="43a3" class="kl km mc kn b ko lj kq kr ks lk ku kv mk ll ky kz ml lm lc ld mm ln lg lh li ij bi translated"><em class="iq"> CodeSandbox用于</em> <a class="ae nb" href="https://codesandbox.io/s/mutation-tracking-getterssetters-44ono" rel="noopener ugc nofollow" target="_blank"> <em class="iq">对象的变异跟踪和</em> </a></p></blockquote><p id="64cd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">总之，要在没有代理的情况下跟踪对象或数组的变化，您需要为所有属性定义定制的getter/setter，以便您可以在设置属性时进行捕获。除此之外，您还需要修补所有的变异方法，因为这将在不触发自定义setter的情况下变异您的对象。</p><p id="cdb9" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">然而，仍然有一些边缘情况无法涵盖，比如添加新的属性或删除属性。</p><p id="c319" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这就是<a class="ae nb" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy" rel="noopener ugc nofollow" target="_blank"> ES6代理</a>来帮忙的地方。</p><h1 id="ac3b" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">使用代理</h1><p id="cbbc" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">代理允许我们在目标对象的基本操作上定义自定义行为。这对于变异跟踪非常有用，因为代理允许我们拦截属性设置和删除，而不管我们是使用索引赋值、<code class="fe md me mf mg b">obj[key] = value</code>还是变异方法、<code class="fe md me mf mg b">obj.push(value)</code>:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="0d06" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><strong class="kn ir">那么我们如何使用突变追踪呢？</strong></p><p id="634b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">变异跟踪的好处是，如果你在上面的例子中注意到了，框架用户并不知道跟踪，并把<code class="fe md me mf mg b">appState</code>当作一个正常的对象:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="8b21" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们可以在组件初始化期间设置跟踪，或者:</p><ul class=""><li id="d758" class="mn mo iq kn b ko lj ks lk kw mp la mq le mr li ms mt mu mv bi translated">跟踪组件的属性，</li><li id="447e" class="mn mo iq kn b ko mw ks mx kw my la mz le na li ms mt mu mv bi translated">跟踪组件实例本身，</li><li id="432a" class="mn mo iq kn b ko mw ks mx kw my la mz le na li ms mt mu mv bi translated">或者介于两者之间</li></ul><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6d32" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">一旦您能够跟踪应用程序状态的变化，接下来要做的事情就是调用<code class="fe md me mf mg b">scheduleUpdate</code>而不是<code class="fe md me mf mg b">console.log</code>。</p><p id="671b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你可能会担心所有这些复杂性是否值得努力。或者你可能担心旧浏览器不支持<a class="ae nb" href="https://caniuse.com/#feat=proxy" rel="noopener ugc nofollow" target="_blank">代理。</a></p><p id="18a5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">你的担心并非完全没有根据。不是所有的框架都使用变异跟踪。</p><h1 id="2867" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">就叫<code class="fe md me mf mg b">scheduleUpdate</code></h1><p id="8649" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">一些框架设计他们的API的方式使得它“欺骗”框架用户告诉框架应用程序状态已经改变。</p><p id="83d5" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">每当您更改应用程序状态时，框架会强迫您使用它们的API来更改应用程序状态，而不是记住调用<code class="fe md me mf mg b">scheduleUpdate</code>:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="0ef1" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这使我们的设计更简单，处理的边缘情况更少:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Inspired by <a class="ae nb" href="https://github.com/facebook/react/blob/0cf22a56a18790ef34c71bef14f64695c0498619/packages/react/src/ReactBaseClasses.js#L57" rel="noopener ugc nofollow" target="_blank">React’s </a><code class="fe md me mf mg b"><a class="ae nb" href="https://github.com/facebook/react/blob/0cf22a56a18790ef34c71bef14f64695c0498619/packages/react/src/ReactBaseClasses.js#L57" rel="noopener ugc nofollow" target="_blank">setState</a></code></figcaption></figure><p id="c8be" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">然而，这可能会让新开发人员陷入框架:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="91ae" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">…在阵列中添加/删除项目时可能有点笨拙:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="6eb2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">一种可能两全其美的不同方法是在您认为最有可能发生变化的场景中插入<code class="fe md me mf mg b">scheduleUpdate</code>:</p><ul class=""><li id="72b1" class="mn mo iq kn b ko lj ks lk kw mp la mq le mr li ms mt mu mv bi translated">事件处理程序</li><li id="6b70" class="mn mo iq kn b ko mw ks mx kw my la mz le na li ms mt mu mv bi translated">超时(例如:<code class="fe md me mf mg b">setTimeout</code>，<code class="fe md me mf mg b">setInterval</code>，...)</li><li id="ed0a" class="mn mo iq kn b ko mw ks mx kw my la mz le na li ms mt mu mv bi translated">API处理、承诺处理</li><li id="8a15" class="mn mo iq kn b ko mw ks mx kw my la mz le na li ms mt mu mv bi">…</li></ul><p id="2cd4" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">因此，框架用户应该使用定制的超时、api处理程序，...：</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div><figcaption class="nc nd gj gh gi ne nf bd b be z dk">Inspired by <a class="ae nb" href="https://github.com/angular/angular.js/blob/master/src/ng/timeout.js#L13" rel="noopener ugc nofollow" target="_blank">AngularJS’s $timeout</a></figcaption></figure><p id="19cc" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">您的框架用户现在可以自由地以他想要的方式更改应用程序状态，只要这些更改是在您的定制处理程序中完成的。因为在处理程序的最后，你会调用<code class="fe md me mf mg b">scheduleUpdate()</code>。</p><p id="1125" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">同样，这也可能让新开发人员陷入框架之中！尝试搜索<a class="ae nb" href="https://www.google.com/search?q=angularjs%20%24timeout%20vs%20window.setTimeout" rel="noopener ugc nofollow" target="_blank">“angular js＄time out vs window . settimeout”</a></p><p id="ea24" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">您可能会想，如果处理函数中没有状态变化，调用额外的<code class="fe md me mf mg b">scheduleUpdate()</code>不是效率很低吗？到目前为止，我们还没有讨论<code class="fe md me mf mg b">scheduleUpdate()</code>中发生了什么，我们可以检查<strong class="kn ir">发生了什么变化</strong>(这将在下一节中介绍)<strong class="kn ir">、</strong>，如果没有变化，我们可以跳过后续步骤。</p><p id="6c68" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果你看看我们迄今为止尝试过的策略，你可能会注意到一个共同的问题:</p><ul class=""><li id="c645" class="mn mo iq kn b ko lj ks lk kw mp la mq le mr li ms mt mu mv bi translated">允许框架用户以他想要的任何方式改变应用程序状态</li><li id="9242" class="mn mo iq kn b ko mw ks mx kw my la mz le na li ms mt mu mv bi translated">在没有太多运行时复杂性的情况下实现反应。</li></ul><p id="6654" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">在这一点上，你必须同意，强制框架开发人员在他们想要改变应用程序状态的时候调用<code class="fe md me mf mg b">setAppState</code>，对框架来说需要<strong class="kn ir">更少的运行时复杂性</strong>，并且不太可能有任何需要处理的极限情况或警告。</p><p id="206a" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">如果开发人员的表达能力和运行时的复杂性之间存在矛盾，或许我们可以通过将复杂性从运行时转移到构建时来达到两全其美？</p><h1 id="3cd3" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">静态分析</h1><p id="f274" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">如果我们有一个编译器允许框架用户编写:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="4e0b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">并将其编译为:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="efee" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">这样，我们就真的两全其美了！😎</p><p id="5770" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">让我们看看框架用户将编写的不同场景，看看我们是否知道何时插入<code class="fe md me mf mg b">scheduleUpdate()</code>:</p><figure class="lp lq lr ls gt lt"><div class="bz fp l di"><div class="ma mb l"/></div></figure><p id="cf71" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">请允许我总结一下上面例子中面临的一些复杂情况:</p><ul class=""><li id="f47c" class="mn mo iq kn b ko lj ks lk kw mp la mq le mr li ms mt mu mv bi translated">跟踪应用程序状态的直接变化很容易，但是跟踪间接的变化却非常困难，例如:<code class="fe md me mf mg b">foo.one</code>、<code class="fe md me mf mg b">doSomethingMutable(this.appState)</code>或者<code class="fe md me mf mg b">this.appState.obj.increment()</code></li><li id="203f" class="mn mo iq kn b ko mw ks mx kw my la mz le na li ms mt mu mv bi translated">通过赋值语句跟踪变更很容易，但是通过变异方法跟踪变更却非常困难，例如:<code class="fe md me mf mg b">this.appState.list.push('1')</code>，我的意思是你如何知道方法正在变异？</li></ul><p id="b339" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">所以对于<a class="ae nb" href="http://github.com/sveltejs/svelte" rel="noopener ugc nofollow" target="_blank"> Svelte </a>这种使用静态分析来实现反应性的框架之一，它只通过赋值操作符来保证反应性(例如:<code class="fe md me mf mg b">=</code>，<code class="fe md me mf mg b">+=</code>，...)和一元算术运算符(例如:<code class="fe md me mf mg b">++</code>和<code class="fe md me mf mg b">--</code>)。</p><p id="fc30" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我相信在这个领域还有待探索的空间，特别是在TypeScript 的<a class="ae nb" href="https://2019.stateofjs.com/javascript-flavors/typescript/" rel="noopener ugc nofollow" target="_blank">兴起的时候，我们也许能够通过静态类型更好地理解我们的应用程序状态。</a></p><h1 id="be94" class="jn jo iq bd jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke kf kg kh ki kj kk bi translated">摘要</h1><p id="73e9" class="pw-post-body-paragraph kl km iq kn b ko kp kq kr ks kt ku kv kw kx ky kz la lb lc ld le lf lg lh li ij bi translated">我们已经经历了了解应用程序状态何时改变的不同策略:</p><ul class=""><li id="d8af" class="mn mo iq kn b ko lj ks lk kw mp la mq le mr li ms mt mu mv bi translated">突变跟踪</li><li id="49dc" class="mn mo iq kn b ko mw ks mx kw my la mz le na li ms mt mu mv bi translated">就叫<code class="fe md me mf mg b">scheduleUpdate</code></li><li id="e5f5" class="mn mo iq kn b ko mw ks mx kw my la mz le na li ms mt mu mv bi translated">静态分析</li></ul><p id="b9bd" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">不同的策略体现在框架的API方面:</p><p id="ab05" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">知道应用程序状态何时改变，允许框架知道何时更新我们的视图。然而，为了优化更新，框架需要知道应用程序状态发生了什么变化。</p><p id="5cb2" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我们要删除并重新创建视图中的每个DOM元素吗？根据应用程序状态的变化，我们知道视图的哪一部分将会改变吗？</p><p id="ae7b" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">也就是说，如果我们知道<strong class="kn ir">这个什么</strong>。</p><p id="8c86" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated">我要感谢<a class="ae nb" href="https://twitter.com/Rich_Harris" rel="noopener ugc nofollow" target="_blank"> Rich Harris </a>指出了本文前一版本中的一些不准确之处，并提供了宝贵的反馈。所有剩下的错误都是我的..</p></div><div class="ab cl ng nh hu ni" role="separator"><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl nm"/><span class="nj bw bk nk nl"/></div><div class="ij ik il im in"><p id="b5df" class="pw-post-body-paragraph kl km iq kn b ko lj kq kr ks lk ku kv kw ll ky kz la lm lc ld le ln lg lh li ij bi translated"><em class="mc">原载于</em><a class="ae nb" href="https://lihautan.com/reactivity-in-web-frameworks-the-when/" rel="noopener ugc nofollow" target="_blank"><em class="mc"/></a></p></div></div>    
</body>
</html>