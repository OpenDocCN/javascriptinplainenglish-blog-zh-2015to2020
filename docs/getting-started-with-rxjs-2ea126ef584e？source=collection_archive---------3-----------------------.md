# RxJS 入门

> 原文：<https://javascript.plainenglish.io/getting-started-with-rxjs-2ea126ef584e?source=collection_archive---------3----------------------->

![](img/a7e7e0537488648eae4fbcb7a8e7a2b2.png)

Source: Unsplash

如果你喜欢“承诺”，你会喜欢“可观察的”。

“可观的”是你可以订阅的“东西”,随着时间的推移，你将从中获得价值。我相信每个人都知道什么是“ [rsa securId](https://en.wikipedia.org/wiki/RSA_SecurID) ”，但对于那些不知道的人来说，它是一个小设备，显示每 X 分钟改变一次的随机访问令牌。您可以使用此令牌登录应用程序，如银行网站。我们可以想象，这个设备实际上是被观察对象的观察者，每隔 X 分钟发送一次访问令牌。

我知道这个比喻可能是你听过的最好的(或者最差的)，但是让我们把它带回 web 开发环境，让我们看看如何使用“ [RxJS](https://rxjs-dev.firebaseapp.com/) ”，著名的反应式编程库。

# 获取 RxJS

这可能是这篇文章中最简单的部分了。“RxJS”可以通过安装相应的“节点”包来使用。

> *纱线添加 rxjs -S*

# 使用内置观察器

在创建我们自己的可观测量之前，我们将从使用“RxJS”为我们提供的可观测量开始。在这个例子中，我们将简单地显示鼠标在页面上停止移动时的位置。所以我们的目标不是在光标一移动就显示它的位置，而是在它停止移动的时候显示。

让我们从 HTML 开始:

然后，我们将订阅一个绑定到“document”对象的“mousemove”事件的可观察对象。所以基本上，每次触发“document”对象的“mousemove”事件时，这个可观察对象都会发出一个值。

要订阅一个“可观察的”，我们只需要调用“subscribe”方法并传递一个具有某些特定属性的对象:

*   **下一个**:被观察对象发出值时调用的回调函数。
*   **错误**:当可观察对象发出错误时调用的回调函数。
*   **完成**:观察完成时调用回调函数。

所以基本上，它看起来像这样:

“RxJS”还允许您将这些回调直接作为参数传递:

这三个参数是可选的(尽管如此，我想知道没有定义三个回调的观察者有什么用)。

使用“RxJS”可以很容易地获得“可观察的”,例如，我们将通过使用“fromEvent”函数获得“document”对象的“mousemove”事件的可观察值，如下所示:

第 1 行从“rxjs”库中导入“fromEvent ”,而第 2 行检索对将显示光标位置的“span”的引用(甚至不要想使用 jQuery 来获取这个引用)。代码的主要部分从第 5 行开始，我们使用“fromEvent”来获取“document”对象(第一个参数)的“mousemove”事件(第二个参数)的可观察值。一旦我们得到它，我们需要订阅它，以便能够获得它将发出的价值。我们使用第二种形式的“subscribe”函数，我们在上面看到，其中“next”回调被定义为函数的第一个参数。

该回调将接收一个参数，该参数将是可观察对象发出的值。因此，每次光标在文档上移动时，回调函数将被调用，并在参数中指定一个值，在本例中，它将是一个“MouseEvent”对象，包含两个有趣的属性:

*   clientX:光标的 X 位置。
*   clientY:光标的 Y 位置。

我们的代码使用这两个属性来显示页面上的光标位置。

# 管道可观察

有时，在我们接收到发出的值之前，对“可观察的”执行一些动作会很有趣。例如，在上面的代码中，我们将在参数中收到一个“MouseEvent”对象，它包含许多属性，但我们将只使用“clientX”和“clientY”属性。接收一个只包含“x”和“y”属性的更简单的对象会很酷。

为此，我们可以使用“管道”函数对发出的值进行一些转换。让我们使用“map”操作符将“MouseEvent”对象转换为我们刚刚讨论过的更简单的对象:

“管道”函数接受数量不定的参数，这些参数是接收发出的值的函数。在我们的例子中，我们使用“map”函数将一个值转换成另一个值。这里，我们接收“MouseEvent”对象，并简单地返回一个新对象，它具有包含发出值的属性“clientX”的属性“x”和包含发出值的属性“clientY”的属性“y”。这意味着在“subscribe”方法的回调中，我们将不再得到一个“MouseEvent”对象，而是一个具有“x”和“y”属性的对象。

很酷吧。然而，我们的代码有问题…我们说过一旦光标停止移动，我们将显示光标位置，但是光标一移动，位置就会刷新。为了解决这个问题，我们将使用“RxJS”的“去反跳时间”操作符。基本上，只要最后一次发射值和当前时刻之间的时间间隔短于指定值，该操作符就会忽略发射值。让我们看看如何使用它，然后我们会让这个解释更清楚:

我们在 observable 的“pipe”函数中添加了对“debounceTime”的调用，这样，它将为每个发出的值调用。正如我们所说的，只要最后一次发出的值和当前时刻之间的时间间隔短于传递给该函数的参数，该函数就会忽略发出的值。

如果您测试这段代码，您将会看到，只要光标在移动，就不会刷新“span”中的位置。这是因为当您移动光标时，会为每个像素发出一个新的位置，除非您非常缓慢地移动光标，否则两个不同位置之间的时间将少于 100 毫秒，因此该值将被忽略。然后，在某个时间点，你将停止移动你的鼠标，100 毫秒后，这个值将被发出，所以位置将被刷新。

该操作符对于自动完成组件也非常有用。很多时候，你不想在用户键入一封信后直接搜索他正在键入的内容，因为当他想搜索“可爱而毛绒绒的猫的视频”时，你不想搜索“v”，然后“vi”，然后“vid”，…最好在用户似乎已经停止键入其搜索标准时进行研究。

# 快点，停下来！

退订一个可观察对象和订阅它一样容易。这里我们没有说的是“订阅”函数实际上返回的是一个名为“订阅”的对象。您可以对该对象调用“unsubscribe”方法来停止侦听发出的值。让我们像这样修改我们的“HTML ”:

您的“JavaScript”代码是这样的:

Et voilà，您只需向按钮添加一个“click”事件侦听器，当它被触发时，我们会对由可观察对象的“subscribe”函数返回的对象调用“unsubscribe ”,因此当您单击按钮时，光标的位置不再刷新。取消订阅一个可能永远不会完成的“可观察”总是一个好习惯。

# 我要我的，我要我的！

使用像这样的内置“可观察物”已经很酷了，但是创建你自己的更酷。我们将通过创建我们自己的小型“rsa-securid”应用程序来了解如何做到这一点。因此，基本上，我们将有一个名为“rsa”的模块，它将负责每 2 秒钟生成一次“rsa”令牌(因为测试每 5 分钟是否发出新令牌会很无聊)。所以从创建模块开始”。/src/rsa.js "。

我们将通过使用“RxJS”主题来创建“可观察的”。主题是一个对象，您可以在其上调用三个主要函数:

*   “下一个”向“可观察的”上发射一个新值。
*   “error”在“observable”上发出一个错误。
*   “完成”表示可观察的完成。

这些功能有印象吗？这很正常，它们的名字与我们传递给“observable”的“subscribe”方法的回调相同。有不同种类的主题，我最常用的是:

*   主体:简单的主体，释放价值。
*   ReplaySubject:当您订阅绑定到“ReplaySubject”的可观察对象时，您将获得一定数量的过去已经发出的值。
*   BehaviorSubject:当您订阅绑定到“BehaviorSubject”的可观察对象时，您将获得最后一个发出的值，或者如果还没有发出任何值，将获得一个默认值。

在这里，我们将使用一个“行为主体”,以便在我们订阅可观察对象时拥有一个令牌。所以我们先从“RxJS”导入“BehaviorSubject”开始:

然后，实现负责令牌生成的函数。在这里，不会是火箭科学，只是 10000 到 99999 之间的一个随机数(甚至不确定，我没有彻底测试过，不过没关系；-) ).

接下来，我们创建我们的主题:

“BehaviorSubject”构造函数接受一个参数，该参数表示如果尚未发出任何值，将在订阅时发出的值。然后，我们需要每两秒钟发出一个新的令牌，为此，我们将使用主题的“下一个”函数:

最后，我们将导出一个默认函数，该函数将返回一个到我们主题的可观察边界。为此，我们只需调用主题的“asObservable”函数。

我们现在将使用这个模块在页面中显示生成的令牌。用以下代码更新您的“HTML”代码:

您的“index.js”包含:

第 1 行导入我们的“rsa”模块，第 3 行获取对页面“h1”的引用，第 5 行订阅我们的“observable ”,并为每个发出的值更新“h1”的内容。去吧，测试一下，你会看到每 2 秒钟一个新的代币。

请注意，如果我们使用“Subject”而不是“BehaviorSubject ”,我们将不会在前两秒看到任何令牌，因为普通的“Subject”不会在订阅时发出默认值。

# 我看不出错误/完全回调的意义:-(

到目前为止，我们刚刚看到了如何使用“下一个”回调，我们现在要看看如何使用另外两个回调。让我们给我们的 rsa 生成添加一个愚蠢的规则，声明即使我们生成 10000 到 99999 之间的令牌，如果令牌高于 50000，我们不会发出它，但我们会抛出一个错误。这没有任何意义，但这是我能想到的最简单的例子:-)

让我们首先实现错误抛出。为此，将您的“setTimeout”函数替换为以下函数:

因此，正如所承诺的，如果令牌小于或等于 50000，则主体发出值，然而，如果大于 50000，则会通过“可观察”抛出一个错误。现在我们需要在我们的“index.js”文件中捕获这个错误:

这一次，我们使用“subscribe”方法的第二个参数来显示“h1”中的错误。注意，如果一个错误通过“可观察的”被抛出，它就停止它。换句话说，只要你得到一个错误，你就不会得到任何后续的值。

完成一个可观察对象就像在上面扔一个错误一样简单，不用叫“错误”，你只要叫“完成”就行了。例如，一旦生成了 10 个令牌，我们将使用此代码来完成可观察性:

那么我们可以这样捕捉“完整的”回调:

这里，我选择传递一个对象，因为我不想处理“错误”回调，我发现这样更干净。

# 所以我不再需要承诺了？

我们都知道这种感觉…我们只是学到一些很酷的东西，以至于我们开始在任何地方使用它，即使它并不必要，只是因为…嗯…它很酷。如果你以前从未使用过“可观的”，你可能会倾向于这种行为，你甚至可能会认为现在你有了“可观的”，你就不再需要“承诺”了，但这并不完全正确。

在做决定之前，了解“承诺”和“可观察到的”之间的区别很重要:

*   承诺只能处理一个事件，并且本身不可取消。以“HTTP”请求为例。您执行它，然后您将收到一个“承诺”,一旦“HTTP”调用响应出现，该承诺就会立即执行。你不能取消这个电话，一旦你收到回复，你就不能再做其他任何事情了。
*   “可观察”可以处理零个、一个或多个事件。以 web 套接字连接为例。一旦你连接到它，你可能会收到无限多的信息，所以“可观”是处理这种情况的完美选择。

然而，并不是因为“可观察的”可以做“承诺”所做的一切，所以你必须到处使用“可观察的”。我建议在上述情况下继续使用“promises”:您只需要一个值，并且不需要取消 promises 或对它应用一些操作符(比如“map”或“debounceTime”)。

# 结论

这个帖子只介绍了“RxJS”是什么的很小一部分。事实上，我没有谈到“冷”和“热”之间的区别“可观测量”，我采取了简单的方法使用“RxJS 主题”,我只谈到两个运营商，而它存在几十个。然而，正如帖子标题所述，这只是对“RxJS”的介绍。如果你喜欢你刚刚在这里读到的，我建议你深入挖掘，了解更多关于“RxJS”的知识，因为这真的很棒。