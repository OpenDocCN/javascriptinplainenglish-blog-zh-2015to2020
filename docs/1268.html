<html>
<head>
<title>Guide to the Express Request Object — Body, Cookies and More</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">快速请求对象指南—正文、Cookies等</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/guide-to-the-express-request-object-body-cookies-and-more-f0cbdb834c8c?source=collection_archive---------2-----------------------#2020-02-21">https://javascript.plainenglish.io/guide-to-the-express-request-object-body-cookies-and-more-f0cbdb834c8c?source=collection_archive---------2-----------------------#2020-02-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/0ed79dada7f538c187a3896a902e4b13.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*yC8QZsohyzKS6Zji"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nickkarvounis?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nick Karvounis</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="6e6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">request对象让我们在中间件和路由处理程序中获得来自客户端的请求信息。</p><p id="ce24" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在本文中，我们将详细研究Express的请求对象的属性，包括获取请求体和cookies。</p><h1 id="a596" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">请求对象</h1><p id="3972" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们在上面的路由处理程序中的<code class="fe me mf mg mh b">req</code>参数是<code class="fe me mf mg mh b">req</code>对象。</p><p id="6000" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">它有一些属性，我们可以使用这些属性来获取客户端发出的请求的相关数据。下面列出了比较重要的几个。</p><h2 id="6bb6" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求应用程序</h2><p id="d7e5" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">req.app</code>属性保存了对使用中间件的Express应用实例的引用。</p><p id="e098" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="e614" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const path = require('path');<br/>const app = express();</span><span id="655d" class="mi lc iq mh b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="5149" class="mi lc iq mh b gy ng nd l ne nf">app.set('foo', 'bar');</span><span id="a010" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send(req.app.get('foo'));<br/>})</span><span id="5c4d" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="e888" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们运行<code class="fe me mf mg mh b">app.set(‘foo’, ‘bar’);</code>将<code class="fe me mf mg mh b">foo</code>设置为值<code class="fe me mf mg mh b">'bar'</code>，然后我们可以用<code class="fe me mf mg mh b">req.app</code>的<code class="fe me mf mg mh b">get</code>方法获得该值。</p><h2 id="e28c" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">req.baseUrl</h2><p id="2555" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">req.baseUrl</code>属性保存已挂载的路由器实例的基本URL。</p><p id="595c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="e92a" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');</span><span id="f7da" class="mi lc iq mh b gy ng nd l ne nf">const app = express();<br/>const greet = express.Router();<br/>greet.get('/', (req, res) =&gt; {<br/>  console.log(req.baseUrl);<br/>  res.send('Hello World');<br/>})</span><span id="bd52" class="mi lc iq mh b gy ng nd l ne nf">app.use('/greet', greet);</span><span id="8b29" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="6f0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从<code class="fe me mf mg mh b">console.log</code>得到<code class="fe me mf mg mh b">/greet</code>。</p><h2 id="c0d2" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求体</h2><p id="aa9b" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">req.body</code>有请求体。我们可以用<code class="fe me mf mg mh b">express.json()</code>解析JSON主体，用<code class="fe me mf mg mh b">express.urlencoded()</code>解析URL编码的请求。</p><p id="b745" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="1f33" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express')<br/>const app = express()</span><span id="e96c" class="mi lc iq mh b gy ng nd l ne nf">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="05ba" class="mi lc iq mh b gy ng nd l ne nf">app.post('/', (req, res) =&gt; {<br/>  res.json(req.body)<br/>})</span><span id="4311" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="49c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们用JSON主体发出POST请求时，我们得到的是我们在请求中发送的内容。</p><h2 id="8edb" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">req.cookies</h2><p id="3d39" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以获得带有<code class="fe me mf mg mh b">req.cookies</code>属性的请求所发送的cookies。</p><p id="fe6f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="fa4c" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const cookieParser = require('cookie-parser');<br/>const app = express();<br/>app.use(cookieParser());</span><span id="f90c" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send(req.cookies.name);<br/>})</span><span id="339b" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="7884" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，当我们像发送<code class="fe me mf mg mh b">name=foo</code>一样发送以<code class="fe me mf mg mh b">name</code>为关键字的<code class="fe me mf mg mh b">Cookie</code>请求头时，就会显示<code class="fe me mf mg mh b">foo</code>。</p><h2 id="31c2" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求新鲜</h2><p id="c4a8" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">fresh</code>属性表示该应用程序是“新鲜的”。如果<code class="fe me mf mg mh b">cache-control</code>请求头没有<code class="fe me mf mg mh b">no-cache</code>指令，且以下任何一项为<code class="fe me mf mg mh b">true</code>，则App app为“新的”:</p><ul class=""><li id="4443" class="nh ni iq kf b kg kh kk kl ko nj ks nk kw nl la nm nn no np bi translated"><code class="fe me mf mg mh b">if-modified-since</code>请求头被指定，<code class="fe me mf mg mh b">last-modified</code>请求头等于或早于<code class="fe me mf mg mh b">modified</code>请求头。</li><li id="e911" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe me mf mg mh b">if-none-match</code>请求头是<code class="fe me mf mg mh b">*</code></li><li id="b982" class="nh ni iq kf b kg nq kk nr ko ns ks nt kw nu la nm nn no np bi translated"><code class="fe me mf mg mh b">if-none-match</code>请求头在被解析成指令后，与<code class="fe me mf mg mh b">etag</code>响应头不匹配。</li></ul><p id="3c11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们可以如下使用它:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="fa60" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const path = require('path');<br/>const app = express();</span><span id="3543" class="mi lc iq mh b gy ng nd l ne nf">app.use(bodyParser.json());<br/>app.use(bodyParser.urlencoded({ extended: true }));</span><span id="ae2a" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send(req.fresh);<br/>})</span><span id="ad7c" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="ffd3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果这些条件不满足，我们就应该得到<code class="fe me mf mg mh b">false</code>。</p><figure class="mu mv mw mx gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nv"><img src="../Images/18a1ae4939008c069302a17baa25fcf0.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*FPVGX6er4OQcs_q4"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@aniket940518?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Aniket Bhattacharya</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="8227" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求主机名</h2><p id="f8e9" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用<code class="fe me mf mg mh b">req.hostname</code>从HTTP头中获取主机名。</p><p id="f8f5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当信任代理设置未评估为<code class="fe me mf mg mh b">false</code>时，Express将从<code class="fe me mf mg mh b">X-Forwarded-Host</code>报头字段获取值。报头可以由客户端或代理设置。</p><p id="f5cc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果有多个<code class="fe me mf mg mh b">X-Forwarded-Host</code>表头，将使用第一个。</p><p id="a6b1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，如果我们有:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="84c9" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express')<br/>const app = express()</span><span id="4c68" class="mi lc iq mh b gy ng nd l ne nf">app.use(express.json())<br/>app.use(express.urlencoded({ extended: true }))</span><span id="8ad0" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.json(req.hostname)<br/>})</span><span id="59a1" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000, () =&gt; console.log('server started'));</span></pre><p id="e643" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后，如果没有<code class="fe me mf mg mh b">X-Forwarded-Host</code>头，并且信任代理的评估结果不是<code class="fe me mf mg mh b">false</code>，我们就可以得到应用所在的域名。</p><h2 id="ee1b" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求. ip</h2><p id="c647" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">我们可以用这个属性获取发出请求的IP地址。</p><p id="b9d2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="83eb" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const cookieParser = require('cookie-parser');<br/>const app = express();<br/>app.use(cookieParser());</span><span id="a3cc" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send(req.ip);<br/>})</span><span id="9190" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="987b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们得到类似<code class="fe me mf mg mh b">::ffff:172.18.0.1</code>的显示。</p><h2 id="766a" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求. ips</h2><p id="b013" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">当<code class="fe me mf mg mh b">trust proxy</code>设置不是<code class="fe me mf mg mh b">false</code>时，该属性包含由<code class="fe me mf mg mh b">X-Forwarded-For</code>请求头指定的IP地址数组。</p><p id="da0a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">否则，它就是一个空数组。<code class="fe me mf mg mh b">X-Forwarded-For</code>可以由客户端或代理设置。</p><p id="3176" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">例如，我们可以如下使用它:</p><pre class="mu mv mw mx gt my mh mz na aw nb bi"><span id="727a" class="mi lc iq mh b gy nc nd l ne nf">const express = require('express');<br/>const bodyParser = require('body-parser');<br/>const app = express();<br/>app.set('trust proxy', true);</span><span id="2b91" class="mi lc iq mh b gy ng nd l ne nf">app.get('/', (req, res) =&gt; {<br/>  res.send(req.ips);<br/>})</span><span id="dda7" class="mi lc iq mh b gy ng nd l ne nf">app.listen(3000);</span></pre><p id="4efa" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然后我们从客户端或<code class="fe me mf mg mh b">X-Forwarded-For</code>头获取远程IPs。</p><h2 id="4623" class="mi lc iq bd ld mj mk dn lh ml mm dp ll ko mn mo lp ks mp mq lt kw mr ms lx mt bi translated">请求方法</h2><p id="4d2a" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated"><code class="fe me mf mg mh b">method</code>属性具有请求的请求方法，如GET、POST、PUT或DELETE。</p><h1 id="03ba" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">结论</h1><p id="e957" class="pw-post-body-paragraph kd ke iq kf b kg lz ki kj kk ma km kn ko mb kq kr ks mc ku kv kw md ky kz la ij bi translated">request对象有许多属性，用于获取有关接收到的HTTP请求的各种信息。</p><p id="f241" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">像<code class="fe me mf mg mh b">cookie-parser</code>这样的第三方中间件向请求对象添加了新的属性，以获取cookies数据等内容。</p></div></div>    
</body>
</html>