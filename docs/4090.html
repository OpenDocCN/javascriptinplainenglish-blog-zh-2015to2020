<html>
<head>
<title>Are You Using Imports &amp; Exports Properly?</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">你是否正确使用进出口？</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/are-you-using-imports-exports-properly-7ac77600cdcc?source=collection_archive---------12-----------------------#2020-11-15">https://javascript.plainenglish.io/are-you-using-imports-exports-properly-7ac77600cdcc?source=collection_archive---------12-----------------------#2020-11-15</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/42c13de60cb12016edbc72fc339bd937.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*fctoRJiqZqDEJSGo"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@andasta?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Andy Li</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="ae3c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">JavaScript模块由文件分隔并异步加载。使用关键字<code class="fe lb lc ld le b">export</code>定义导出，使用关键字<code class="fe lb lc ld le b">import</code>定义导入。</p><p id="255b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">虽然导入和导出的基础知识很容易理解，但是使用ES模块还有许多其他方法。在本文中，我们将讨论在模块中导出和导入的所有方法。</p></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="6811" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">出口</h1><p id="a48a" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们将研究三种类型的出口:</p><h2 id="c2ad" class="mp ln iq bd lo mq mr dn ls ms mt dp lw ko mu mv ma ks mw mx me kw my mz mi na bi translated">1.默认导出</h2><p id="164b" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">每个模块都有一个单独的<strong class="kf ir">默认</strong>导出，它表示从该模块导出的主值。一个模块中不能有多个默认导出。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="c73a" class="mp ln iq le b gy nj nk l nl nm">const foo = () =&gt; console.log('foo');</span><span id="17dd" class="mp ln iq le b gy nn nk l nl nm">export default foo;</span></pre><p id="758c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">默认情况下，我们也可以导出函数声明或类声明。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="590e" class="mp ln iq le b gy nj nk l nl nm">export default function foo() {<br/>  console.log('foo');<br/>}</span></pre><p id="8615" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以将值导出为默认导出。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="f5d4" class="mp ln iq le b gy nj nk l nl nm">export default 555;</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h2 id="f89d" class="mp ln iq bd lo mq mr dn ls ms mt dp lw ko mu mv ma ks mw mx me kw my mz mi na bi translated">2.命名出口</h2><p id="790d" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">任何变量声明都可以在创建时导出，方法是在声明前添加<code class="fe lb lc ld le b">export</code>关键字。这基本上创建了一个使用变量名作为导出名的命名导出。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="55de" class="mp ln iq le b gy nj nk l nl nm">export const foo = () =&gt; console.log('foo');</span></pre><p id="bbca" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以立即导出函数和类声明。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="b8fe" class="mp ln iq le b gy nj nk l nl nm">export function foo() {<br/> console.log('foo')<br/>}</span></pre><p id="24ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们想导出一个已经定义好的变量，我们可以用花括号把变量括起来。这通常在文件末尾完成。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="a5cc" class="mp ln iq le b gy nj nk l nl nm">const foo = () =&gt; console.log('foo');</span><span id="4364" class="mp ln iq le b gy nn nk l nl nm">export { foo };<!-- --> </span></pre><p id="c53d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了重命名已命名的导出，使用<code class="fe lb lc ld le b">as</code>关键字。我们也可以同时导出其他变量。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="9d58" class="mp ln iq le b gy nj nk l nl nm">const foo = () =&gt; console.log('foo');<br/>const bar = 123;</span><span id="999e" class="mp ln iq le b gy nn nk l nl nm">export { foo as printFoo, bar };</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h2 id="d4a4" class="mp ln iq bd lo mq mr dn ls ms mt dp lw ko mu mv ma ks mw mx me kw my mz mi na bi translated">3.出口总额</h2><p id="1ac3" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">有些情况下，我们必须从另一个文件导入模块，然后再导出它们。这种情况通常出现在从几个文件中导入模块，然后从一个文件中导出所有模块的地方。当您同时导入和导出大量内容时，这会变得很乏味。ES模块允许我们同时导入和导出多个值。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="fd73" class="mp ln iq le b gy nj nk l nl nm">export * from "./foo.js";</span></pre><p id="4995" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这将获取<code class="fe lb lc ld le b">./foo.js</code>的所有<strong class="kf ir"> <em class="no">名为</em> </strong>的导出，并重新导出它们。但是它不会重新导出默认导出，因为一个模块只能有一个默认导出。我们还可以专门从其他文件中导出默认模块，或者在重新导出时命名默认导出。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="8a6c" class="mp ln iq le b gy nj nk l nl nm">export { default } from "./foo.js";</span><span id="35ee" class="mp ln iq le b gy nn nk l nl nm">// or</span><span id="7cf6" class="mp ln iq le b gy nn nk l nl nm">export { default as foo } from "./foo.js";</span></pre><p id="54e3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以有选择地从另一个模块中导出不同的变量，而不是重新导出所有的变量。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="74ca" class="mp ln iq le b gy nj nk l nl nm">export { foo as printFoo, bar} from "./foo.js";<!-- --> </span></pre><p id="e7c5" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以使用<code class="fe lb lc ld le b">as</code>关键字将整个模块包装成一个单独的命名导出。假设，考虑下面的文件。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="281d" class="mp ln iq le b gy nj nk l nl nm">// funcs.js<br/>export function foo() {console.log('foo')}<br/>export function bar() {console.log('bar')}</span></pre><p id="2f9a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们现在可以将它打包到一个导出中，这个导出是一个包含所有命名和默认导出的对象。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="6b5e" class="mp ln iq le b gy nj nk l nl nm">export * as funcs from "./funcs.js"; <br/>// { foo: function foo(), bar: function bar() }</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="be34" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">进口</h1><p id="c6f2" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们将研究三种类型的进口:</p><h2 id="074c" class="mp ln iq bd lo mq mr dn ls ms mt dp lw ko mu mv ma ks mw mx me kw my mz mi na bi translated">1.默认导入</h2><p id="f831" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">当我们导入一个默认值时，我们需要给它指定一个名称。因为它是默认的，我们实际上可以给它任何你选择的名字。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="c55f" class="mp ln iq le b gy nj nk l nl nm">import fooFunctions from "./foo.js";</span></pre><p id="a51a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以同时导入所有导出，包括命名导出和默认导出。这将把所有的导出放到一个对象中，默认的导出将被赋予属性名<code class="fe lb lc ld le b">default</code>。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="9f68" class="mp ln iq le b gy nj nk l nl nm">import * as foo from "./foo.js"; <br/>// { default: foo }</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h2 id="54da" class="mp ln iq bd lo mq mr dn ls ms mt dp lw ko mu mv ma ks mw mx me kw my mz mi na bi translated">2.命名导入</h2><p id="e893" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">我们可以通过将导出的名称放在花括号中来导入任何命名的导出。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="3fd5" class="mp ln iq le b gy nj nk l nl nm">import { foo, bar } from "./foo.js";</span></pre><p id="15af" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以在导入时使用<code class="fe lb lc ld le b">as</code>关键字重命名导入。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="7dcd" class="mp ln iq le b gy nj nk l nl nm">import {foo as fooFunction, bar} from './foo.js`</span></pre><p id="b8b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我们还可以在同一个import语句中混合使用命名导出和默认导出。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="8951" class="mp ln iq le b gy nj nk l nl nm">import foo, { bar } from "./foo.js";</span></pre><p id="12dd" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">最后，我们可以导入一个模块，而不需要在文件中列出任何想要使用的导出。这被称为<strong class="kf ir">副作用导入</strong>，它将执行模块中的代码，而不向我们提供任何导出的值。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="ae2c" class="mp ln iq le b gy nj nk l nl nm">import "./fruitBasket.js";</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h2 id="bae8" class="mp ln iq bd lo mq mr dn ls ms mt dp lw ko mu mv ma ks mw mx me kw my mz mi na bi translated">3.动态导入</h2><p id="7d5b" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">有时，我们在导入文件之前不知道它的名称，或者在执行代码到一半时才需要导入文件。在这些情况下，我们可以使用动态导入在代码中的任何地方导入模块。</p><p id="7851" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因为ES模块是异步的，所以模块不会立即可用。我们必须等待它被加载，然后才能对它做任何事情。如果我们的模块找不到，动态导入将抛出一个错误。</p><p id="ca11" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">使用动态导入时，最好使用<code class="fe lb lc ld le b">try</code> / <code class="fe lb lc ld le b">catch </code>。</p><pre class="nb nc nd ne gt nf le ng nh aw ni bi"><span id="9a83" class="mp ln iq le b gy nj nk l nl nm">async function printFn() {<br/>  try {<br/>    const fooFn = await import('./foo.js');<br/>  } catch {<br/>    console.error("Error getting foo module:");<br/>  }<br/>  return fooFn();<br/>}</span></pre></div><div class="ab cl lf lg hu lh" role="separator"><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk ll"/><span class="li bw bk lj lk"/></div><div class="ij ik il im in"><h1 id="f584" class="lm ln iq bd lo lp lq lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj bi translated">结论</h1><p id="a68f" class="pw-post-body-paragraph kd ke iq kf b kg mk ki kj kk ml km kn ko mm kq kr ks mn ku kv kw mo ky kz la ij bi translated">需要记住的一点是，导出和静态导入只能发生在模块的顶层。另一方面，动态导入可以在函数内部完成。</p><p id="cf60" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章对你有所帮助。如果有，通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw?sub_confirmation=true" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅获取更多类似内容解码，我们的YouTube频道</strong> </a> <strong class="kf ir">！</strong></p></div></div>    
</body>
</html>