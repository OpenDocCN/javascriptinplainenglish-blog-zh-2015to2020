<html>
<head>
<title>ReactJS Training: Understanding React and TypeScript</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">ReactJS培训:理解React和打字稿</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/reactjs-training-understanding-react-and-typescript-d01deb2dd127?source=collection_archive---------5-----------------------#2020-01-02">https://javascript.plainenglish.io/reactjs-training-understanding-react-and-typescript-d01deb2dd127?source=collection_archive---------5-----------------------#2020-01-02</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/10845cfda170d88e83b80b0346f67455.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QaEF8m8VFeJrNZKifZVhSg.png"/></div></div></figure><blockquote class="jy jz ka"><p id="339b" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果你想知道西班牙语的版本，请点击<a class="ae la" href="https://medium.com/@nanovazquez/reactjs-training-entendiendo-react-y-typescript-5daf1fee26c7" rel="noopener">进入</a>。</p></blockquote><p id="150c" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在这个练习中，我们将介绍两个我们将用来开发web应用程序的核心库:<a class="ae la" href="https://reactjs.org/" rel="noopener ugc nofollow" target="_blank"> React </a>和<a class="ae la" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>。为此，我们将通过小而具体的例子来帮助我们理解主要概念，一次一个。</p><p id="7609" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">但是在开始编码之前，我们需要明白我们要做什么。想想你见过的最常见的用户界面(UI)布局，问问自己:</p><ol class=""><li id="a8bd" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">如果我必须做这个，我应该从哪里开始？我必须一个人做所有的事情吗？有什么我可以利用的吗？</li><li id="635f" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">我如何将工作分成不同的任务？最重要的有哪些？</li><li id="c91f" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">有可能在其他或未来的项目中重复使用我将要做的事情吗？</li></ol><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ls"><img src="../Images/c9524630e411fbc238dec5beb5fcf296.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*E_Ilu5tU08MknCMm_aASig.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">A typical back-office web application, displaying Products and their details</figcaption></figure><p id="571d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在接下来的几节中，我们将共同努力给出这些问题的答案。</p><h1 id="e9e7" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">简介:基于网络的开发</h1><p id="ed2b" class="pw-post-body-paragraph kb kc iq ke b kf mz kh ki kj na kl km lb nb kp kq lc nc kt ku ld nd kx ky kz ij bi translated">在开始编码之前，让我们快速回顾一下web开发的基本概念。</p><blockquote class="jy jz ka"><p id="66d5" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">如果您熟悉这些概念，请跳过这一部分，直接跳到第1部分。</p></blockquote><ul class=""><li id="f035" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz ne lk ll lm bi translated">基本上，Web应用程序是可以由(web)浏览器(Chrome、Firefox、Edge、Safari、Internet Explorer等)执行的应用程序。).</li><li id="fd2b" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">网络浏览器只懂HTML，JavaScript，CSS。</li><li id="62ad" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">HTML提供了网站的基本结构，也就是它的标记。</li><li id="4e35" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">CSS用于控制表示、格式和布局，也称为样式。</li><li id="7464" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">JavaScript用于动态改变不同HTML元素和CSS样式的行为。通常取决于用户交互(例如，点击按钮、手指轻击或者甚至语音)。</li></ul><p id="09f1" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">例如，当你因为想搜索某样东西而导航到谷歌网站时，你正在使用一个网络应用程序！</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi nf"><img src="../Images/7105f8c709bdd1bcb755be911e7389aa.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/1*jVUmWTg5736J4FEfO99rYQ.gif"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">When searching about React in Google we are using a web application</figcaption></figure><p id="c862" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在这种情况下:</p><ol class=""><li id="364f" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">页面的结构是用HTML定义的(显示为结果的文本，右边部分，等等。).</li><li id="f452" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">网站的结构是如何使用CSS配置的(字体的颜色，结果项的设计以及它们是如何显示的，等等。).</li><li id="9fc2" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">用户交互由JavaScript代码控制。例如，当某人键入一个问题并按下回车键时会发生什么是用代码配置的。</li></ol><p id="2735" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">随着时间的推移，我们可以在任何web应用程序中做的事情的数量和复杂性都在增加。幸运的是，我们现在可以(重新)使用JavaScript库来避免重新发明轮子并减少重复工作。React和TypeScript就是其中的一些库。</p><h1 id="ce76" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">第一部分:ReactJS是什么，它的用途是什么</h1><blockquote class="jy jz ka"><p id="d431" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注:</strong>想了解ReactJS的更多信息，去它的官方<a class="ae la" href="https://reactjs.org/docs/getting-started.html" rel="noopener ugc nofollow" target="_blank">入门</a>。</p></blockquote><p id="4d09" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">React是一个用于构建用户界面的JavaScript库。React最伟大的事情之一是它改变了你通常对创建应用程序的想法。它建议你按照<a class="ae la" href="https://en.wikipedia.org/wiki/Single_responsibility_principle" rel="noopener ugc nofollow" target="_blank">单一责任原则或SRP </a>将逻辑分割成多个部分，命名为<strong class="ke ir">组件</strong>:每个部分(组件)应该只做一件事。</p><p id="ccfd" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">以我们之前的UI布局为例，我们可以将页面分成(例如)以下组件:</p><ul class=""><li id="972c" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz ne lk ll lm bi translated">一个<em class="kd"> TableComponent </em>，用来显示我们所有的实体。</li><li id="162c" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated"><em class="kd"> SearchComponent </em>，过滤我们显示的实体。</li><li id="e5a4" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated"><em class="kd"> DetailsComponent </em>，显示与所选实体相关的信息。</li><li id="6997" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated"><em class="kd"> SidebarPanelComponent </em>，封装我们在左侧面板中呈现的内容的逻辑(链接和<em class="kd"> PROD </em>按钮)。</li><li id="7a39" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">…等等</li></ul><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ng"><img src="../Images/cbebd7cb1dc907079fa04c593abf7444.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*zN5xnZGTpqf--u0YpoS6aA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">A typical back-office web application, now split into different components</figcaption></figure><p id="ca66" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们将布局分割成组件的方式完全是任意的，尽管现在看起来很难做到，但随着时间的推移会变得更容易。试错法最终会帮助我们决定在可重用性和维护方面什么是最好的答案。</p><blockquote class="jy jz ka"><p id="939c" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>我们可以继续将我们定义的组件分割成更小的组件，每个组件负责完成一项任务。例如，您能否建议如何将TableComponent组件分成更小的部分？</p></blockquote><h1 id="67b5" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">在行动中反应</h1><p id="8727" class="pw-post-body-paragraph kb kc iq ke b kf mz kh ki kj na kl km lb nb kp kq lc nc kt ku ld nd kx ky kz ij bi translated">React是一个库，它通过将UI分解成组件来帮助我们构建UI。让我们通过回顾React文档中的例子来共同理解这意味着什么:</p><p id="e2d9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">打开<strong class="ke ir">喂反应过来了！</strong>点击<a class="ae la" href="https://codesandbox.io/s/hello-react-lbisk" rel="noopener ugc nofollow" target="_blank">此处</a>举例。</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="207c" class="nm mc iq ni b gy nn no l np nq">import React from "react";<br/>import ReactDOM from "react-dom";</span><span id="8c7c" class="nm mc iq ni b gy nr no l np nq">const App = () =&gt; &lt;h1&gt;Hello React!&lt;/h1&gt;;<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App /&gt;, rootElement);</span></pre><p id="d9ca" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">花几分钟时间分析代码。注意，<code class="fe ns nt nu ni b"><em class="kd">&lt;App/&gt;</em></code>组件是一个<em class="kd">反应函数</em>，它只返回<em class="kd"> JSX语法</em>。</p><blockquote class="jy jz ka"><p id="526a" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated">什么是JSX？ JSX是React生态系统中呈现HTML元素的事实上的语法扩展。它不是HTML，但语法非常相似。它可能会让您想起模板语言，但它也具有JavaScript的全部功能。如果你想更多地了解JSX，请看这里的<a class="ae la" href="https://reactjs.org/docs/introducing-jsx.html" rel="noopener ugc nofollow" target="_blank"/>。</p></blockquote><p id="ec69" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><strong class="ke ir">浏览器不理解JSX </strong>。为了让我们的代码在浏览器中工作，我们需要将我们的代码转换成浏览器能够理解的JavaScript代码。我们现在不需要担心这一点，但是您需要认识到，这段代码的最终结果是普通的旧JavaScript:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="9522" class="nm mc iq ni b gy nn no l np nq">var App = () =&gt; React.createElement("h1", null, "Hello React!")<br/>var rootElement = document.getElementById("root");</span><span id="b062" class="nm mc iq ni b gy nr no l np nq">ReactDOM.render(React.createElement(App, null), rootElement);</span></pre><p id="0da8" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们现在将通过向<code class="fe ns nt nu ni b">&lt;App/&gt;</code>组件提供定制呈现消息的能力来修改示例。为此:</p><p id="f22b" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">用发送给组件的<code class="fe ns nt nu ni b">message</code>参数替换硬编码的消息:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="96b7" class="nm mc iq ni b gy nn no l np nq">const App = ({ message }) =&gt; &lt;h1&gt;{message}&lt;/h1&gt;;</span></pre><p id="d004" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">初始化<code class="fe ns nt nu ni b">App</code>组件时提供一个定制的<code class="fe ns nt nu ni b">message</code>:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="7f7c" class="nm mc iq ni b gy nn no l np nq">ReactDOM.render(&lt;App message="Hello React!!" /&gt;, rootElement);</span></pre><p id="6ba3" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated"><em class="kd"> React函数</em>可以通过<strong class="ke ir"> props </strong>(简称<em class="kd"> properties </em>)接收任意的只读输入。这些<strong class="ke ir">道具</strong>模拟了函数返回的内容。例如，在我们前面的例子中，我们在浏览器中输出的消息依赖于<code class="fe ns nt nu ni b">message</code>属性。</p><blockquote class="jy jz ka"><p id="ec3c" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>作为一个通用规则，所有的反应功能&amp;组件必须作为相对于它们的道具的“纯功能”。这意味着它们在浏览器中返回(或呈现)的内容是由其输入值决定的，而不会改变接收到的参数/自变量(也称为“副作用”)。</p></blockquote><p id="a910" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">让我们来看另一个例子。点击此处的<a class="ae la" href="https://codesandbox.io/s/react-timer-2y4k8" rel="noopener ugc nofollow" target="_blank">打开<strong class="ke ir">反应定时器</strong>示例。</a></p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="bbe5" class="nm mc iq ni b gy nn no l np nq">class Timer extends React.Component {<br/>  ...<br/>}</span><span id="e507" class="nm mc iq ni b gy nr no l np nq">const App = () =&gt; &lt;Timer /&gt;;<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(App, rootElement);</span></pre><p id="29f4" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">注意，我们现在有两个文件:一个初始化应用程序的<em class="kd"> index.jsx </em>文件和一个定义React组件的<em class="kd"> Timer.jsx </em>文件。这一次，我们的React组件是一个从<code class="fe ns nt nu ni b">React.Component</code>扩展而来的类，有一个<code class="fe ns nt nu ni b">constructor()</code>和四个其他方法:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="4b76" class="nm mc iq ni b gy nn no l np nq">export default class Timer extends React.Component {<br/>  <br/>  constructor(props) { ... }<br/>  <br/>  tick() { ... }<br/>  <br/>  componentDidMount() { ... }<br/>  <br/>  componentWillUnmount() { ... }</span><span id="a2a2" class="nm mc iq ni b gy nr no l np nq">  render() {<br/>    return &lt;div&gt;Seconds: {this.state.seconds}&lt;/div&gt;;<br/>  }<br/>}</span></pre><p id="7030" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">React允许您将组件定义为类或函数。当你从<strong class="ke ir">伸出时做出反应。组件</strong>，唯一的要求是定义一个<strong class="ke ir"> render() </strong>方法，负责返回将在浏览器中显示的JSX元素。</p><p id="4315" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">此外，React类组件提供了在特定时间执行的其他内置方法。你可以<strong class="ke ir">将自己的代码与这些<a class="ae la" href="https://reactjs.org/docs/react-component.html#the-component-lifecycle" rel="noopener ugc nofollow" target="_blank">生命周期方法</a>挂钩，只需实现它们。其中一些方法是<code class="fe ns nt nu ni b">constructor()</code>、<code class="fe ns nt nu ni b">componentWillMount()</code>、<code class="fe ns nt nu ni b">componentWillUnmount()</code>，但还有其他的方法。</strong></p><blockquote class="jy jz ka"><p id="7524" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong><strong class="ke ir">render()</strong>方法相当于我们在前面的例子中使用的React函数。</p></blockquote><p id="51de" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">检查<code class="fe ns nt nu ni b">componentDidMount()</code>和<code class="fe ns nt nu ni b">componentWillUnmount()</code>中的代码。</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="0350" class="nm mc iq ni b gy nn no l np nq">export default class Timer extends React.Component {<br/>  ...</span><span id="b13c" class="nm mc iq ni b gy nr no l np nq">  componentDidMount() {<br/>    this.interval = setInterval(() =&gt; this.tick(), 1000);<br/>  }</span><span id="1659" class="nm mc iq ni b gy nr no l np nq">  componentWillUnmount() {<br/>    clearInterval(this.interval);<br/>  }</span><span id="fa81" class="nm mc iq ni b gy nr no l np nq">  ...<br/>}</span></pre><p id="9b3f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">这段代码负责初始化、执行和清理定时器。通过使用这两个内置方法，React保证在组件在DOM中呈现(“挂载”)和从DOM中移除(“卸载”)时执行您的代码。</p><blockquote class="jy jz ka"><p id="9e11" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>如果您想了解更多关于状态和生命周期的信息，请点击查看<a class="ae la" href="https://reactjs.org/docs/state-and-lifecycle.html" rel="noopener ugc nofollow" target="_blank">。</a></p></blockquote><p id="3cad" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">最后，我们来回顾一下最后一种方法。自定义的<code class="fe ns nt nu ni b">tick()</code>方法通过调用<code class="fe ns nt nu ni b">this.setState()</code>来更新组件的状态:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="6d7e" class="nm mc iq ni b gy nn no l np nq">export default class Timer extends React.Component {<br/>  ...</span><span id="326c" class="nm mc iq ni b gy nr no l np nq">  tick() {<br/>    this.setState(prevState =&gt; (<br/>      { seconds: prevState.seconds + 1 }<br/>    ));<br/>  }</span><span id="30f4" class="nm mc iq ni b gy nr no l np nq">  ...<br/>}</span></pre><p id="1a30" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">每个React组件都可以将其本地状态存储在<code class="fe ns nt nu ni b">this.state</code>中。<strong class="ke ir">状态</strong>类似于道具，但是是私有的，完全由组件控制。<strong class="ke ir">不得直接修改状态</strong>。相反，你应该总是使用<code class="fe ns nt nu ni b">this.setState()</code>方法并返回一个新的状态。</p><blockquote class="jy jz ka"><p id="fa5e" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>您不应该直接改变状态的原因是，状态更新可能<em class="iq">潜在地</em>触发<code class="fe ns nt nu ni b"><em class="iq">render()</em></code>方法的新执行，重新绘制组件。如果您使用<code class="fe ns nt nu ni b"><em class="iq">this.setState()</em></code>，React将为您进行这个调用，以及其他计算。</p></blockquote><p id="6d13" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">我们现在是本节的最后一个例子。点击<a class="ae la" href="https://codesandbox.io/s/react-questionnaire-4che1" rel="noopener ugc nofollow" target="_blank">此处</a>打开<strong class="ke ir">问卷</strong>示例。</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="7f3b" class="nm mc iq ni b gy nn no l np nq">class Questionnaire extends React.PureComponent {<br/>  ...<br/>}</span><span id="948a" class="nm mc iq ni b gy nr no l np nq">const App = () =&gt; &lt;Questionnaire /&gt;;<br/>const rootElement = document.getElementById("root");<br/>ReactDOM.render(&lt;App /&gt;, rootElement);</span></pre><p id="87d6" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">花几分钟时间来分析所有涉及到的代码片段，以及它们每一个的职责。然后，玩复选框，看看结果。</p><p id="d327" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">打开<strong class="ke ir"> Question.jsx </strong>和<strong class="ke ir"> Answer.jsx </strong>，注意这些文件建模了一个React函数(或React函数组件),它们接收不同的属性并返回一个结果，通过jsx建模。</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="09d2" class="nm mc iq ni b gy nn no l np nq">export default ({ question, value }) =&gt; (<br/>  &lt;p&gt;<br/>    &lt;span&gt;{`${question}: ${value}`}&lt;/span&gt;<br/>  &lt;/p&gt;<br/>);</span></pre><p id="c70e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">打开<strong class="ke ir">问卷. jsx </strong>文件。看看呈现组件的不同部分所使用的方法:问题和答案。注意我们如何使用<code class="fe ns nt nu ni b">render()</code>方法编排所有的绘图逻辑。</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="502b" class="nm mc iq ni b gy nn no l np nq">export default class Questionnaire extends React.PureComponent {<br/>  ...<br/>  <br/>  renderQuestions() {<br/>    ...<br/>  }</span><span id="6b52" class="nm mc iq ni b gy nr no l np nq">  renderAnswers() {<br/>    ...<br/>  }</span><span id="ccd2" class="nm mc iq ni b gy nr no l np nq">  render() {<br/>    return (<br/>      &lt;React.Fragment&gt;<br/>        {this.renderQuestions()}<br/>        {this.renderAnswers()}<br/>      &lt;/React.Fragment&gt;<br/>    );<br/>  }<br/>}</span></pre><blockquote class="jy jz ka"><p id="6eea" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong> React Fragment是一个内置组件，用于(逻辑上)分组一系列子节点，而无需向DOM添加额外的节点。如果你想了解更多，点击<a class="ae la" href="https://reactjs.org/docs/fragments.html" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote><p id="e73d" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">关注<code class="fe ns nt nu ni b">renderQuestions()</code>方法并定位<code class="fe ns nt nu ni b">onChange</code>支柱。请注意，我们向<code class="fe ns nt nu ni b">onChange</code> prop传递了一个<code class="fe ns nt nu ni b">this.handleQuestionChanged()</code>方法，如果问题得到回答，该方法将更新UI，并将值存储在(问卷调查)组件的状态中:</p><pre class="lt lu lv lw gt nh ni nj nk aw nl bi"><span id="0e11" class="nm mc iq ni b gy nn no l np nq">export default class Questionnaire extends React.PureComponent {<br/>  ...</span><span id="bbac" class="nm mc iq ni b gy nr no l np nq">  renderQuestions() {<br/>    ...<br/>    <br/>    return questions.map(question =&gt; (<br/>      &lt;Question<br/>        key={question.id}<br/>        id={question.id}<br/>        text={question.text}<br/>        checked={question.value}<br/>        onChange={this.handleQuestionChanged}<br/>      /&gt;<br/>    ));<br/>  }</span><span id="f42c" class="nm mc iq ni b gy nr no l np nq">  ...<br/>}</span></pre><p id="efb9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">请注意，我们处理用户交互的方式(通过<em class="kd">“events”</em>)与普通JS代码类似:</p><ul class=""><li id="8c8e" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz ne lk ll lm bi translated">所有JSX元素都公开了一组事件(参见这里的所有支持的事件<a class="ae la" href="https://reactjs.org/docs/events.html#supported-events" rel="noopener ugc nofollow" target="_blank"/>)。</li><li id="841c" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">我们可以通过给每个事件附加一个函数来与它挂钩。默认情况下，它将接收一个<a class="ae la" href="https://reactjs.org/docs/events.html" rel="noopener ugc nofollow" target="_blank">合成事件</a>对象作为第一个参数，但是<a class="ae la" href="https://reactjs.org/docs/handling-events.html#passing-arguments-to-event-handlers" rel="noopener ugc nofollow" target="_blank">您可以更改这个</a>。</li></ul><h2 id="3785" class="nm mc iq bd md nv nw dn mh nx ny dp ml lb nz oa mp lc ob oc mt ld od oe mx of bi translated">包扎</h2><p id="b440" class="pw-post-body-paragraph kb kc iq ke b kf mz kh ki kj na kl km lb nb kp kq lc nc kt ku ld nd kx ky kz ij bi translated">通过回顾这些例子，我们了解到以下内容:</p><ol class=""><li id="8744" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz lj lk ll lm bi translated">在React中，我们通常用<strong class="ke ir"> JSX </strong>来描述UI应该是什么样子。</li><li id="4cb0" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">为了定制我们输出的内容，我们可以将<strong class="ke ir"> props </strong>发送给我们的React函数或组件。</li><li id="d0e4" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">React提供了<strong class="ke ir"> React。Component </strong>类来帮助将我们的代码封装在组件中。</li><li id="c5ff" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">一个<strong class="ke ir"> React的<strong class="ke ir"> render() </strong>方法的输出。组件</strong>告诉浏览器我们想要画什么。</li><li id="096a" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">每个React组件都有自己的<strong class="ke ir">状态</strong>来本地存储值。</li><li id="0db2" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz lj lk ll lm bi translated">您可以通过将函数或类方法与JSX事件挂钩来捕捉用户交互。</li></ol><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi og"><img src="../Images/e765852be1f3f58df34fa54e656dae9c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*3yqBUQ7qzBtlrXpUUhI1Dw.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk"><a class="ae la" href="http://here" rel="noopener ugc nofollow" target="_blank">I</a>n React, data flows in one direction (top-down, from parent to child), and events flow from bottoms-up</figcaption></figure><blockquote class="jy jz ka"><p id="4951" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>您可以在<a class="ae la" href="https://reactjs.org/docs/hello-world.html" rel="noopener ugc nofollow" target="_blank"> React文档</a>中找到一组完整的示例，每一个都集中在一个单独的React概念上。</p></blockquote><h1 id="0e67" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">第2部分:TypeScript添加了什么</h1><p id="ead2" class="pw-post-body-paragraph kb kc iq ke b kf mz kh ki kj na kl km lb nb kp kq lc nc kt ku ld nd kx ky kz ij bi translated"><a class="ae la" href="https://www.typescriptlang.org/" rel="noopener ugc nofollow" target="_blank"> TypeScript </a>是微软开发和维护的开源库，用于在JavaScript环境中实现大规模应用。它编译成普通的JavaScript，可以在任何浏览器、Node.js或任何支持<a class="ae la" href="https://en.wikipedia.org/wiki/ECMAScript" rel="noopener ugc nofollow" target="_blank"> ECMAScript </a> 3(或更新版本)的JavaScript引擎上运行。</p><p id="0331" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">本质上，它是JavaScript的一个严格的语法超集，在开发时为语言<strong class="ke ir">添加了可选的静态类型。</strong></p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oh"><img src="../Images/ada86e541bd5da0f94fb7ef0b1f03c3f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*nS98HlMhgmrJ-jh_odxCNg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">TypeScript has great IDE support nowadays</figcaption></figure><p id="4dc5" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">使用该库的主要好处是:</p><ul class=""><li id="c181" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz ne lk ll lm bi translated">它有静态检查和代码重构，以及一系列高效的开发工具和实践。</li><li id="3163" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">它允许您使用最新的特性和语法编写代码，而不用担心浏览器的支持(因为它会编译成普通的JS)。</li><li id="30f3" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">它不会强迫你使用TypeScript:如果你愿意，你可以写JavaScript。</li><li id="c088" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">微软和谷歌维护它。Angular使用它。</li></ul><h1 id="7e53" class="mb mc iq bd md me mf mg mh mi mj mk ml mm mn mo mp mq mr ms mt mu mv mw mx my bi translated">运行中的TypeScript</h1><p id="74e6" class="pw-post-body-paragraph kb kc iq ke b kf mz kh ki kj na kl km lb nb kp kq lc nc kt ku ld nd kx ky kz ij bi translated">让我们用一个例子来看看TypeScript是如何工作的:</p><p id="f619" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">打开<a class="ae la" href="http://www.typescriptlang.org/play/" rel="noopener ugc nofollow" target="_blank">打字稿游乐场</a>。这个运动场使用与VSCode IDE解释代码相同的工具。</p><p id="a367" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">在页面左侧的下拉菜单中，选择选项<a class="ae la" href="http://www.typescriptlang.org/play/?target=1&amp;e=178#example/hello-world" rel="noopener ugc nofollow" target="_blank"> Hello world </a>。花点时间彻底阅读它的代码，理解TypeScript是什么和做什么。如果你愿意，继续阅读<em class="kd"> JavaScript Essentials </em>部分的其他例子。</p><p id="c3e9" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">现在打开<a class="ae la" href="http://www.typescriptlang.org/play/?e=155#example/classes-101" rel="noopener ugc nofollow" target="_blank">类101 </a>的例子。让我们一起来回顾一下:</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi oi"><img src="../Images/bebd8fc5bf909ce565c2046ec3071658.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*CKy7PNNT5xx-FoD3qn48jA.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">TypeScript Classes 101 example</figcaption></figure><ul class=""><li id="866e" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz ne lk ll lm bi translated">在左边的面板中，有定义<code class="fe ns nt nu ni b">Vendor</code>类的类型脚本代码和一个欢迎客户来商店的方法，通过它的名字来识别。</li><li id="962e" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">在右侧面板中，您可以看到通过将TypeScript代码传输到ES2017生成的JavaScript等价物。这是浏览器理解并能运行的代码。</li><li id="2610" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">类似地，左边有定义<code class="fe ns nt nu ni b">FoodTruck</code>类的TypeScript代码，以及一个欢迎新客户端的方法。</li></ul><p id="58eb" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">将鼠标悬停在第47行的<code class="fe ns nt nu ni b">FoodTruck</code>实例化上。请注意，IDE显示了有关其构造函数的信息。</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div class="gh gi oj"><img src="../Images/d9d8db9144339ce5d7385dfb38c09e64.png" data-original-src="https://miro.medium.com/v2/resize:fit:1024/format:webp/1*eIQUCehM-eUKmHyzM1FdLA.png"/></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">IDEs like VSCode provide IntelliSense for TypeScript code</figcaption></figure><p id="bd9e" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">添加第二个参数来实例化一个<code class="fe ns nt nu ni b">FoodTruck</code>，比如<code class="fe ns nt nu ni b">"asado"</code>。现在，通过右键单击页面打开浏览器的开发人员控制台(或开发人员工具)(但是在编辑器之外，比如在顶部的蓝色导航栏中)。然后，点击<strong class="ke ir">运行</strong>按钮。</p><p id="016f" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">嘿！我们的更改没有显示在控制台上，这不公平。要使其工作，要么在<em class="kd">行48 </em>上添加<code class="fe ns nt nu ni b">console.log(nameOnlyTruck.greet());</code>，要么用<code class="fe ns nt nu ni b">nameOnlyTruck</code>实例替换<em class="kd">行54 </em>。然后点击<strong class="ke ir">再次运行</strong>。</p><blockquote class="jy jz ka"><p id="685e" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><strong class="ke ir">注意:</strong>每个现代的网络浏览器都包括一套强大的开发工具，帮助开发人员理解浏览器解释的内容，并找到代码中可能存在的错误(HTML、JavaScript或CSS)。它还显示了一些指标，比如页面加载需要多长时间，以及浏览器发出的(和正在发出的)其他请求。如果你想深入了解这一点，点击<a class="ae la" href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_are_browser_developer_tools" rel="noopener ugc nofollow" target="_blank">这里</a>。</p></blockquote><p id="eb70" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">最后，用数字<code class="fe ns nt nu ni b">1</code>替换字符串<code class="fe ns nt nu ni b">"asado"</code>。现在代码中有一个错误告诉你“数字不允许作为构造函数的参数”。请注意，这显示在TypeScript面板中，而不是JavaScript中(右侧面板)。</p><figure class="lt lu lv lw gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ok"><img src="../Images/0d3226936f9c9085e242e3a67b9cfa26.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*Ga7EGh9giRkkbutPGBPCvg.png"/></div></div><figcaption class="lx ly gj gh gi lz ma bd b be z dk">With IntelliSense, you can detect errors before running your code</figcaption></figure><p id="c6ff" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">通过将数字<code class="fe ns nt nu ni b">1</code>替换为字符串值(如<code class="fe ns nt nu ni b">"helado"</code>)来解决这个问题。</p><p id="cc01" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi translated">就是这样！</p><h2 id="f22c" class="nm mc iq bd md nv nw dn mh nx ny dp ml lb nz oa mp lc ob oc mt ld od oe mx of bi translated">包扎</h2><p id="299a" class="pw-post-body-paragraph kb kc iq ke b kf mz kh ki kj na kl km lb nb kp kq lc nc kt ku ld nd kx ky kz ij bi translated">通过这个简单的例子，我们了解到:</p><ul class=""><li id="e710" class="le lf iq ke b kf kg kj kk lb lg lc lh ld li kz ne lk ll lm bi translated">TypeScript代码可以转换成任何浏览器都可以执行的JavaScript代码。<em class="kd">你可以在这里</em>  <em class="kd">找到它的手册</em> <a class="ae la" href="https://www.typescriptlang.org/docs/handbook/basic-types.html" rel="noopener ugc nofollow" target="_blank"> <em class="kd">。</em></a></li><li id="e1f2" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">TypeScript允许您像在强类型语言中那样定义类型。<em class="kd">这里</em>  <em class="kd">可以找到它的规格</em> <a class="ae la" href="https://github.com/Microsoft/TypeScript/blob/master/doc/spec.md" rel="noopener ugc nofollow" target="_blank"> <em class="kd">。</em></a></li><li id="9697" class="le lf iq ke b kf ln kj lo lb lp lc lq ld lr kz ne lk ll lm bi translated">所有现代的ide(vs code，WebStorm，Atom等。)支持TypeScript，可以提供提示和错误消息(IntelliSense)，以及静态分析(通过<a class="ae la" href="https://palantir.github.io/tslint/" rel="noopener ugc nofollow" target="_blank"> tslint </a>)。</li></ul><p id="95be" class="pw-post-body-paragraph kb kc iq ke b kf kg kh ki kj kk kl km lb ko kp kq lc ks kt ku ld kw kx ky kz ij bi">🎉</p></div><div class="ab cl ol om hu on" role="separator"><span class="oo bw bk op oq or"/><span class="oo bw bk op oq or"/><span class="oo bw bk op oq"/></div><div class="ij ik il im in"><blockquote class="jy jz ka"><p id="6203" class="kb kc kd ke b kf kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz ij bi translated"><em class="iq">记住你可以在</em> <a class="ae la" href="https://github.com/nanovazquez/reactjs-training" rel="noopener ugc nofollow" target="_blank"> <strong class="ke ir"> <em class="iq">这个GitHub资源库</em> </strong> </a> <em class="iq">里找到完整的训练。</em></p></blockquote></div></div>    
</body>
</html>