<html>
<head>
<title>Using Firebase for storage and auth with Restify &amp; NodeJS</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">通过Restify &amp; NodeJS使用Firebase进行存储和授权</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/using-firebase-for-storage-and-auth-with-restify-nodejs-d14a8f72a586?source=collection_archive---------5-----------------------#2020-05-08">https://javascript.plainenglish.io/using-firebase-for-storage-and-auth-with-restify-nodejs-d14a8f72a586?source=collection_archive---------5-----------------------#2020-05-08</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/80b94ce419ad3648db3d2433b23232e5.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*v4z6ny9xeLIbNQlu"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@fourcolourblack?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Adam Wilson</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="a9c2" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我最近一直在构建一个API，为我将要构建的CV应用程序实现基本的创建、读取、更新、删除(CRUD)功能。</p><p id="32d7" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><a class="ae kc" href="https://medium.com/@colinwren/building-an-api-consumer-first-with-pact-88360a19bf0d" rel="noopener">我首先使用Pact </a>构建API消费者，一旦我很高兴我的API满足了带有存根的消费者契约，我就开始实现用于存储和授权的<a class="ae kc" href="https://firebase.google.com/" rel="noopener ugc nofollow" target="_blank">Firebase</a>，使用消费者契约来确保我没有破坏任何东西。</p><p id="bec6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是我第一次使用Firebase，因为如果我需要实现授权，我通常会退回到我的舒适区Django和PostgreSQL，但我过去曾使用过<a class="ae kc" href="http://restify.com/" rel="noopener ugc nofollow" target="_blank"> Restify </a>,并很喜欢它，所以决定尝试一下Firebase，因为它有望轻松实现授权和存储。</p><h1 id="26b5" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Firebase添加身份验证</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/0f0f77f868978b3f89a87d8c74e4761e.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*xAVrhEHxBizAPhts"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@siora18?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Siora Photography</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="e518" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现成的Firebase支持相当多的身份验证后端，我认为您很难找到一个用户没有至少一个提供后端的帐户，在编写本文时，这些帐户包括:</p><ul class=""><li id="3914" class="me mf iq kf b kg kh kk kl ko mg ks mh kw mi la mj mk ml mm bi translated">电子邮件地址和密码</li><li id="1322" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">电子邮件地址和一次性链接</li><li id="5d61" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">电话号码</li><li id="87f6" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">脸谱网</li><li id="b285" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">推特</li><li id="bc19" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">谷歌</li><li id="ff83" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">微软</li><li id="6f62" class="me mf iq kf b kg mn kk mo ko mp ks mq kw mr la mj mk ml mm bi translated">苹果</li></ul><p id="04ac" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的例子中，我使用电子邮件地址和密码。</p><h2 id="8051" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">创建新用户</h2><p id="33b2" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">在让用户登录之前，您需要让他们注册您的应用程序。</p><p id="f373" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了做到这一点，您可以使用<code class="fe nj nk nl nm b">firebase.auth().createUserWithEmailAndPassword()</code>函数来创建帐户或抛出一个错误，然后使用<code class="fe nj nk nl nm b">firebase.auth().currentUser.getIdToken()</code>函数来为该用户获取一个auth令牌。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Wrap a try/catch around this and you’ve got a means of signing the user up and returning their auth token to them</figcaption></figure><h2 id="1edd" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">登录现有用户</h2><p id="cc71" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">一旦用户第一次登录到您的应用程序，他们就可以使用<code class="fe nj nk nl nm b">firebase.auth().signInWithEmailAndPassword()</code>函数登录，类似于<code class="fe nj nk nl nm b">createUserWithEmailAndPassword()</code>函数，但是需要调用<code class="fe nj nk nl nm b">getIdToken()</code>来获得他们的认证令牌。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Wrap a try/catch around this and you’ve got a means of singing the user in and returning their auth token to them</figcaption></figure><h2 id="13bb" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">从JWT获取用户</h2><p id="8420" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">一旦用户成功注册或登录，并且获得了他们的auth令牌，他们就需要在随后对API的调用中使用该令牌来验证他们自己，这通常是通过在Authorization头中使用它作为载体令牌来完成的(例如<code class="fe nj nk nl nm b">Authorization: Bearer [TOKEN]</code>)。</p><p id="e8d3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在Restify中，您可以将函数作为中间件应用于对服务器的所有调用，并在调用控制器之前执行任务。</p><p id="c88e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我创建了一个函数来做这件事，然后使用<code class="fe nj nk nl nm b">server.use()</code>函数来应用它，中间件函数采用与普通控制器相同的<code class="fe nj nk nl nm b">(req, res, next)</code>参数。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Grab the JWT, get the user from it and set that on the request to be accessed by later controllers</figcaption></figure><p id="e692" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了从JWT获取用户记录，您需要调用<code class="fe nj nk nl nm b">admin.auth().verifyIdToken()</code>，它将返回令牌中包含的信息。然后您可以使用带有<code class="fe nj nk nl nm b">admin.auth().getUser()</code>的<code class="fe nj nk nl nm b">sub</code>属性来加载用户记录。</p><p id="3746" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦我获得了用户记录，我就使用Restify的<code class="fe nj nk nl nm b">req.set()</code>函数来设置请求的用户对象，然后可以通过后续控制器中的<code class="fe nj nk nl nm b">req.get()</code>来访问用户记录。</p><h2 id="259a" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">明白了—注销不会吊销令牌</h2><p id="4611" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><a class="ae kc" href="https://firebase.google.com/docs/reference/js/firebase.auth.Auth#signout" rel="noopener ugc nofollow" target="_blank">Firebase文档</a>建议您调用<code class="fe nj nk nl nm b">firebase.auth().signOut()</code>来结束用户的会话，但这实际上并没有撤销用户的授权令牌，这意味着用户仍然可以在他们使用的令牌创建后的一个小时内访问文档。</p><p id="d9a1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">相反,<code class="fe nj nk nl nm b">signOut()</code>告诉Firebase在用户令牌到期时不要更新它。我还没有找到在注销时完全撤销访问权的方法，所以在使用Firebase进行auth时要记住这一点。</p><h1 id="e5bc" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">使用Firebase作为存储</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi lz"><img src="../Images/9534ab9c794eb43617544ef03c70d734.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*D_JKCoEUcDRDkXnN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@findthevision?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Danny</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bcd4" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Firebase使用文档存储结构。与大多数NoSQL解决方案类似，它没有绑定到模式，因此可以用于保存文档之间的不同数据。</p><p id="1188" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还没有机会深入了解Firebase的存储方面，但据我目前所见，它相对容易使用，但像大多数NoSQL存储一样，您需要提前计划如何横向扩展。</p><p id="04c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">Firebase使用<code class="fe nj nk nl nm b">collections</code>作为分离文档类型的一种方式，所以如果你想处理一系列包含狗的数据的文档，你可以使用<code class="fe nj nk nl nm b">admin.firestore().collection('dogs')</code>，然后对集合执行操作。</p><p id="d95a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在集合中有一系列对文档的引用；这些引用对象是您创建、删除、更新和读取文档的交互方式。</p><h2 id="0f14" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">设置事物</h2><p id="b10c" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">为了使用Firebase存储，您需要使用<code class="fe nj nk nl nm b">admin.firestore()</code>初始化Firestore，它会返回一个对象，您可以使用它来执行文档操作。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The db constant will then be used to perform any database operations.</figcaption></figure><h2 id="56ba" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">创建文档</h2><p id="1a07" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">创建文档非常简单，只需使用<code class="fe nj nk nl nm b">db.collection('dogs').doc()</code>在集合中创建一个新文档，它将返回对新创建文档的引用。</p><p id="afe9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">该文档引用有一个名为<code class="fe nj nk nl nm b">set()</code>的方法，用于更新存储在该文档中的数据。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The document reference is really important for dealing with the record</figcaption></figure><h2 id="84bf" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">搜索文档</h2><p id="7870" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">一旦你创建了一个文档，你很可能想要在以后检索它并与之交互。</p><p id="2740" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您仍然将ref存储在某个地方，那么这样做是很容易的，但通常情况下，您需要进行搜索来找到它，或者根据某个条件对多个文档进行搜索(比如用户ID来获取该用户的所有文档)。</p><p id="3b3f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了搜索一个文档，你需要获得一个存储该文档的集合的引用，这个引用有一个叫做<code class="fe nj nk nl nm b">where()</code>的方法，可以用来提供一个谓词来进行搜索。</p><p id="b214" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦使用由<code class="fe nj nk nl nm b">where()</code>提供的<code class="fe nj nk nl nm b">get()</code>函数执行了搜索，结果对象将具有一个<code class="fe nj nk nl nm b">docs</code>属性，这是一个返回文档的数组。</p><p id="00c6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在下面的例子中，我搜索与用户相关的所有文档，然后向用户返回一个id数组。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">The predicate can search in nested objects using dot syntax</figcaption></figure><p id="0c29" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有一点需要注意，因为Firebase是一个NoSQL数据库。您需要在您的模式中找到一种方法来存储您想要搜索的属性，例如<code class="fe nj nk nl nm b">userId</code>，因为默认情况下不会提供这些属性，在我的应用程序中，我不得不扩展我的文档的元对象的模式，以包含<code class="fe nj nk nl nm b">userId</code>来搜索它。</p><h2 id="3eeb" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">阅读文件</h2><p id="8dbe" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">通过文档ID直接访问文档以便从中读取数据的管理方式类似于执行搜索，唯一的区别是为集合提供文档ID意味着不需要提供谓词。</p><p id="51c1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以使用<code class="fe nj nk nl nm b">db.collection('dogs').doc(DOCUMENT_ID)</code>获得对文档的引用，它返回对集合中文档的引用，类似于您需要调用<code class="fe nj nk nl nm b">get()</code>来获得对文档本身的引用的搜索。</p><p id="0cef" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦获得了文档引用，就可以使用引用的<code class="fe nj nk nl nm b">exists</code>属性来检查文档是否确实存在，并调用<code class="fe nj nk nl nm b">data()</code>方法来读取文档数据本身。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">I like to split the collection reference logic into a separate function to allow for re-use</figcaption></figure><h2 id="5652" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">更新文档</h2><p id="6661" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">对文档的更新是在文档引用上执行的，并作为单个深度对象提供。</p><p id="137a" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">任何需要更新的嵌套对象属性都需要以点语法提供(例如，要更新<code class="fe nj nk nl nm b">meta</code>对象的<code class="fe nj nk nl nm b">userId</code>属性，您需要提供<code class="fe nj nk nl nm b">meta.userId</code>作为更新对象中的键)。</p><p id="ad0d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当处理需要对嵌套对象使用点语法时，我发现<code class="fe nj nk nl nm b">dotize</code>库很有用。</p><p id="df82" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一旦获得了正确格式的更新数据，就可以调用文档引用的<code class="fe nj nk nl nm b">update()</code>方法。</p><p id="a3be" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">然而，对文档的更新并没有更新现有的文档引用，所以如果您希望将更新后的文档返回给用户，您需要再次获取它并从中读取数据。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Dotize is great for taking nested objects and converting them to dot syntax</figcaption></figure><h2 id="a464" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">删除文档</h2><p id="32f7" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">删除一个文档非常简单，只需在文档引用上调用<code class="fe nj nk nl nm b">delete()</code>即可。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">I return true or false as a means of knowing if the document existed but this isn’t necessary</figcaption></figure><h1 id="5452" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">测试用熄灭火源</h1><figure class="ma mb mc md gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi np"><img src="../Images/34f885d40ada333679de28d93d6d1286.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*041xsovpIC6SzpvS"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@nicolasthomas?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Nicolas Thomas</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="2036" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如本文开头提到的，<a class="ae kc" href="https://medium.com/@colinwren/building-an-api-consumer-first-with-pact-88360a19bf0d" rel="noopener">我在构建我的API实现时一直使用Pact来实践TDD</a>，由于Pact创建的Pact的静态特性，我需要在测试中使用存根值。</p><p id="b179" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">即使我没有使用Pact，但是我仍然希望存根我的Firebase调用，因为这将允许我测试我的应用程序如何响应各种场景，而不需要有一个运行的Firebase来连接和操纵返回我需要验证的状态。</p><p id="dbf9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我使用<a class="ae kc" href="https://jestjs.io/docs/en/manual-mocks" rel="noopener ugc nofollow" target="_blank"> Jest作为我的测试运行程序，因为它有一个非常有用的自动模仿特性</a>，这意味着将模块放在项目根目录下的<code class="fe nj nk nl nm b">__mock__</code>目录中会将这些模块作为存根应用于测试代码中导入的实际模块。</p><p id="eb4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这取代了使用像<code class="fe nj nk nl nm b">proxyquire</code>和<code class="fe nj nk nl nm b">Rewire</code>这样的库来控制被测代码将与之交互的库的需要。</p><h2 id="bc0a" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">嘲弄火焰基地-管理</h2><p id="a7cf" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe nj nk nl nm b">firebase-admin</code>是提供JWT阅读和firestore功能的模块，因此大多数firebase呼叫都是在这里进行的。</p><p id="7223" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的模块需要在<code class="fe nj nk nl nm b">__mocks__/firebase-admin.js</code>可用才能工作，你可以在任何<code class="fe nj nk nl nm b">jest.fn()</code>调用中使用<code class="fe nj nk nl nm b">mockImplementation</code>来实现你想要测试的行为。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">This mock covers all the firebase-admin functionality used in this post</figcaption></figure><h2 id="519f" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated">模拟燃烧基地</h2><p id="417c" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated"><code class="fe nj nk nl nm b">firebase/app</code>是提供创建新用户帐户、登录和注销以及获取当前用户的功能的模块。T</p><p id="c41d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">既然如此，这是一个相对轻量级的模拟。</p><p id="5377" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">下面的模块需要在<code class="fe nj nk nl nm b">__mocks__/firebase/app.js</code>可用才能工作，与上面类似，你可以使用<code class="fe nj nk nl nm b">mockImplementation</code>来实现你想要测试的行为。</p><figure class="ma mb mc md gt jr"><div class="bz fp l di"><div class="nn no l"/></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">This mock covers all the firebase/app functionality used in this post</figcaption></figure><h1 id="945d" class="lb lc iq bd ld le lf lg lh li lj lk ll lm ln lo lp lq lr ls lt lu lv lw lx ly bi translated">摘要</h1><p id="4af7" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">Firebase无疑实现了它的承诺，即易于实现授权和存储，并且使用起来很愉快，尤其是在Restify中使用中间件和Jest在测试期间的自动模仿功能与模块化方法相结合时。</p><p id="6362" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我还没有到需要担心Firebase的定价模式的地步，所以我还没有考虑到这一点，但我会向任何希望快速向项目添加授权和/或存储的开发人员推荐Firebase。</p><h2 id="e548" class="ms lc iq bd ld mt mu dn lh mv mw dp ll ko mx my lp ks mz na lt kw nb nc lx nd bi translated"><strong class="ak">简明英语团队的笔记</strong></h2><p id="cd16" class="pw-post-body-paragraph kd ke iq kf b kg ne ki kj kk nf km kn ko ng kq kr ks nh ku kv kw ni ky kz la ij bi translated">你知道我们有四种出版物吗？给他们一个关注来表达爱意:<a class="ae kc" href="https://medium.com/javascript-in-plain-english" rel="noopener"><strong class="kf ir">JavaScript in Plain English</strong></a><a class="ae kc" href="https://medium.com/ai-in-plain-english" rel="noopener"><strong class="kf ir">AI in Plain English</strong></a><a class="ae kc" href="https://medium.com/ux-in-plain-english" rel="noopener"><strong class="kf ir">UX in Plain English</strong></a><a class="ae kc" href="https://medium.com/python-in-plain-english" rel="noopener"><strong class="kf ir">Python in Plain English</strong></a><strong class="kf ir"/>——谢谢，继续学习！我们还推出了一个YouTube，希望你能通过<a class="ae kc" href="https://www.youtube.com/channel/UCtipWUghju290NWcn8jhyAw" rel="noopener ugc nofollow" target="_blank"> <strong class="kf ir">订阅我们的英语频道</strong> </a>来支持我们</p><p id="5c42" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一如既往,“简明英语”希望帮助推广好的内容。如果您有一篇文章想要提交给我们的任何出版物，请发送电子邮件至<a class="ae kc" href="mailto:submissions@plainenglish.io" rel="noopener ugc nofollow" target="_blank"><strong class="kf ir">submissions @ plain English . io</strong></a><strong class="kf ir"/>，并附上您的媒体用户名和您感兴趣的内容，我们将会回复您！</p></div></div>    
</body>
</html>