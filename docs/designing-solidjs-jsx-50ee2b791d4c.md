# 设计固体:JSX

> 原文：<https://javascript.plainenglish.io/designing-solidjs-jsx-50ee2b791d4c?source=collection_archive---------2----------------------->

## 为什么虚拟 DOM 产生的语法也是反应式 UI 库的最佳语法？

![](img/b2c9e0bfc518e3ac571fdd9813f70672.png)

Black and White Carbon Close Up by Engin Akyurt

[*SolidJS*](https://github.com/ryansolid/solid) *是一个高性能的 JavaScript UI 库。本系列文章深入探讨了设计该库的技术和决策。使用 Solid 不需要了解这些内容。今天的文章主要关注 Solid 的 JSX 模板系统。*

JSX 可能不是反应式 UI 库中模板化的最明显的选择，但它无疑带来了一些不容忽视的东西。它允许增加灵活性，更好的工具，和无与伦比的性能。我认为 JSX 是使 Solid 成为反应最快的库的重要因素。有些人声称这是不应该匹配的东西，但我挑战你，读者，读完这篇文章后，建议他们为什么不应该匹配。

# 简而言之 JSX

JSX 是由脸书开发的，目的是让 React 的命令式 API 具有声明性。Reacts 渲染方法与视频游戏引擎中的过程并无不同。它只是反复调用函数来渲染屏幕。

```
React.createElement("div", { id: "main" }, [
  "Hi ",
  React.createElement("span", {}, [state.name])
]);
```

JSX 允许开发者写下:

```
<div id="main">Hi <span>{state.name}</span></div>
```

这种将 JSX 编译成 JavaScript 的方法被标准化为 HyperScript，通常用`h`表示，其中任何库都可以提供它们的工厂函数并利用 JSX。这个简单的方法向 JSX 开放了许多库，因为你所需要的只是处理一个接受 3 个参数的函数，标签或组件，道具和子对象。您可以编写自己的 DOM 库，通过编写一个简单的函数来处理这个问题，从而利用今天的 JSX。

```
import { h } from "your-library";h("div", { id: "main" }, [
  "Hi ",
  h("span", {}, [state.name])
]);
```

# 经典反应模板

细粒度的反应式 UI 库的模板，那些基于原子状态更新而不是差分虚拟 DOM 构建的库已经成为字符串模板的领域。这始于在 HTML 之上应用的历史，以及在单页面应用流行之前的早期服务器端呈现。除了易于无缝地放置在呈现的 HTML 字符串之上，字符串模板对于这些反应式库还有一些重要的优势。

首先，它们模糊了专用的反应式数据对象和计算。仅仅引用一个变量比执行一个访问函数(可观察的)或者将整个绑定包装在一个函数中要好得多。请记住，在 Solid 这样的细粒度库中，跟踪范围就是一切。所以你的绑定表达式不能被公开执行。

其次，这些字符串通常代表 HTML。这意味着可能的值和输入的范围非常有限。您可以绑定到属性或特性，但是条件和循环需要特定的发明语法或 DSL(领域特定语言)。这将完全控制权放在解析器和库中，以处理和指定什么是合法的。

最后，您可以提前看到整个模板，并从结构上优化代码执行。这个模板没有必要的基础。不仅仅是函数调用。它可以利用这个事实在运行任何代码之前进行预测。结果是为最终用户完全抽象了库的基础。

这绝对是一种让事情变得简单的方法，因为实际上这些库正在后台建立一个依赖图，动态地处理您所有的变更传播需求。但这是有代价的。最令人震惊的是需要一个人造的瞄准镜。需要构造数据对象来承载范围并在循环中定义新的范围，而不是使用局部范围。这不仅增加了开销，而且会妨碍 ESLint 或 TypeScript 之类的工具。有些人还会指出所需的 DSL 是一个缺点，但对于细粒度的，我对此持中立态度，因为无论如何，您都需要专门的方法来有效地处理反应数据。我想指出的是，缺乏可扩展性是 DSL 的更大问题。有些库不仅允许你写自定义绑定指令，还允许你写自定义控制流指令，所以这并不完全正确。不仅仅是这样做的过程变得更加努力。

所以以我典型的方式，我拒绝接受我不能做些什么来改善这一点。解决范围/上下文问题是我的出发点。

# 固体中的 JSX

## 屏蔽反应数据

JSX 提供了一些真正有用的东西。一种预定义的 AST 语法，它是标准化的，并与现有工具兼容。所以现在的问题只是处理字符串模板中你认为理所当然的东西。

很早我就决定使用代理作为主要的状态对象。我想在有意义的地方避免访问函数。在处理多状态原子时，我看到了`state.count`比`count()`的好处。幸运的是，使用巴别塔和 JSX，我可以把表达转化为功能。所以上面的 JSX 可以编译成:

```
import { h } from "your-library";h("div", { id: "main" }, [
  "Hi ",
  h("span", {}, [**() => state.name**])
]);
```

这允许`state.name`的访问发生在它自己的范围内。这允许只对该表达式进行重新计算，而无需重新执行整个树。我考虑了一下标签模板文字，但是它们会将访问包装推给最终用户。因此，就像字符串模板一样，预处理是必经之路。

这看起来很简单，我本可以就此打住，但是这种方法虽然基本上是兼容的，却完全没有效率。想一想。当然，由于我们的细粒度反应性，我们不需要在这里重新呈现不必要的部分，但是当我们运行大块的视图代码，也许是列表中重复的行时，会发生什么呢？

## 转义 HyperScript

现在 Solid 确实支持 HyperScript 版本，如果人们希望使用它，他们可以使用带标记的模板文字或传统的 JSX 编译器，但这些方法可能永远不会是反应库的最佳选择。原因是它们是运行时方法。如果我们不做大量的区别或者构建一个虚拟 DOM 树，为什么要这么麻烦呢？

你首先应该考虑的是所有额外的函数调用和道具对象的创建。事实是，`h`工厂需要解析并确定处理每次执行的输入的最佳方式。如果我们正在编译，我们已经知道了形状。

让我们再来看看 HyperScript:

```
import { h } from "your-library";h("div", { id: "main" }, [
  "Hi ",
  h("span", {}, [() => state.name])
]);
```

唯一的动态部分是`state.name`其余的基本上是静态的 HTML。HyperScript 将 HTML 分解成多个方法，这意味着我们充其量只是在创作上做一堆`document.createElement`调用。克隆整个节点模板的性能要高得多。

您可能还会注意到内部的`h`在外部的执行之前完成了执行。那个`span`在被创建的时候不知道它的父代是谁。HyperScript 基本上是从内向外执行的。这对于运行时方法来说是完全可以接受的，这种方法对数据进行两次传递，比如渲染一棵虚拟树，然后进行差异修补。但是对于单遍库，这可能是有限制的。

我的意思是我们真正想要的是更简单的东西。从概念上讲，我们寻求:

```
const div = <div />
```

为什么`<div />`不能只是一个 HTMLDivElement？为什么要额外收费。好吧，动态绑定可能没那么简单，但也不一定更复杂。那么，如果将上一节中的 JSX 示例编译成:

```
// do once on module load
const tmpl = document.createElement("template")
tmpl.innerHTML = `<div id="main">Hi <span></span></div>`// inside your component, run as many times as you want
const div = tmpl.content.firstChild.cloneNode(true);
const span = div.firstChild.nextSibling;
createEffect(() => span.textContent = state.name);
```

设置时间确实花费了我们一个 innerHTML。然而，运行时代码生成要高效得多。`createEffect`是 Solid 版本的反应式计算，它封装了单次更新。但是除此之外，没有额外的闭包，没有解析，你基本上可以看到所有相关的代码。它不仅效率更高，而且更加透明。这是该视图呈现时运行的所有代码。除了必须调试到`createEffect`之外，你所看到的就是你所得到的。这就是 Svelte 所说的正在消失的运行时。但是仍然有一个小的运行时，但是表面的简单程度可以很容易地看出哪里有错误。

## 组件和上下文

记得刚才我提到过，HyperScript 是从内向外执行的。嗯，这对于 JSX 来说是一件真实的事情，因为它只是 JavaScript，所以我们可以在 JSX 的 JSX 插入 JSX，等等…这里是完整的盗梦空间。无论我如何编译它，它最终都会成为某种函数调用，在它结束之前执行它的子对象。尤其是当你考虑组件的时候。我已经在做的一件事是将表达式包装在函数中，这样父类至少可以选择何时评估任何动态子类。但是我想要像 React 的上下文 API 那样的依赖注入。

通常，反应式库将其上下文与其 DOM 节点联系在一起，因此对组件做同样的事情是很自然的。JSX 面临的挑战是，在附加到父节点之前创建子节点，除非进行第二次传递，否则无法沿着 DOM 树向上走。就像一个“onConnected”或“onMounted”生命周期挂钩，当反应式图在很大程度上使生命周期变得多余时，我知道我想要避免不必要的开销。我可以推迟组件的执行，直到附加到父组件，但是这会增加相当大的复杂性，并阻止我想探索的其他事情(比如悬念)。

因此，我在反应式库方面做了一些前所未有的事情。我使用反应图的层次结构来存储上下文数据。具有自动依赖性跟踪的细粒度反应式系统的工作方式是，在每个执行上下文中，当前运行的计算(反应)被提升到全局范围，在该范围下可以分配任何反应式访问。所以我需要做的就是将每个上下文反向链接到它的父上下文。通过在其上存储值，任何子上下文都可以在执行时向上查找树来找到这个值。它的工作方式与 React 的 Context API 非常相似，因为 reactive graph 是一种虚拟树，它没有实际 DOM 的基础，即使在分离时也可以访问。

这对于 JSX 来说意味着渲染首先发生在内存中，因为执行是沿着树向下的，然后在返回的路上附加到它的父节点。因此，只有当整个页面已经呈现时，它才附加到真正的 DOM(异步效果之外)。

## 控制流

这真的是最后一块了。理解了组件和上下文是如何工作的，我们就可以用它们来管理视图中的条件和循环。对于反应式库来说，无论是好是坏，您都是在处理专门的数据类型。无论你如何掩饰，它们都存在，所以像本机内置数组方法这样的东西永远不会是最佳的。反应库的字符串 DSL 也隐藏了这个事实。使用组件并不是前所未有的(见 https://github.com/leebyron/react-loops)，即使是 React 也是如此，尽管 Solid 使用这种方法要早得多。虽然它是一种 DSL，但它不是固定的。这里最大的优势是我们仍然使用真正的 JavaScript 作用域。我们可以利用 ESLint 或 TypeScript 这样的工具。

# 挑战

尽管有这么多好处，但也存在一些挑战。讽刺的是，最难的是打字稿。一个关键的好处是，这种方法是完全开箱即用的。或者至少理论上是这样。事实是，TypeScript 基本上假设如果你使用 JSX，你使用的是 React，并且在支持其他库甚至其他 HyperScript 库时速度非常慢。在这一点上，我已经提出了一些问题，并对十几个问题进行了权衡。这里有一些缺点。没有什么不可克服的，但绝对尴尬。就像没有一种简单的方法可以在不强制转换的情况下判断 TypeScript `<div />`是一个 HTMLDivElement。

对我来说不幸的是，这是我第一次在 Solid 上介绍 TypeScript，所以我不得不说，在这一点上感觉非常不成熟。但是所有的 Solid 都是用 TypeScript 编写的，并且考虑到了 TypeScript，所以我打赌如果有足够的支持，他们最终会修复这些问题。

# 结论

如果你一直跟进这一点，你可能会开始看到把所有这些东西放在一起的力量。JSX 是 JS 意味着 DSL 是任意的。定制绑定并不比仅仅使用`ref`更难，因此您可以创建定制的控制流。我指的是条件和循环之类的东西。没有多少库允许你编写自己的`if`或`each`绑定。使用这种方法，您可以随心所欲地管理控制流。我用它来写一些东西，比如入口，悬念，开关/案例，懒惰加载组件，任何需要的东西。

我最喜欢的部分可能是制作部分是多么容易。您可以非常容易地拆分组件和重构。甚至像 React 这样简单地将内容拆分到一个文件中也不是这些库的典型做法。这是不需要任何实际成本的。这导致了更好的代码清晰度和可维护性。当谈到长期项目时，sanity React 做了很多正确的事情。

我还意识到这种方法可以推广到任何反应式库。我也为 [MobX](https://github.com/ryansolid/mobx-jsx) 和 [Knockout](https://github.com/ryansolid/ko-jsx) 制作了这个核心编译器/渲染器的版本。两者的表现都令人难以置信的好，即使没有 Solid 快，它们仍然是最快的库之一，与 Inferno 等并驾齐驱，远远领先于任何更受欢迎的反应库，如 Svelte 或 Vue。(参见 [JS 框架基准](https://github.com/krausest/js-framework-benchmark))

显然，JSX 不是实现这一目标的唯一途径，但它肯定更有活力。一旦你的字符串模板解析器开始需要一个 JS 解析器，你也可以考虑给 JSX 一个机会。

[](https://github.com/ryansolid/solid) [## 瑞安固体/固体

### 一个用于构建用户界面的声明式、高效且灵活的 JavaScript 库。-瑞安固体/固体

github.com](https://github.com/ryansolid/solid) [](https://medium.com/swlh/designing-solidjs-components-8f1ebb88d78b) [## 设计 SolidJS:组件

### 组件是现代 Web UI 开发的基础。本文探讨了固体的独特方法…

medium.com](https://medium.com/swlh/designing-solidjs-components-8f1ebb88d78b) [](https://itnext.io/designing-solidjs-reactivity-75180a4c74b4) [## 设计固体:反应性

### 2019 年前端开发的热点按钮话题。这很大程度上归功于苗条而富有的哈里斯…

itnext.io](https://itnext.io/designing-solidjs-reactivity-75180a4c74b4) [](https://medium.com/@ryansolid/designing-solidjs-dualities-69ee4c08aa03) [## 设计固体:二元性

### 看对立面能否帮助我们重新定义看待整体问题空间的方式？

medium.com](https://medium.com/@ryansolid/designing-solidjs-dualities-69ee4c08aa03)