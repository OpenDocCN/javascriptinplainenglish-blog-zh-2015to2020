<html>
<head>
<title>JavaScript concepts helpful for learning React</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">有助于学习React的JavaScript概念</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-concepts-helpful-for-learning-react-63418520b86?source=collection_archive---------6-----------------------#2019-11-29">https://javascript.plainenglish.io/javascript-concepts-helpful-for-learning-react-63418520b86?source=collection_archive---------6-----------------------#2019-11-29</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><figure class="gl gn jl jm jn jo gh gi paragraph-image"><div role="button" tabindex="0" class="jp jq di jr bf js"><div class="gh gi jk"><img src="../Images/ada7c2b70f6d2c4ba67992e17312796b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*MfaU8CErG3upBQfY.jpg"/></div></div></figure><p id="5027" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">通过这篇文章，我想让你熟悉在React中广泛使用的JS概念。我已经有将近一年没有接触JavaScript了，然后就加入了React潮流。这就是为什么，我确实遇到了一些问题。因此，如果你打算学习React，这里有一些你可能希望修改的概念。随意跳过你已经熟悉的部分。</p><ul class=""><li id="dbcb" class="kt ku in jx b jy jz kc kd kg kv kk kw ko kx ks ky kz la lb bi translated"><strong class="jx io">类</strong></li><li id="1664" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">解构与展开操作者</strong></li><li id="72db" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">箭头功能</strong></li><li id="54d3" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">模板字符串</strong></li><li id="98e2" class="kt ku in jx b jy lc kc ld kg le kk lf ko lg ks ky kz la lb bi translated"><strong class="jx io">声明变量</strong></li></ul></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="feab" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">类:</strong></p><p id="bb5d" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你有OOPS的背景，你可能会熟悉这个概念。类是用户定义的数据类型，用于存储相似的特征和行为。看看这个例子:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="e9be" class="lx ly in lt b gy lz ma l mb mc">class Person {<br/>  constructor(age, name) {<br/>       this.name = name;<br/>      this.age = age;<br/>  }</span><span id="389e" class="lx ly in lt b gy md ma l mb mc">  showDetails() {<br/>    console.log(“Person Details : Age = “ + this.age + “ and name                                                      is: “ + this.name);<br/>    }<br/>}</span></pre><p id="c948" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这里，我们创建了一个“Person”类，它有两个特征，“name”和“age”，以及一个行为“showDetails”。我们现在可以使用以下内容创建一个“人”:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="5e49" class="lx ly in lt b gy lz ma l mb mc">var person = new Person(20,“John”);</span></pre><p id="3118" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们也可以继承类，这意味着使用其他类来扩展类的功能。假设我们需要创建一个“学生”类，一个学生总是有一个名字和一个年龄，所以我们可以在创建“学生”类的同时扩展“父”类。看一下语法:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="25a2" class="lx ly in lt b gy lz ma l mb mc">class Student extends Person {<br/>   constructor(id,age,name) {<br/>      super(age,name);<br/><a class="ae me" href="http://this.id" rel="noopener ugc nofollow" target="_blank">       this.id</a> = id;<br/>   }</span><span id="c0c7" class="lx ly in lt b gy md ma l mb mc">   showStudentDetails() {<br/>      console.log(“Student has Id: ”+<a class="ae me" href="http://this.id" rel="noopener ugc nofollow" target="_blank">this.id</a>);<br/>      super.showDetails();<br/>   }<br/>}</span></pre><p id="1d6f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然后我们创建一个学生，如下所示:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="800e" class="lx ly in lt b gy lz ma l mb mc">var student  = new Student(1,20,”John”);</span></pre><p id="0cca" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">一些术语:<br/> <strong class="jx io">构造函数</strong>:这是一个创建对象时调用的函数。通常这是你初始化你的对象属性的地方。<br/> <strong class="jx io">超级</strong>:用于访问上级属性。在“学生”类中使用super，其实是指向“人”类。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="7ca8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">解构与展开操作:</strong></p><p id="9774" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这些概念在React中被大量使用，也是我最纠结的地方。假设你有一个像这样的物体:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ff3f" class="lx ly in lt b gy lz ma l mb mc">var user = {<br/>  name : “Steve”,<br/>  age : 15,<br/>  email : “abc@xyz.com”<br/>}</span><span id="69a2" class="lx ly in lt b gy md ma l mb mc">And you only need limited number of properties from this object. The traditional way to do it was :</span><span id="a629" class="lx ly in lt b gy md ma l mb mc">let name = user.name;<br/>let age = user.age;</span></pre><p id="9208" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">然而，现在我们可以用更好的方法来做。呈现<strong class="jx io">解构。</strong></p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="10f1" class="lx ly in lt b gy lz ma l mb mc">let { name, age} = user;<br/>This will take out only name and age from user object and assign the corresponding values to “name” and “age” variables.</span></pre><p id="1476" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">比方说你要复制一个对象，不用手动一个一个的复制属性，我们可以使用spread运算符。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="6b0b" class="lx ly in lt b gy lz ma l mb mc">let copiedUser = …user.</span></pre><p id="8c58" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个奇怪的3点“…”叫做<strong class="jx io">传播算子</strong>。顾名思义，它是用来传播的对象。在React上下文中，它主要用于组合对象或附加到对象。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="ecfe" class="lx ly in lt b gy lz ma l mb mc">To combine multiple objects :<br/>let combinedObject = {…user,…category,…cart};</span><span id="c0d9" class="lx ly in lt b gy md ma l mb mc">This “combinedObject” will have all the properties present in “user”, “category” and “cart”.</span><span id="1c06" class="lx ly in lt b gy md ma l mb mc">To append to an object(needs to be an array) :<br/>let newArray = […previousArray, newValue];</span></pre><p id="6bc7" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这就是Spread运算符的神奇之处。</p></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="825f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">箭头函数:<br/> </strong>这些是用来快速且以更干净的方式编写函数的。对于React来说，这不是必须要学的东西，但这肯定会提高你的工作效率。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="e167" class="lx ly in lt b gy lz ma l mb mc">function getParameter() {<br/>   return param;<br/>}</span><span id="3c1b" class="lx ly in lt b gy md ma l mb mc">getParameter = () =&gt; {<br/>   return param; <br/>}</span><span id="0fe8" class="lx ly in lt b gy md ma l mb mc">Both of the above 2 functions have similar functionality.<br/>Also, with arrow functions with parameter:</span><span id="ab3a" class="lx ly in lt b gy md ma l mb mc">getParameter = (param) =&gt; {<br/> return param;<br/>}</span><span id="4512" class="lx ly in lt b gy md ma l mb mc">If there is only a return statement in arrow function, we can skip the curly braces:<br/>getParameter = (param) =&gt;  param;</span></pre><p id="3ede" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">与普通函数相比，Arrow函数最大的优点之一是在其中使用了“this”关键字。<br/> <strong class="jx io">常规函数中“this”关键字的值取决于函数是如何被调用的。arrow函数中的“this”值取决于函数的定义位置。</strong></p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="3ec7" class="lx ly in lt b gy lz ma l mb mc">const obj = {<br/> name: "john",<br/> regularFunction :function() {<br/> console.log("regularFunction : " +this.name);   <br/> //John will be printed here<br/>},</span><span id="0cad" class="lx ly in lt b gy md ma l mb mc">arrowFn : () =&gt; {<br/>     console.log("arrowFn : "+this.name);   <br/>     //name is undefined when called because here "this" represents          context where its defined and that object doesn’t have name property     defined<br/> }<br/>}</span><span id="a76e" class="lx ly in lt b gy md ma l mb mc">obj.regularFunction();<br/>obj.arrowFn();</span></pre></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="af53" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">模板字符串:</strong></p><p id="8a02" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">如果你看到我上面的代码，我是这样打印我的用户信息的:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="fdf7" class="lx ly in lt b gy lz ma l mb mc">console.log(“Person Details : Age = ”+this.age+” and name is: ”+this.name);</span></pre><p id="761c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">我们现在有了更好的方法来达到同样的效果。同样的语句可以写成</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="860b" class="lx ly in lt b gy lz ma l mb mc">console.log(`Person Details : Age = ${this.age} and name is: ${this.name}`);</span></pre><p id="d454" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">注意这里我们使用`(反斜杠)来打印。此外，${ }表示表达式，所以无论我们在${}中写什么，都将被求值。<br/>例如:</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="5d2c" class="lx ly in lt b gy lz ma l mb mc"><br/>console.log(`2 + 5 is ${2+5}`); ==&gt; 2 + 5 is 7</span></pre></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="95f8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">声明变量:</strong></p><p id="a57e" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">这个概念相对容易理解。有3种方式声明变量:<br/> <strong class="jx io"> let </strong>，<strong class="jx io"> var </strong>和<strong class="jx io"> const </strong>。</p><p id="d4e8" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> var : <br/>用var关键字声明的变量被“提升”到块的顶部，这意味着它们甚至在声明之前就可以在它们的封闭范围内被访问。</strong></p><p id="ca1c" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> let : <br/> </strong>用“let”声明的变量是块作用域，即只能在声明它的块中访问。</p><p id="9267" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io"> const : <br/> </strong>用于标记一个变量常量，即以后不能更改。然而，正确的做法是，引用是不变的，不能改变。我们仍然可以改变变量的内部属性。</p><pre class="lo lp lq lr gt ls lt lu lv aw lw bi"><span id="dfc6" class="lx ly in lt b gy lz ma l mb mc">{</span><span id="013d" class="lx ly in lt b gy md ma l mb mc"> var a = 5;<br/> let b = 6; <br/> const c = 7; <br/> b = 8; <br/> // c = 9         --&gt; Not possible because c is constant reference</span><span id="62f3" class="lx ly in lt b gy md ma l mb mc">}</span><span id="9324" class="lx ly in lt b gy md ma l mb mc">console.log(a);<br/>//console.log(b);   --&gt;  Not able to access "let" outside block<br/>//console.log(c);   --&gt;  Not able to access "const" outside block</span></pre></div><div class="ab cl lh li hr lj" role="separator"><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm ln"/><span class="lk bw bk ll lm"/></div><div class="ig ih ii ij ik"><p id="6bfc" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated"><strong class="jx io">结论:</strong></p><p id="f28f" class="pw-post-body-paragraph jv jw in jx b jy jz ka kb kc kd ke kf kg kh ki kj kk kl km kn ko kp kq kr ks ig bi translated">在React中，你会经常用到这些概念。像创建组件、析构和扩展操作符的类，同时处理反应状态等等。当然，这篇文章会帮助你快速反应。<br/>快乐编码..</p></div></div>    
</body>
</html>