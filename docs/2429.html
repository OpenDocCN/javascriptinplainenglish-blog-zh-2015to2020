<html>
<head>
<title>How to create private fields and functions in a JavaScript class</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何在JavaScript类中创建私有字段和函数</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/private-members-in-javascript-classes-cb04944f1ae2?source=collection_archive---------0-----------------------#2020-06-23">https://javascript.plainenglish.io/private-members-in-javascript-classes-cb04944f1ae2?source=collection_archive---------0-----------------------#2020-06-23</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="6a7d" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中的私有成员</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/4bacf5e6ec8527c3298fc2387fd01cf9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*OGko5nPenCKA04bRwzoedw@2x.jpeg"/></div></div></figure><p id="5eec" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">本文首先介绍JavaScript中的第三阶段特性，该特性用于创建私有字段、getter、setter和函数。它与TypeScript中的类似功能进行了比较。随后，它列出了浏览器兼容性。最后，描述了TC39流程，并对0-4阶段进行了说明。</p><p id="a6ca" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">像Java、C#这样的传统语言使用访问修饰符来控制对字段或方法的访问。可以在类外部的类实例上访问公共字段；仅在类中的私有字段。</p><p id="f9a6" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ES6 / ES2015在JavaScript中引入了类。它是数据(字段)和行为(函数)的封装。对于目前处于阶段3的新提议，类可以有私有成员，这些成员在类的范围之外是不可访问的。</p><h1 id="36f2" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">私有类字段</h1><p id="5e06" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">我们可以在JavaScript中创建私有字段、getters &amp; setters和函数，方法是在前面加上#。它们在课堂之外是不可访问的。</p><p id="81db" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">考虑下面的例子。我们创建了一个恐龙类。构造函数接受三个输入参数，名称、时间范围和地区。</p><p id="c40c" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">该类使用这些信息创建友好的消息。当您阅读本文时，我们将构建这个示例。首先，我们创建一个类和几个字段。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="b4b5" class="mq lp iq mm b gy mr ms l mt mu">1. class Dinosaur{<br/>2.    #name = ''; // Private fields need to be declared<br/>3.    #milYears = 0;<br/>    <br/>4.    constructor(name, milYears, region) {<br/>5.        this.#name = name;<br/>6.        this.region = region;<br/>7.        this.#milYears = milYears;<br/>8.    }<br/>9. }</span><span id="7f05" class="mq lp iq mm b gy mv ms l mt mu"><em class="ln">Snippet-1: A class with private fields</em></span></pre><p id="0c44" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">请注意，构造函数在类级别的字段上设置值。私有字段用# names(散列名)声明。它们需要显式声明，如上面代码片段中的第2行和第3行所示。但是，注意<em class="ln">地区</em>不是私有字段。它没有哈希名。因此它可以在没有声明的情况下被实例化(第6行)。</p><p id="a16d" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">私有字段不能在类外访问。考虑下面的代码片段-2。第2行记录区域打印正确。但是，第3行和第4行返回一个错误，因为这些字段是私有的</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="dffd" class="mq lp iq mm b gy mr ms l mt mu">1. let dino = new Dinosaur('Euhelopus', 100.5, 'Asia');<br/><br/>2. console.log(dino.region); // public- accessible outside the class<br/>3. console.log(dino.#milYears); //private- not accessible outside the class<br/>4. console.log(dino.#name); // private- not accessible outside class</span><span id="e746" class="mq lp iq mm b gy mv ms l mt mu"><em class="ln">Snippet-2: Instantiate a JavaScript class</em></span></pre><h2 id="5f1c" class="mq lp iq bd lq mw mx dn lu my mz dp ly la na nb ma le nc nd mc li ne nf me ng bi translated">TypeScript中的私有字段</h2><p id="5681" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">用TypeScript编码的开发人员习惯私有字段。然而，浏览器不解释TypeScript。代码被编译成JavaScript以在浏览器上运行。没有JavaScript中的私有字段，我们总是可以访问snippet-3中指定的私有字段。参见第7行。JavaScript中的私有字段提供了更好的抽象，因为该语言本身就支持它。</p><blockquote class="nh ni nj"><p id="b7df" class="kr ks ln kt b ku kv jr kw kx ky ju kz nk lb lc ld nl lf lg lh nm lj lk ll lm ij bi translated">TypeScript允许通过指定访问修饰符在构造函数中创建字段，如第2行所示。这非常有用——代码片段1中的6行代码现在被写成了一行。</p></blockquote><p id="485e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">注意，我们运行tsc (TypeScript编译器)将代码编译成JavaScript。使用Node.js运行js文件。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nn"><img src="../Images/81c21512c17847f5cb270f1b3513b186.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*6ffQnybPIyoyhZ-c0XkdEA.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Snippet-3: Private fields in TypeScript</figcaption></figure><h1 id="06a1" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">私有Getters和Setters</h1><p id="bde4" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">与字段类似，我们可以创建私有的getters和setters。考虑下面的代码片段-4。参见第10–15行，我们为字段milYears创建了一个getter和setter。我们称之为#时间框架。构造函数使用第8行的私有字段来设置一个值。在后面的例子中，我们将使用时间框架获取恐龙时间框架上的友好消息。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="43f5" class="mq lp iq mm b gy mr ms l mt mu">1. class Dinosaur{<br/>2.    #name = '';<br/>3.    #milYears = 0;<br/>4.    <br/>5.    constructor(name, timeframe, region) {<br/>6.        this.#name = name;<br/>7.        this.region = region;<br/>8.        this.#timeframe = timeframe;<br/>9.    }</span><span id="7abf" class="mq lp iq mm b gy mv ms l mt mu">10. get #timeframe(){<br/>11.        return `lived ${this.#milYears} million years ago`<br/>12.    }</span><span id="2f9f" class="mq lp iq mm b gy mv ms l mt mu">13. set #timeframe(value){<br/>14.        this.#milYears = value;<br/>15.    }<br/>16. }</span><span id="3154" class="mq lp iq mm b gy mv ms l mt mu">Snippet-4: Private getters and setters</span></pre><h1 id="0a35" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">私人功能</h1><p id="e0ca" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">现在让我们向示例中添加一个私有函数——以hash (#)作为前缀。注意，我们使用getter " <em class="ln"> this。第4行中的#timeframe" </em>。私有函数#generateTitle返回一条关于恐龙的友好消息。不能在类外部访问此函数。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="b6a8" class="mq lp iq mm b gy mr ms l mt mu">1. class Dinosaur {</span><span id="e677" class="mq lp iq mm b gy mv ms l mt mu">2. // Removed rest of the class for brevity. Same class as in Snippet-4</span><span id="550d" class="mq lp iq mm b gy mv ms l mt mu">3. #generateTitle() {<br/>4.   return `A dinosaur ${this.#name} ${this.#timeframe} in  ${this.region}.  `;<br/>5.  }</span><span id="ff4c" class="mq lp iq mm b gy mv ms l mt mu">6. }</span><span id="63d6" class="mq lp iq mm b gy mv ms l mt mu">Snippet-5: Private function</span></pre><p id="5c2f" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">类中的私有项提供控制，哪些向消费者公开，哪些在内部使用。考虑下面的完整示例。我们添加了一个公共函数printTitle()，它在控制台上记录友好的消息。请参见第18–20行。参见第23行中在恐龙对象的类外调用的公共函数。</p><pre class="kg kh ki kj gt ml mm mn mo aw mp bi"><span id="502f" class="mq lp iq mm b gy mr ms l mt mu">1. class Dinosaur{<br/>2.    #name = '';<br/>3.    #milYears = 0;<br/>    <br/>4.    constructor(name, timeframe, region) {<br/>5.        this.#name = name;<br/>6.        this.region = region;<br/>7.        this.#timeframe = timeframe;<br/>8.    }</span><span id="a48d" class="mq lp iq mm b gy mv ms l mt mu">9. get #timeframe(){<br/>10.        return `lived ${this.#milYears} million years ago`<br/>11.    }</span><span id="e5f0" class="mq lp iq mm b gy mv ms l mt mu">12. set #timeframe(value){<br/>13.        this.#milYears = value;<br/>14.    }</span><span id="46b9" class="mq lp iq mm b gy mv ms l mt mu">15. #generateTitle() {<br/>16.        return `A dinosaur ${this.#name} ${this.#timeframe} in ${this.region}.  `;<br/>17.    }</span><span id="8463" class="mq lp iq mm b gy mv ms l mt mu">18. printTitle() {<br/>19.       console.log(this.#generateTitle());<br/>20.    }<br/>21. }</span><span id="2752" class="mq lp iq mm b gy mv ms l mt mu">22. let dino = new Dinosaur('Euhelopus', 100.5, 'Asia');<br/>23. dino.printTitle();</span></pre><p id="7c04" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">看到下面的结果，</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi ns"><img src="../Images/ca10a7b485154ef40e30dd6ee746729c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*8SJBE4mBlhTrHctSv-g19w.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure-1: Dinosaur with private and public fields, getters/setters and functions</figcaption></figure><p id="df0e" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">任何在类外部访问的私有项都会返回错误。请参见下面的图2。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nt"><img src="../Images/e2704631f6fe3e469b3b23e612fd59ff.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*QnRbktw-AVMNf9BC2fndUg.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure-2: Error on accessing the Private Field (Chormium Browser)</figcaption></figure><blockquote class="nh ni nj"><p id="c7ce" class="kr ks ln kt b ku kv jr kw kx ky ju kz nk lb lc ld nl lf lg lh nm lj lk ll lm ij bi translated">请注意，散列名称不能在对象文字(JSON对象)上创建，也不能通过在prototype上添加字段或函数来创建。它们不能像其他字段一样临时创建。它们需要在类中提前声明。</p></blockquote><h1 id="eec0" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">浏览器支持</h1><p id="2b60" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">如前所述，这些特征处于TC-39工艺的第三阶段。指的是候选人，也就是<strong class="kt ir">快</strong>完了。它允许用户/开发者试验该特性并提供反馈。(参见下一节了解TC-39过程)。</p><p id="457a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">Google Chrome支持83.x以上版本的私有字段。私有的getter/setter和函数是一个独立的TC39提案，从版本84(撰写本文时是beta版)开始就受到支持。在83.x版本中，这些特性可以通过在<em class="ln"> chrome://flags/中启用实验性JavaScript来实现。</em></p><p id="3be8" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">有关其他浏览器支持信息，请参见下面的图3。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi nu"><img src="../Images/f4af4f02a975bd959267bf35047b984b.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*2k8sypL8IIwoS2p8UZPCng.png"/></div></div><figcaption class="no np gj gh gi nq nr bd b be z dk">Figure-3: Browser support. Link — <a class="ae nv" href="https://kangax.github.io/compat-table/esnext/" rel="noopener ugc nofollow" target="_blank">https://kangax.github.io/compat-table/esnext/</a></figcaption></figure><h1 id="4034" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">TC-39关于私有字段、getter/setter和函数的建议</h1><p id="f173" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">请在下面找到这两个提案的链接。</p><ul class=""><li id="f188" class="nw nx iq kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated"><a class="ae nv" href="https://github.com/tc39/proposal-class-fields" rel="noopener ugc nofollow" target="_blank">建议-类别-字段</a></li><li id="9ade" class="nw nx iq kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated"><a class="ae nv" href="https://github.com/tc39/proposal-private-methods" rel="noopener ugc nofollow" target="_blank">提案-私有-方法</a></li></ul><h1 id="1df8" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">TC39流程——新特性是如何添加到JavaScript中的？</h1><p id="5088" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated">对于许多其他语言，随着新特性的增加，只需要升级一个运行时或一个编译器。JavaScript是独一无二的；功能需要通过各种浏览器来实现。它们由不同组织拥有的不同团队构建和维护。每个人都必须走到一起，不断升级语言。</p><p id="9cb0" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ECMA脚本(简称ES)是为标准化JavaScript而创建的语言规范。ES5是2009年发布的流行JavaScript版本。ES 6于2015年发布。也被称为ES 2015。从ES 6开始，每年都会进行一次升级。如前所述，本文描述的动态导入特性是ES 2020或ES 11的一部分。</p><p id="ec03" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">ECMA TC39是一个委员会，负责演变ECMA脚本。TC 39使用以下阶段定义将JavaScript特性移动到ECMA脚本版本之一。每一个新的JavaScript提案都要经历在所有浏览器上可用的阶段。</p><ul class=""><li id="db09" class="nw nx iq kt b ku kv kx ky la ny le nz li oa lm ob oc od oe bi translated">阶段0— Strawperson或新规范(以前称为strawman，现在重新命名—正确的名称是:)</li><li id="2320" class="nw nx iq kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">第1阶段—提案。使用正式的规范语言演示对添加、解决方案和挑战的需求。</li><li id="c939" class="nw nx iq kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">第2阶段—草拟。描述语法和语义。</li><li id="2dcc" class="nw nx iq kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">第3阶段—候选人。允许用户进行实验并提供反馈。可以根据反馈重新定义规范。大多数浏览器都在这个阶段开始调整特性。功能可能尚未为黄金时段做好准备。</li><li id="463f" class="nw nx iq kt b ku of kx og la oh le oi li oj lm ob oc od oe bi translated">阶段4 —已完成。功能已准备就绪，可供所有用户使用。</li></ul><p id="958a" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">按照<a class="ae nv" href="https://tc39.es/process-document/" rel="noopener ugc nofollow" target="_blank">链接获取TC 39工艺文件</a></p><h1 id="3e4a" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">参考资料及进一步阅读</h1><ol class=""><li id="6c9c" class="nw nx iq kt b ku mg kx mh la ok le ol li om lm on oc od oe bi translated"><a class="ae nv" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields" rel="noopener ugc nofollow" target="_blank"> Mozilla文档</a></li></ol><p id="12a4" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated">2.P <a class="ae nv" href="https://github.com/tc39/proposal-class-fields" rel="noopener ugc nofollow" target="_blank"> roposal级油田</a></p><p id="c087" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae nv" href="https://github.com/tc39/proposal-private-methods" rel="noopener ugc nofollow" target="_blank"> 3 .建议-私有-方法</a></p><p id="a358" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae nv" href="https://kangax.github.io/compat-table/esnext/" rel="noopener ugc nofollow" target="_blank"> 4 .ECMA脚本兼容性表</a></p><p id="ca65" class="pw-post-body-paragraph kr ks iq kt b ku kv jr kw kx ky ju kz la lb lc ld le lf lg lh li lj lk ll lm ij bi translated"><a class="ae nv" href="https://medium.com/javascript-in-plain-english/discuss-native-support-for-on-the-fly-import-of-modules-in-es-2020-also-called-es-11-ad4f899e0c2" rel="noopener"> 5 .我的一篇关于动态导入的JavaScript文章，附带一个关于TC-39进程</a>的解释</p><h1 id="a5a5" class="lo lp iq bd lq lr ls lt lu lv lw lx ly jw lz jx ma jz mb ka mc kc md kd me mf bi translated">关于我</h1><p id="965f" class="pw-post-body-paragraph kr ks iq kt b ku mg jr kw kx mh ju kz la mi lc ld le mj lg lh li mk lk ll lm ij bi translated"><em class="ln">Twitter-</em><a class="ae nv" href="http://twitter.com/keertikotaru" rel="noopener ugc nofollow" target="_blank"><em class="ln">@ keertkotaru</em></a><em class="ln">。</em><a class="ae nv" href="http://kvkirthy.github.io/showcase" rel="noopener ugc nofollow" target="_blank">web-<em class="ln">http://kvkirthy.github.io/showcase</em></a><em class="ln"><br/>书籍，</em><a class="ae nv" href="https://www.amazon.com/Angular-Material-Design-TypeScript-Interface/dp/1484254333/ref=sr_1_4?crid=IPQSCYP20TBM&amp;keywords=angular+material&amp;qid=1578619358&amp;sprefix=angular+mater%2Caps%2C139&amp;sr=8-4" rel="noopener ugc nofollow" target="_blank">T28】角材书</a><em class="ln"/><a class="ae nv" href="https://www.amazon.com/Material-Design-Implementation-AngularJS-Component/dp/1484221893/ref=sr_1_10?crid=IPQSCYP20TBM&amp;keywords=angular+material&amp;qid=1578619358&amp;sprefix=angular+mater%2Caps%2C139&amp;sr=8-10" rel="noopener ugc nofollow" target="_blank"><em class="ln">角材v1.x </em> </a></p></div></div>    
</body>
</html>