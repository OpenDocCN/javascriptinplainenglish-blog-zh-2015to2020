<html>
<head>
<title>How I share React components between projects</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">我如何在项目之间共享React组件</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-i-share-react-components-between-projects-3896d853cbee?source=collection_archive---------0-----------------------#2020-01-23">https://javascript.plainenglish.io/how-i-share-react-components-between-projects-3896d853cbee?source=collection_archive---------0-----------------------#2020-01-23</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="a867" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">通过与Bit共享组件来缩短开发时间！</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9467290cf80c329bffad0f7209c6584c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1aqUERetKCrc-_kF.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Bit.dev</figcaption></figure><h1 id="b1a6" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">作为一名开发人员，我总是在开发新的应用程序。因此，我经常发现自己在重复很多任务。</h1><p id="0b7f" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">比如一遍又一遍地创建相同类型的组件——按钮、表单、导航条等。我最近遇到了一个名为<a class="ae mg" href="https://bit.dev/" rel="noopener ugc nofollow" target="_blank"> Bit </a>的平台，它为开发者提供了一种在项目之间共享组件的简单有效的方式<a class="ae mg" href="https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l3bhezsg" rel="noopener ugc nofollow" target="_blank">。使用Bit为我提供了一种简单的方法来提高速度，因为它帮助我避免了一遍又一遍地重新创建那些相同的组件。</a></p><h2 id="4dee" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated">在使用Bit的过程中，我还拥有了一个组件库，可以通过它们的GUI浏览。</h2><p id="3630" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">使用GUI——它不是Bit的一个独立软件，而只是登录到Bit网站并查看组件库——我获得了能够单独查看每个组件的额外能力，并且可以使用不同的值、状态等查看它的外观。</p><p id="181e" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">这种创建和存储组件的可视化方法有助于将开发和设计这两个世界结合在一起，这种体验是在GitHub等设备上存储代码时所没有的。</p><p id="b278" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">从任何应用程序或项目共享组件变成了一个简单的过程，使用Bit添加、标记和导出组件到您的可重用集合。然后，使用npm/yarn向您的项目添加组件变得很容易，就像您添加任何其他包一样。</p><h2 id="3345" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated">我想演示一下使用Bit有多简单。</h2><p id="fed4" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">因此，让我们花几分钟时间，将我们之前创建的一些简单组件导出到Bit，然后在我们的应用程序中重用它们。</p><p id="45ed" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">我很快从一个演示版的React To-Do应用程序变成了这样:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi my"><img src="../Images/257e019b15d86a9c090cbac7883a2870.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*z52GkQhB60YMtUPC4X2Xxw.png"/></div></div></figure><p id="646b" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">到拥有一组独立的可重用组件供我使用:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi mz"><img src="../Images/ba88d429446890494fcce3d8d3b8f7c9.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*NabVFo2hSkq0bgQG.gif"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Reviewing a collection of components in Bit</figcaption></figure><h1 id="2bb7" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">好了，说够了。我们开始吧！</h1><h2 id="09ab" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated"><strong class="ak"> 1。收集您的组件</strong></h2><p id="13a4" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">如果你以前用React创建过一个应用，那很好。你将得到那个应用程序，并用它来构建你自己的组件库。您现在可以进入第2步了！</p><p id="e877" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">注意:如果你没有任何应用程序，或者之前从未使用React创建过应用程序，那么最好是先创建一些简单的应用程序，比如to do应用程序，然后在你对React感到满意时再回来。</p><h2 id="f4e4" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated"><strong class="ak"> 2。现在，安装Bit: </strong></h2><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="33ef" class="mh kt in nb b gy nf ng l nh ni">$ yarn global add bit-bin<br/># or<br/>$ npm install bit-bin --global</span></pre><h2 id="ca45" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated"><strong class="ak"> 3。创建一个免费的Bit账户</strong></h2><p id="19d3" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">您可以通过访问:<strong class="lm io"/><a class="ae mg" href="https://bit.dev/signup" rel="noopener ugc nofollow" target="_blank"><strong class="lm io">https://bit.dev/signup</strong></a></p><h2 id="2853" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated"><strong class="ak"> 4。回到终端并登录您的Bit账户</strong></h2><p id="bad2" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">您可以通过运行以下命令来实现这一点:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="4ee3" class="mh kt in nb b gy nf ng l nh ni">$ bit login</span></pre><p id="0b25" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">Bit会在终端中问你几个关于错误报告的问题，你可以回答<em class="nj">是</em>或<em class="nj">否</em>。然后你的浏览器应该打开Bit网站，并显示一个成功页面，如果一切按预期进行的话——对我来说就是这样，这是一次奇妙的开发体验。</p><h2 id="1c95" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated"><strong class="ak"> 5。开始分享吧！</strong></h2><p id="f1f7" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">要在Bit上共享组件，我们需要做3件事:<strong class="lm io">添加</strong>(打包)<strong class="lm io">标签</strong>(版本)<strong class="lm io">导出</strong>(发布)。Bit自动完成了大部分工作，所以这实际上是一个非常简单的过程。</p><p id="a8c4" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">在你的应用程序的根文件夹中运行<code class="fe nk nl nm nb b">bit init</code>来初始化一个Bit工作空间。默认情况下，这会将您的工作区设置为使用npm。如果你喜欢使用纱线，运行这个<code class="fe nk nl nm nb b">bit init --package-manager yarn</code>。或者直接更新<code class="fe nk nl nm nb b">"packageManager"</code>值来使用<code class="fe nk nl nm nb b">yarn</code>。</p><p id="458e" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">这为您的<strong class="lm io"> package.json </strong>添加了一些代码，如下所示:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="35d0" class="mh kt in nb b gy nf ng l nh ni">“bit”: {<br/>  “env”: {},<br/>  “componentsDefaultDirectory”: “components/{name}”,<br/>  “packageManager”: “yarn”<br/>}</span></pre><p id="218e" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">现在我们的工作空间已经初始化，让我们继续添加一些组件。</p><h2 id="8536" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated">添加组件</h2><p id="9404" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">接下来，让我们告诉Bit开始跟踪<code class="fe nk nl nm nb b">src/components</code>目录中的所有组件。它会自动打包每个组件的所有文件和依赖项。我们可以通过运行以下命令来实现这一点:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="fe47" class="mh kt in nb b gy nf ng l nh ni">$ bit add src/components/*</span></pre><p id="d4e1" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">您现在可以运行<code class="fe nk nl nm nb b">bit status</code>来查看是否所有的东西都添加好了。如果是，您会在终端/命令行中看到每个添加的组件旁边的<code class="fe nk nl nm nb b">ok</code>。</p><blockquote class="nn no np"><p id="42f2" class="lk ll nj lm b ln mt jo lp lq mu jr ls nq mv lv lw nr mw lz ma ns mx md me mf ig bi translated">如果您在自己的应用程序中执行此操作时遇到任何问题，<a class="ae mg" href="https://docs.bit.dev/docs/isolating-and-tracking-components.html#tracking-a-component-with-file-dependencies" rel="noopener ugc nofollow" target="_blank">请点击此处了解如何解决这些问题</a>。</p></blockquote><p id="39ea" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">为了确保我们的代码可重用，我们需要定义一个编译器。为了节省开销，Bit提供了预定义配置的可重用开发环境(env)。</p><p id="dd72" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">将Bit.dev 中的<a class="ae mg" href="https://bit.dev/bit/envs" rel="noopener ugc nofollow" target="_blank"> <em class="nj"> React编译器</em>导入到你的应用工作区。Bit将它定义为工作空间中每个组件的构建配置。</a></p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="ca37" class="mh kt in nb b gy nf ng l nh ni">$ bit import bit.envs/compilers/react --compiler</span></pre><p id="9939" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">上面的步骤在我的电脑上执行了大约一分钟，所以如果你发现自己有点等待，不要担心。如果一切顺利，您应该在终端中看到以下内容:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="dca8" class="mh kt in nb b gy nf ng l nh ni">the following component environments were installed<br/>- bit.envs/compilers/react@1.0.11</span></pre><p id="b1ed" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">您还会注意到我们的<strong class="lm io"> package.json </strong>中的<code class="fe nk nl nm nb b">"bit"</code>对象现在已经更新为:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="c875" class="mh kt in nb b gy nf ng l nh ni">“bit”: {<br/>  "env": {<br/>    "compiler": "bit.envs/compilers/react@1.0.11"<br/>  },<br/>  “componentsDefaultDirectory”: “components/{name}”,<br/>  “packageManager”: “yarn”<br/>}</span></pre><p id="cde1" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated"><strong class="lm io"> <em class="nj">可选</em> </strong> <em class="nj"> : </em>运行<code class="fe nk nl nm nb b">$ bit build</code>查看所有组件是否构建成功。</p><p id="2cdf" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">既然已经添加了组件，我们现在可以看看如何标记它们了。</p><h2 id="37cc" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated">标记组件</h2><p id="7810" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">Bit使用语义标签来帮助识别组件的不同版本，类似于一个软件如何使用标签来表明它是什么版本。</p><p id="3564" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">为了标记一个组件，我们使用<code class="fe nk nl nm nb b">bit tag</code>,后跟你想要标记的组件的文件路径，以及我们想要给组件的版本号。或者，我们可以通过添加<code class="fe nk nl nm nb b">--all</code>标志来一次性标记所有组件，如下所示:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="c3ee" class="mh kt in nb b gy nf ng l nh ni">$ bit tag --all 1.0.0</span></pre><p id="04b4" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">如果一切顺利，您应该可以在终端/命令行中看到标记的组件数量。</p><p id="acd3" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">值得注意的是，指定版本号并不是强制性的。如果您愿意，您实际上可以将它留给Bit来处理，在这种情况下，补丁号将在每个新标签上自动增加。</p><p id="617d" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">最后，我们现在可以将组件导出到我们的Bit.dev集合中。</p><h2 id="19a1" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated">导出组件</h2><p id="9c85" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">首先，进入to <a class="ae mg" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank"> bit.dev </a>，如果你已经登录，点击右上角的+New按钮，然后点击“收藏”。</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nt"><img src="../Images/8783bd644c537443ff982c8af56567d3.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bIPOcAOrttqMGbaC-yNwZg.png"/></div></div></figure><p id="e0da" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">然后为您的收藏命名:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nu"><img src="../Images/0da90818ba9cb4d40f225e5707a8223c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*tLkXCmNSlBLZNY3-jUenDg.png"/></div></div></figure><p id="24f0" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">所以在我的例子中，我把我的集合叫做“反应组件”。然后点击页面底部的“创建”按钮。您现在将看到一个类似如下的页面:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nv"><img src="../Images/84e30395699ba76d2a22049e058becdb.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*vZqhwn4SX3_ig_1zBUt0_w.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae mg" href="https://bit.dev/sunil-sandhu/react-components" rel="noopener ugc nofollow" target="_blank">https://bit.dev/sunil-sandhu/react-components</a></figcaption></figure><p id="7b0d" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">在上面图像的右边，您可以看到它显示了一个命令，每当您想要将组件导出到这个集合时就运行这个命令。让我们继续这样做，运行:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="06ed" class="mh kt in nb b gy nf ng l nh ni">$ bit export user-name.collection-name</span></pre><p id="3992" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">在我的例子中，我将运行下面的:<code class="fe nk nl nm nb b">$ bit export sunil-sandhu.react-components</code>。</p><p id="1b5e" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">完成后，您应该会在终端/命令行中看到一条注释，表明它是成功的。如果我在Bit上重新访问我的组件库，我可以看到我导出的六个组件！</p><p id="15b9" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">现在你的每一个组件都可以在一个隔离的环境中查看，在这里你可以进行修改，添加/删除道具，等等！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nw"><img src="../Images/ec42a0f99482ad245f11abe246508e90.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*P2Dh_9-ExOOQ9-Sq.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">What the component playground looks like for my List component</figcaption></figure><p id="3da9" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">如您所见，我已经确保组件获得了所有需要的道具。此外，我还添加了一个包含right <code class="fe nk nl nm nb b">@import</code>的CSS文件，以便组件能够使用我希望它使用的字体系列。</p><h1 id="3a26" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">就这样，我现在有了自己的可重用组件库！</h1><p id="8aca" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">好的，那么我如何在其他应用程序中使用它们呢？让我们接下来讨论这个问题吧！</p><h2 id="b6f1" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated">在新应用程序中安装组件。</h2><p id="8064" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">使用<code class="fe nk nl nm nb b">create-react-app</code>创建一个新的React应用程序，并将其命名为‘new-app’。</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="13bf" class="mh kt in nb b gy nf ng l nh ni">$ npx create-react-app new-app</span></pre><p id="0bbe" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">现在，您可以从新创建的Bit库获取组件了！</p><p id="6024" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">所以在我的例子中，假设我的项目需要一个<code class="fe nk nl nm nb b">removable-list-item</code>组件。有趣的是，我之前已经创建了一个并导出到Bit！因此，我可以像安装任何其他软件包一样安装它。我可以通过运行以下命令来实现:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="8ed7" class="mh kt in nb b gy nf ng l nh ni">yarn @bit/sunil-sandhu.react-components.removable-list-item</span></pre><p id="21db" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated"><strong class="lm io">当然，您可以用替换username . component-library . component-name</strong>—<em class="nj">，在我的例子中是:sunil-sand Hu . react-components . removable-list-item—</em><strong class="lm io"><em class="nj">，而不管您的username . component-library . component-name是什么。</em></strong></p><h2 id="be24" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated">但是，如果我不想将组件作为包添加，而只想让代码出现在我的应用程序中，该怎么办呢？</h2><p id="2a50" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">没问题，Bit允许你分叉你的组件代码，允许你在本地编辑。</p><p id="6f6d" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">为此，在应用程序的根目录中初始化一个Bit工作空间:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="65b7" class="mh kt in nb b gy nf ng l nh ni"># cd new-app</span><span id="95cc" class="mh kt in nb b gy nx ng l nh ni">$ bit init</span></pre><p id="e119" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">现在，如果我想使用之前的<code class="fe nk nl nm nb b">removable-list-item</code>组件，但只是想要代码而不是包，我可以运行下面的命令:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="4a62" class="mh kt in nb b gy nf ng l nh ni">$ bit import sunil-sandhu.react-components/removable-list-item</span></pre><p id="1dd8" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated"><strong class="lm io">同样，您可以用您的名称替换用户名.组件库/组件名。</strong></p><p id="9452" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">这将导入组件并放在一个新创建的名为<code class="fe nk nl nm nb b">components</code>的文件夹中。</p><p id="e69b" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated"><strong class="lm io"> <em class="nj">注意</em> </strong> <em class="nj">:这个</em> <code class="fe nk nl nm nb b"><em class="nj">components</em></code> <em class="nj">文件夹出现在你app的根目录下，所以和</em> <code class="fe nk nl nm nb b"><em class="nj">src/components</em></code> <em class="nj">目录不同。</em></p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="597d" class="mh kt in nb b gy nf ng l nh ni">├───.git<br/>├───components<br/>│   ├───removable-list-item</span></pre><p id="7185" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">您可以访问组件的源代码，并根据需要进行任何更改。</p><p id="e26c" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">现在，假设您已经在本地进行了一些更改，并且现在决定希望这些更改作为组件的新版本出现在您的Bit组件库中。原来你也可以这样！</p><p id="bf58" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">如果运行<code class="fe nk nl nm nb b">bit status</code>，Bit会识别出组件已经被修改。您可以使用<code class="fe nk nl nm nb b">bit list</code>列出所有组件。在我们的例子中，我们只有一个被跟踪的组件:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ny"><img src="../Images/6f0032687a0b656d81b6261a0fc5c87f.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*BT6qJxtX6CJ97ihJ-46iAQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Single tracked bit component</figcaption></figure><p id="82af" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">使用组件的ID为其标记新版本:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="3bd3" class="mh kt in nb b gy nf ng l nh ni">$ bit tag user-name.collection-name/component-name</span></pre><p id="e2c7" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">就我而言，<code class="fe nk nl nm nb b">$ bit tag sunil-sandhu.react-components/removable-list-item</code>。</p><p id="3f2a" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">现在将新版本导出到Bit.dev。</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="e058" class="mh kt in nb b gy nf ng l nh ni">$ bit export user-name.collection-name</span></pre><p id="5f02" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">就这样，您刚刚从新项目中编辑了组件，并将新的可重用版本导出到您的Bit集合中。</p><h2 id="dee4" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated">但是，如果我希望我创建的原始应用程序使用这个组件的新版本，该怎么办呢？</h2><p id="f5c5" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">事实证明，Bit也创造了一种方法来做到这一点！仅供参考，这类似于用Git合并变更。最后，让我们快速回顾一下如何做这件事。</p><p id="c2f1" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">回到你的待办事项应用程序:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="a705" class="mh kt in nb b gy nf ng l nh ni">$ cd react-demo-app</span></pre><p id="1eeb" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">现在运行以下命令来检查应用程序中的过期版本:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="25fa" class="mh kt in nb b gy nf ng l nh ni">$ bit list --outdated</span></pre><p id="3779" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">这将列出您的应用程序中的所有组件，我可以看到<code class="fe nk nl nm nb b">removable-list-item</code>的本地版本以红色列出。</p><p id="3be8" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">您应该会在控制台中看到类似下表的内容:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi nz"><img src="../Images/26588677edaa5d2abaa86c046148a133.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*xJRZ9b2lBoacBrE-3VV_CQ.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><code class="fe nk nl nm nb b">bit list --outdated</code></figcaption></figure><p id="66f5" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">您现在可以获取组件的最新版本:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="b610" class="mh kt in nb b gy nf ng l nh ni">$ bit import</span></pre><p id="8e6a" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">现在组件已经下载了，但是您的本地组件还没有改变。我们可以通过运行以下命令来验证这一点:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="32dc" class="mh kt in nb b gy nf ng l nh ni">$ bit status</span></pre><p id="315f" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">您应该会收到此消息，说明有挂起的更新，特别是您的更新组件。</p><p id="e21a" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">我们通过运行<code class="fe nk nl nm nb b">bit checkout</code>来合并新导入版本和您的本地版本之间的变更，从而解决这个问题。在我们的例子中，我们运行以下内容:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="b170" class="mh kt in nb b gy nf ng l nh ni">$ bit checkout 1.0.1 removable-list-item</span></pre><p id="7f28" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated"><strong class="lm io">你可以用你的组件的任何名称替换</strong> <code class="fe nk nl nm nb b"><strong class="lm io">removable-list-item</strong></code> <strong class="lm io">。</strong></p><p id="747c" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">如果您遇到任何合并冲突，Bit会在终端中告诉您。它还会为您的结账提供可选标志，其中之一是添加<code class="fe nk nl nm nb b">--manual</code>标志，如下所示:</p><pre class="kd ke kf kg gt na nb nc nd aw ne bi"><span id="c717" class="mh kt in nb b gy nf ng l nh ni">$ bit checkout 1.0.1 removable-list-item --manual</span></pre><p id="79e8" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated"><strong class="lm io">同样，用你的组件的任何名称替换</strong> <code class="fe nk nl nm nb b"><strong class="lm io">removable-list-item</strong></code> <strong class="lm io">。</strong></p><p id="e6d3" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">这给了我修复组件内部任何合并冲突的能力，就像在Git中修复合并冲突一样。</p><p id="3f67" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">然后我可以运行<code class="fe nk nl nm nb b">yarn start</code>来查看我的ToDo应用程序现在正在使用更新的组件！</p><h2 id="ff03" class="mh kt in bd ku mi mj dn ky mk ml dp lc lt mm mn le lx mo mp lg mb mq mr li ms bi translated">浅谈构件属性和构件有效性</h2><p id="0afc" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">当在Bit上查看组件库中的组件时，确保组件接收到它们通常可能需要的任何道具是很重要的。</p><p id="28ed" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">这里的关键是考虑你的每一个组件，而不是考虑它需要什么道具来渲染。因此，举例来说，如果你有一个组件，通常会收到一个“文本”属性，确保你提供给它的属性。如果你不这样做，当你试图在你的组件库中查看你的组件时，Bit将不能呈现你的组件。</p><p id="5b13" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">当您将它上传到Bit时，不为它提供道具可能是有意义的，因为您可能不喜欢这样做，但是您可以考虑解决这个问题的方法，比如通过prop-types库提供默认的道具。或者至少，在组件库中查看组件时，向组件添加所需的道具🙂。</p><h1 id="5682" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">我们做到了！🎉</h1><p id="13f0" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated">我们已经看到了如何在React应用程序之间快速打包、版本化和重用组件。除了Bit自动化带来的速度提升，我们还创建了自己的可重用库！</p><p id="1f3f" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">我们现在可以决定在我们的编程之旅中逐步增加。我们甚至可以邀请其他开发人员为我们的代码做贡献，就像我们对待其他项目一样。</p><p id="457e" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated">它还不止于此，因为Bit上还有成千上万的其他组件库等着您去探索！</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/9467290cf80c329bffad0f7209c6584c.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/0*1aqUERetKCrc-_kF.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk"><a class="ae mg" href="https://bit.dev" rel="noopener ugc nofollow" target="_blank">Bit.dev</a></figcaption></figure><h1 id="be7f" class="ks kt in bd ku kv kw kx ky kz la lb lc jt ld ju le jw lf jx lg jz lh ka li lj bi translated">想了解更多关于Bit的内容吗？</h1><p id="78d0" class="pw-post-body-paragraph lk ll in lm b ln lo jo lp lq lr jr ls lt lu lv lw lx ly lz ma mb mc md me mf ig bi translated"><a class="ae mg" href="https://blog.bitsrc.io/15-reasons-to-build-your-component-library-in-bit-dev-93a514878863" rel="noopener ugc nofollow" target="_blank">在Bit.dev中构建组件库的15个理由</a></p><p id="c17a" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated"><a class="ae mg" href="https://blog.bitsrc.io/5-tools-for-faster-development-in-react-676f134050f2" rel="noopener ugc nofollow" target="_blank">在React中加快开发的5个工具</a></p><p id="8ca4" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated"><a class="ae mg" href="https://blog.bitsrc.io/11-react-component-libraries-you-should-know-178eb1dd6aa4" rel="noopener ugc nofollow" target="_blank">2019年你应该知道的11个React UI组件库</a></p><p id="50e9" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated"><strong class="lm io">更新:</strong>如果您想使用Bit，我强烈推荐这些更新的资源:</p><p id="ccd1" class="pw-post-body-paragraph lk ll in lm b ln mt jo lp lq mu jr ls lt mv lv lw lx mw lz ma mb mx md me mf ig bi translated"><a class="ae mg" href="https://medium.com/@JonathanSaring/update-with-some-new-examples-for-this-workflow-5c6b3bf2730?source=post_info_responses---------5-----------------------" rel="noopener">https://www.youtube.com/watch?v=9vS86xgG3ak&amp;t = 217s</a></p><div class="oa ob gp gr oc od"><a href="https://bit.cloud/blog/how-to-reuse-react-components-across-your-projects-l4pz83f4" rel="noopener  ugc nofollow" target="_blank"><div class="oe ab fo"><div class="of ab og cl cj oh"><h2 class="bd io gy z fp oi fr fs oj fu fw im bi translated">如何在项目中重用React组件</h2><div class="ok l"><h3 class="bd b gy z fp oi fr fs oj fu fw dk translated">最后，您完成了为应用程序中的表单创建一个奇妙的输入字段的任务。你对……很满意</h3></div><div class="ol l"><p class="bd b dl z fp oi fr fs oj fu fw dk translated">比特云</p></div></div><div class="om l"><div class="on l oo op oq om or km od"/></div></div></a></div></div></div>    
</body>
</html>