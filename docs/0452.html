<html>
<head>
<title>How to ace the Fibonacci sequence interview question</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何ace斐波那契数列面试题</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-ace-fibonacci-sequence-interview-question-93b5f15a27cc?source=collection_archive---------6-----------------------#2019-10-17">https://javascript.plainenglish.io/how-to-ace-fibonacci-sequence-interview-question-93b5f15a27cc?source=collection_archive---------6-----------------------#2019-10-17</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="1548" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">如何优化JavaScript中斐波那契数列元素的计算</h2></div><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi kc"><img src="../Images/b71ab02cf912072e4db1515e25d4a309.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*7j8nQGV4Q6x3EEhTPubNbg.jpeg"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Fibonacci sequence in nature</figcaption></figure><blockquote class="ks kt ku"><p id="12f2" class="kv kw kx ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated"><strong class="ky io"> TLDR: </strong>实现斐波那契数列在编程面试中是如此常见，值得掌握这个问题。了解这个序列递归实现的简单优化方法。</p></blockquote><p id="2c3f" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi lv translated"><span class="l lw lx ly bm lz ma mb mc md di"> H </span>你曾经需要在面试中使用斐波那契数列计算程序吗？这么多人举手！让我们研究一下这个简单的问题。我们从<strong class="ky io">问题定义</strong>开始好吗？</p><blockquote class="me"><p id="4f1a" class="mf mg in bd mh mi mj mk ml mm mn lr dk translated">写一个函数，以正整数N为参数，返回斐波那契数列的第N个元素。使用斐波那契数列的递归定义。</p></blockquote><p id="2e21" class="pw-post-body-paragraph kv kw in ky b kz mo jo lb lc mp jr le ls mq lh li lt mr ll lm lu ms lp lq lr ig bi translated">斐波那契数列的数学定义是这样的:</p><blockquote class="ks kt ku"><p id="b3fd" class="kv kw kx ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">fib(n)= fib(n-1)+fib(n-2)<br/>fib(1)= fib(2)= 1</p></blockquote><p id="7646" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">用英语描述这个:斐波那契数列的第N个元素可以通过将前一个元素和前一个元素之前的元素相加来计算。我们还知道两个Fibonacci数都等于1。</p><p id="51c1" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">这是一个非常简单的问题。我们需要将数学定义转化为代码实现。</p><p id="7e70" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">首先，让我们通读问题定义并提取函数签名:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Function signature</figcaption></figure><p id="7326" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">让我们仔细看看提到的数学定义。它有两个组成部分:<strong class="ky io">递归定义</strong>解释了如何计算特定元素。<strong class="ky io">终止条件</strong>表示何时停止计算:</p><blockquote class="ks kt ku"><p id="7907" class="kv kw kx ky b kz la jo lb lc ld jr le lf lg lh li lj lk ll lm ln lo lp lq lr ig bi translated">fib(n) = fib(n-1) + fib(n-2) //递归定义<br/> fib(1) = fib (2) = 1 //终止条件</p></blockquote><h1 id="261d" class="mv mw in bd mx my mz na nb nc nd ne nf jt ng ju nh jw ni jx nj jz nk ka nl nm bi translated">第一工作溶液</h1><p id="b542" class="pw-post-body-paragraph kv kw in ky b kz nn jo lb lc no jr le ls np lh li lt nq ll lm lu nr lp lq lr ig bi translated">其次，让我们尝试实现<strong class="ky io">循环定义</strong>:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Implementing recurrence definition</figcaption></figure><p id="7855" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">这是很好的代码，但不幸的是它不会终止。除非我们增加一些<strong class="ky io">终止条件</strong>，否则这种情况会一直持续下去:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Implementing termination condition</figcaption></figure><p id="5c2b" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">我们获得了第一个工作解决方案。成功！</p><h1 id="5ea8" class="mv mw in bd mx my mz na nb nc nd ne nf jt ng ju nh jw ni jx nj jz nk ka nl nm bi translated">测试</h1><p id="9576" class="pw-post-body-paragraph kv kw in ky b kz nn jo lb lc no jr le ls np lh li lt nq ll lm lu nr lp lq lr ig bi translated">此时，您应该考虑测试您的解决方案，以确信它是正确的。问问你自己:它对任何有效的输入都有效吗？有没有死角？什么输入可能有问题？</p><p id="3a97" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">为了使文章简短，我们将省略这一步。</p><h1 id="ac07" class="mv mw in bd mx my mz na nb nc nd ne nf jt ng ju nh jw ni jx nj jz nk ka nl nm bi translated">最佳化</h1><p id="38e4" class="pw-post-body-paragraph kv kw in ky b kz nn jo lb lc no jr le ls np lh li lt nq ll lm lu nr lp lq lr ig bi translated">通常在这一点上，我们应该考虑是否能以某种方式优化代码。斐波纳契数列的这个简单定义有一个缺陷，如果不一步一步地分析算法，这个缺陷可能不容易被发现。</p><p id="61fd" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">让我们分析一下如何计算小n的值。假设它是6。为了计算fib(6)，我们需要计算fib(5)和fib(4)。好的，看起来不错。让我们继续…为了计算fib(5 ),我们需要计算fib(4)和fib(3)。</p><p id="4920" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">稍等..我们需要计算fib(4)两次！一个在计算fib(6)时，一个在计算fib(5)时。那是浪费时间。</p><p id="c201" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">如果我们进一步进行计算，似乎我们需要多次计算一些元素。让我们以图形的形式可视化每个元素的依赖元素:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/fd947553c6c202f9dd2e3d7a7d2e24dc.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*_evlN1XKULp1dv71QvPHWA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Graph of elements to compute for N=6</figcaption></figure><p id="4425" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">我们清楚地看到一些节点是重复的。让我们给相同的元素上色:</p><figure class="kd ke kf kg gt kh gh gi paragraph-image"><div role="button" tabindex="0" class="ki kj di kk bf kl"><div class="gh gi ns"><img src="../Images/9ad134c519b9de87518d14074212e066.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*30pw3NpHm8QW50jydJo9ZA.png"/></div></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Graph of elements to compute for N=6 (colorized)</figcaption></figure><p id="66fc" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">让我们用表格总结一下我们的发现:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Table of repeated calculations</figcaption></figure><p id="87ed" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">我们只检查了N=6的情况，但是对于更大的N，所有这些多余的计算变得更加糟糕！</p><h2 id="f6a7" class="nt mw in bd mx nu nv dn nb nw nx dp nf ls ny nz nh lt oa ob nj lu oc od nl oe bi translated">高速缓存简介</h2><p id="a2bc" class="pw-post-body-paragraph kv kw in ky b kz nn jo lb lc no jr le ls np lh li lt nq ll lm lu nr lp lq lr ig bi translated">有人可能会问:有可能每个序列元素只计算一次吗？想到的是在计算完每个元素后保存它，然后在试图计算它之前总是检查所需的元素是否已知。</p><p id="ee22" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">如何贯彻这一理念？让我们介绍一下简单的<a class="ae of" href="https://en.wikipedia.org/wiki/Cache_(computing)" rel="noopener ugc nofollow" target="_blank">缓存</a>。我们将引入一个表，在该表中我们将保存序列元素的值，如下所示:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div><figcaption class="ko kp gj gh gi kq kr bd b be z dk">Example of filled cache</figcaption></figure><p id="4cb4" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">显然，我们在开始时不知道任何值，所以我们从空数组开始:</p><figure class="kd ke kf kg gt kh"><div class="bz fp l di"><div class="mt mu l"/></div></figure><p id="3dd2" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">最后，我们得到了优化的递归解。大获成功！</p><h1 id="acf3" class="mv mw in bd mx my mz na nb nc nd ne nf jt ng ju nh jw ni jx nj jz nk ka nl nm bi translated">摘要</h1><p id="9318" class="pw-post-body-paragraph kv kw in ky b kz nn jo lb lc no jr le ls np lh li lt nq ll lm lu nr lp lq lr ig bi translated">从这些例子中你可以学到一些一般性的东西。我们用系统的方法处理这个问题。我们也用了一些工具进行算法分析。</p><h2 id="b11c" class="nt mw in bd mx nu nv dn nb nw nx dp nf ls ny nz nh lt oa ob nj lu oc od nl oe bi translated">方法</h2><p id="c4a9" class="pw-post-body-paragraph kv kw in ky b kz nn jo lb lc no jr le ls np lh li lt nq ll lm lu nr lp lq lr ig bi translated">我们使用非常通用的方法来解决编程问题，可以这样总结:<br/> 1 .思考问题定义:<br/> a)它要求什么？<br/> b)我理解使用的所有术语吗？<br/> c)它有关于解决方案的任何信息吗？(例如函数签名)<br/> 2。关于小投入的理由。一步一步地为他们解决问题。<br/> 3。得出第一个工作解决方案，即使它远非最佳解决方案。<br/> 4。测试您的解决方案。(我们跳过了这一步)<br/> a)正确吗？<br/> b)哪些输入值可能有问题？<br/> c)是否存在任何死角？<br/> 5。尝试优化您的解决方案？<br/> a)是否存在冗余？你能想出更简单的公式吗？有些计算是不必要的吗？</p><h2 id="7e72" class="nt mw in bd mx nu nv dn nb nw nx dp nf ls ny nz nh lt oa ob nj lu oc od nl oe bi translated">工具</h2><p id="4dc9" class="pw-post-body-paragraph kv kw in ky b kz nn jo lb lc no jr le ls np lh li lt nq ll lm lu nr lp lq lr ig bi translated">我们默默地使用了一些在分析任何算法时都有用的工具:<br/>——用纸笔浏览简单的例子<br/>——可视化算法工作。任何图表、图画、情节都可以。人类非常擅长寻找视觉模式，不太擅长算术。说实话，我们算术真的很差。<br/> -在表格中总结算法的某些方面。与可视化工具一样，在表格中发现模式比在数字序列中容易得多。</p><p id="0e49" class="pw-post-body-paragraph kv kw in ky b kz la jo lb lc ld jr le ls lg lh li lt lk ll lm lu lo lp lq lr ig bi translated">尽管斐波纳契数列是一个非常简单的问题，但是你可以使用所描述的方法和工具来解决任何其他的编程问题。</p></div></div>    
</body>
</html>