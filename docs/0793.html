<html>
<head>
<title>How to publish JavaScript Libraries</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何发布JavaScript库</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-publish-javascript-libraries-68b9dd22dbda?source=collection_archive---------2-----------------------#2019-12-11">https://javascript.plainenglish.io/how-to-publish-javascript-libraries-68b9dd22dbda?source=collection_archive---------2-----------------------#2019-12-11</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><figure class="gl gn jo jp jq jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi jn"><img src="../Images/a6404453a64d51b7af13647489fc229a.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*G1mp7Ey7dCD_OMep"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jamesponddotco?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">James Pond</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><p id="bc7d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">你写了一些代码，很有用。当然，您想在不同的项目中使用它，或者您甚至想发布它让更多的人使用它。你可以把源代码上传到某个地方，并写下如何使用它的说明。但是有一个更标准更简单的方法:<strong class="kf ir">将其发布为库</strong>。</p><p id="1d0c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当您发布您的库时，您或其他人可以通过键入以下内容轻松获得它:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="72b4" class="lk ll iq lg b gy lm ln l lo lp">npm install your-super-library</span></pre><p id="592f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">并将其用于:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="d870" class="lk ll iq lg b gy lm ln l lo lp">import { somethingUseful } from “your-super-library”;</span></pre><p id="3940" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这使得高效的代码重用和基于更小的可重用片段的项目创建成为可能。</p><h1 id="5b9e" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">哪里出版</strong></h1><p id="bd92" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">目前<a class="ae kc" href="https://www.npmjs.com/" rel="noopener ugc nofollow" target="_blank"> npmjs </a>是事实上的标准，它允许公共和私有包，每个OS JavaScript库都在那里发布。<a class="ae kc" href="https://github.com/yarnpkg/yarn/issues/5891" rel="noopener ugc nofollow" target="_blank"> Yarn </a>资源库基本上是npmjs的镜像。</p><p id="1c79" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">有两个主要的客户端访问存储库(也称为包管理器):npm和yarn。两者都很棒，都允许开发人员轻松地:</p><ul class=""><li id="b62c" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">从存储库中获取库</li><li id="9721" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">处理可传递依赖关系</li><li id="53e8" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">随着新版本的发布更新依赖关系</li><li id="6356" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">发布您自己的库</li><li id="24b3" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">在机器之间复制依赖关系树(例如dev和CI)</li><li id="4fe6" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi">…</li></ul><p id="c062" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">也有一些替代方案来托管您自己的回购，如<a class="ae kc" href="https://jfrog.com/artifactory/" rel="noopener ugc nofollow" target="_blank"> Artifactory </a>或<a class="ae kc" href="https://www.sonatype.com/product-nexus-repository" rel="noopener ugc nofollow" target="_blank"> Nexus </a>。在本指南中，我假设您将使用npmjs，但发布到Artifactory或Nexus应该基本相同。</p><h1 id="4d60" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> package.json </strong></h1><p id="3da9" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">package.json是描述您的包的文件(在本指南中，我将库和包作为同义词使用)。</p><p id="8bdb" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这是一个示例package.json</p><figure class="lb lc ld le gt jr"><div class="bz fp l di"><div class="ng nh l"/></div></figure><p id="0db3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如您所见，它包括一些描述性数据<strong class="kf ir">如名称、版本、描述、作者、许可证、存储库或主页。</strong></p><p id="ad25" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">名称和版本是必需的。package.json中的附加属性是合法的，因此项目通常向package.json添加属性，以存储CI服务器、测试库等使用的一些配置。</p><p id="caff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在选择<strong class="kf ir">名称</strong>时，您应该考虑使用<a class="ae kc" href="https://docs.npmjs.com/misc/scope" rel="noopener ugc nofollow" target="_blank">作用域包</a>，这不仅是因为更容易找到自由名称，还因为它允许您更改特定作用域的存储库或认证数据，这在使用私有包时非常有用。</p><p id="72ff" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于<strong class="kf ir">版本</strong>你必须遵循<a class="ae kc" href="https://semver.org/" rel="noopener ugc nofollow" target="_blank">永远</a>。Semver说，当更新你的包依赖关系时，你可以决定改变是补丁还是次要的，但是因为这会对使用你的库的项目(例如包大小)产生很大的影响，所以我建议把这些改变作为次要的来发布。</p><p id="1371" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">还有一些数据会影响其他项目如何使用我们的包:</p><ul class=""><li id="911a" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated"><strong class="kf ir"> main </strong> —指向我们库的主js文件</li><li id="3019" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated"><strong class="kf ir">模块</strong> —指向我们库的主ES6模块</li><li id="34b6" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated"><strong class="kf ir"> jsnext:main </strong> —类似模块，但已过时</li><li id="72d2" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated"><strong class="kf ir">类型</strong> —指向typescript主d.ts文件</li><li id="2594" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated"><strong class="kf ir">依赖关系</strong> —使用该库所需的其他包</li><li id="1c88" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated"><strong class="kf ir">副作用</strong>—nodejs编译器优化ES6模块的提示</li></ul><h1 id="be98" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">模块</strong></h1><p id="49e1" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">发布我们的库的主要原因是为了便于重用。包存储库使下载库变得容易，但我们也希望代码在项目中易于使用。</p><p id="888d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是<strong class="kf ir">模块</strong>概念发挥作用的地方。一个模块可以被看作是一个乐高积木，它的底部有一些“管子”,顶部有一些“螺柱”,这个简单的契约可以很容易地将一些模块连接在一起。模块内部可以是任何东西，模块的内部不会影响其他模块的内部。</p><p id="7853" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这个使所有模块都可以连接到其他模块的契约被称为<strong class="kf ir">模块定义</strong>。目前我们有很多模块定义，所以我们需要理解它们以便为我们的库选择一个(或多个)模块定义。</p><p id="a37c" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">为了理解不同的模块定义，我推荐你阅读我以前的文章<a class="ae kc" href="https://medium.com/javascript-in-plain-english/javascript-module-definitions-a5a467a7f202" rel="noopener"> JavaScript模块定义</a></p><h2 id="2c36" class="lk ll iq bd lr ni nj dn lv nk nl dp lz ko nm nn md ks no np mh kw nq nr ml ns bi translated"><strong class="ak">我应该选择哪个模块定义</strong></h2><p id="abab" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">库的最佳模块定义取决于库的使用方式:</p><ul class=""><li id="2560" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">如果你的库只能在节点中使用(因为它使用文件系统),你应该使用CJS</li><li id="273b" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">如果您的库将用于新的web应用程序，您应该使用ESM</li><li id="cc42" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">如果你想让你的库在遗留的网络应用中使用，你可能需要AMD或者IIFE</li><li id="cc6e" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">如果您正在为一个特定的框架创建一个组件，并且它推荐一个特定的模块定义，那么就去使用它</li></ul><p id="5f07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是，如果我的库可以在浏览器和节点上使用，并且我想向所有人开放，我该怎么办呢？</p><p id="e8f1" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果你还记得，我们在package.json中有属性<em class="nt"> main </em>和<em class="nt"> module </em>，它们指向库的主js文件和使用es模块的库的主js。</p><p id="286b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这允许我们用ESM和bundle/trans file对我们的库进行两次编码，并生成例如<em class="nt"> dist/index.js </em>和<em class="nt"> dist/index.es.js </em>文件。然后我们可以将<em class="nt">主</em>和<em class="nt">模块</em>指向这2个文件。</p><p id="c274" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当一个项目依赖于我们的库时，它的捆绑者将选择最适合它需要的文件。这样，新的应用程序将选择ESM文件。</p><p id="6521" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是旧的应用程序会怎么样呢？如果我们选择<strong class="kf ir"> UMD </strong>作为主文件，nodejs应用程序、使用requireJS的应用程序甚至不使用捆绑器或加载器的web应用程序都可以使用它。</p><p id="37e6" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">所以main=UMD和module=ES6几乎支持我们库的每一个用户。</strong></p><p id="cdcc" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">今天很少有人在没有捆绑器的情况下建立网站，所以如果你对支持传统网站不感兴趣，你可能更喜欢main=CJS和module=ES6。</p><h1 id="2b8f" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">要不要捆绑？</strong></h1><p id="c3ad" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">捆绑意味着将所有文件连接成一个js文件。这是一种对web应用程序非常有用的技术。但是我们的图书馆可以捆绑或不捆绑出版。</p><p id="8b4f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果您的库是从一个节点应用程序中使用的，那么它是否是捆绑的就无关紧要了。使用捆绑器的web应用程序也会发生同样的情况。除非您的库使用别名(或其他方法)来缓解导入中的“相对路径地狱”。在这种情况下，您不能依赖使用您的库的应用程序来定位文件，最好进行捆绑。</p><p id="da07" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于不使用bundler的web应用程序，通常最好进行捆绑，因为浏览器很难通过HTTP找到导入的文件。即使这样做了，下载&gt;解析&gt;查找导入&gt;下载&gt;解析&gt;查找导入……的周期也比一次下载整个库要慢。</p><p id="5738" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所以是的，<strong class="kf ir">通常捆绑你的库更安全</strong>。</p><h1 id="19d7" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">我们应该在捆绑包中包含依赖关系吗？</h1><p id="1ed8" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们的捆绑包不得包含依赖代码。我们已经在package.json中列出了依赖项，因此使用我们库的项目将会下载依赖项本身。</p><p id="6e49" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">一些开发者(包括我)在bundler配置文件中导入package.json，将package.json依赖项作为外部使用。这样，我们可以确保捆绑包中不包含任何依赖项。</p><p id="bb6d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于不使用加载器或捆绑器的遗留web应用程序，包含一个包含依赖项的捆绑包可能是有用的，但是您永远不应该将它用作主文件。</p><h1 id="640f" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">我们应该转换到旧的EcmaScript吗？</h1><p id="a75f" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">当然，当我们生成UMD、AMD或IIFE bundles时，我们必须这样做，因为我们的库可能会像一样在浏览器<em class="nt">中使用。</em></p><p id="8c4e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是我们也需要将ESM包移植到ES5。这很有趣，因为ESM是在ES6中定义的。这是必要的，因为现代的捆绑器理解ES模块，但默认情况下不转换依赖关系。这会产生应用程序包，其中包含一些浏览器无法运行的代码。</p><h1 id="e3c4" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">poly fill会怎样？</strong></h1><p id="6005" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">如果我们将代码移植到旧版本，浏览器也可能需要一些聚合填充来运行我们的库。</p><p id="5fb9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">但是提供聚合填充的责任总是由应用程序承担，而不是由它的依赖项承担，因为只有应用程序的创建者知道目标浏览器，并且这是防止几个依赖项的唯一方法，以提供几个等价的聚合填充。</p><p id="c365" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">因此，<strong class="kf ir">我们的库必须在运行时检查所需特性的存在，如果不存在，它将抛出一个错误来帮助应用程序开发人员添加polyfill。</strong></p><p id="078e" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">此外，在库文档中提及所需的polyfills也是很好的。</p><h1 id="7f69" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">打字稿会怎么样？</strong></h1><p id="d773" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">作为库开发人员，我们希望其他开发人员能够轻松使用我们的库，因此我们将提供typescript定义文件(. d.ts)。这些文件解释了我们的模块期望和导出的类型。所以用typescript(现在相当流行)编写的应用程序可以使用我们的库，而不需要自己编写. d.ts文件。</p><p id="2048" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">如果我们用typescript编写代码，那么我们就不需要自己编写. d.ts，因为typescript会自动生成它。Typescript还帮助我们在模块内部正确处理类型，因此它将提高我们的代码质量。</p><p id="41ba" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在模块化架构中，一些部分可能由不同的团队使用不同的技术创建，因此这些部分按照预期工作并尽可能少地出现错误非常重要。</p><p id="8684" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">正如我们可以配置本库的<strong class="kf ir"> main </strong>文件一样，在package.json中，我们也可以告知我们的包的main .d.ts位于何处。为此，我们将使用属性<strong class="kf ir">类型。</strong></p><p id="3257" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">注意</strong> <em class="nt"> : </em>如果我们的库依赖于其他包，我们需要导入额外的类型来使用它们，这些<strong class="kf ir">类型依赖就不是dev-dependencies </strong>。因为使用我们库的应用程序将需要过渡性地使用它们。</p><h1 id="f57a" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak"> package-lock.json，yarn.lock还是npm-shrinkwrap.json？</strong></h1><p id="25c5" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">锁文件让我们复制完全相同的依赖关系树实例，包括直接依赖关系和传递依赖关系。这对于在不同开发人员的机器、CI中拥有相同的环境，甚至是回到过去生成构建的开发环境，都是非常有用的。</p><p id="baae" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">现在我们正在构建一个用于其他应用程序的库，我们有一个不同的需求:</p><blockquote class="nu nv nw"><p id="98f6" class="kd ke nt kf b kg kh ki kj kk kl km kn nx kp kq kr ny kt ku kv nz kx ky kz la ij bi translated">如果我们的库有一个依赖项，并且使用我们的库的应用程序有相同的依赖项，我们希望应用程序包只包含一次依赖项。</p></blockquote><p id="da44" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">这就是为什么我们在package.json中用通配符(^，~，*，&gt;，…)定义依赖项，如果有一个版本的依赖项与我们的库和应用程序都兼容，那么它应该只包含一次。</p><p id="8aab" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">当构建依赖于它的应用程序时，我们库中的<strong class="kf ir"> package.lock </strong>和<strong class="kf ir"> yarn.lock </strong>都将被忽略。但是<strong class="kf ir"> npm-shrinkwrap.json </strong>是可传递的，所以应用程序将被迫使用相同版本的公共依赖项，它们可能会被添加两次。</p><p id="a42f" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated"><strong class="kf ir">对于库，建议不要添加npm-shrinkwrap.json </strong>。</p><p id="12d8" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">对于服务器端应用程序或CLI应用程序，添加它是可以的，但可能<strong class="kf ir"> package.lock </strong>也是可以的。</p><h1 id="204a" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated"><strong class="ak">将要发布的文件</strong></h1><p id="7dc5" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">默认情况下，除了名为. npmignore的文件中列出的文件之外，项目文件夹中的所有文件都将被发布。gitignore事实上如果没有。不要理会。将使用gitignore文件。</p><p id="6d27" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">在package.json中，我们还可以配置<a class="ae kc" href="https://docs.npmjs.com/files/package.json#files" rel="noopener ugc nofollow" target="_blank">文件属性</a>。它是一个文件模式数组，描述当您的库发布时要上传到存储库的条目。如果您的package.json有一个<strong class="kf ir"> files </strong>属性，那么只有匹配的文件才会包含在包中。</p><p id="6f30" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">无论您的配置如何，还有一些文件总是包含在内:package.json、README、CHANGELOG、LICENSE和main属性中的文件。</p><p id="c97d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">您可以通过运行以下命令来检查哪些文件将包含在您的包中</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="ff97" class="lk ll iq lg b gy lm ln l lo lp">npm pack</span></pre><h1 id="4a56" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">出版过程</h1><p id="3d79" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">我们终于准备好出版我们的图书馆了。要创建我们的库，我们应该完成:</p><ul class=""><li id="e6ad" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">配置软件版本控制(git init)</li><li id="3fbd" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">创建我们的package.json并配置所有需要的属性(npm init)</li><li id="ee1c" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">编写代码和测试</li><li id="1059" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">配置捆绑器并生成捆绑包</li><li id="c348" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">创建一个自述文件，至少解释这个库的用途以及如何使用它</li></ul><h2 id="0815" class="lk ll iq bd lr ni nj dn lv nk nl dp lz ko nm nn md ks no np mh kw nq nr ml ns bi translated"><strong class="ak">检查库是否工作</strong></h2><p id="9c4c" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">由于我们正在生成一个库，所以我们希望将其作为实际应用程序的依赖项进行测试。</p><p id="a2b3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我建议您在您的库中创建一个名为<strong class="kf ir"> example </strong>的目录，其中包含一个使用该库的演示应用程序。</p><p id="808d" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">示例文件夹中的以下package.json将允许您依赖您的库包，然后像使用外部依赖项一样使用它，而无需发布它:</p><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="614d" class="lk ll iq lg b gy lm ln l lo lp">{</span><span id="4548" class="lk ll iq lg b gy oa ln l lo lp">    “name”: “@jacarma/my-awesome-library-example”,</span><span id="974b" class="lk ll iq lg b gy oa ln l lo lp">    “version”: “0.0.0”,</span><span id="9754" class="lk ll iq lg b gy oa ln l lo lp">    “license”: “MIT”,</span><span id="8efc" class="lk ll iq lg b gy oa ln l lo lp">    “private”: true,</span><span id="ffed" class="lk ll iq lg b gy oa ln l lo lp">    “dependencies”: {</span><span id="28ba" class="lk ll iq lg b gy oa ln l lo lp">        “@jacarma/my-awesome-library”: “file:..”</span><span id="529e" class="lk ll iq lg b gy oa ln l lo lp">    },</span><span id="efdc" class="lk ll iq lg b gy oa ln l lo lp">    “scripts”: {</span><span id="ba5a" class="lk ll iq lg b gy oa ln l lo lp">        “start”: “dev-server”</span><span id="f155" class="lk ll iq lg b gy oa ln l lo lp">    }</span><span id="95d6" class="lk ll iq lg b gy oa ln l lo lp">}</span></pre><p id="d407" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">或者，你可以<strong class="kf ir"> npm在你的库文件夹中链接</strong>，然后在另一个文件夹的目录中，<strong class="kf ir"> npm链接你的库名</strong>。这将在node_modules中创建一个链接，让您可以将它用作依赖项。</p><h2 id="49a7" class="lk ll iq bd lr ni nj dn lv nk nl dp lz ko nm nn md ks no np mh kw nq nr ml ns bi translated"><strong class="ak">预发行支票</strong></h2><p id="60c0" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在发布之前，我们希望确保我们会做得正确，以下是一些对我来说有意义的检查:</p><ul class=""><li id="1cc0" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">我们是在主服务器上还是在发布分支上</li><li id="6ff8" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">我们的工作目录与回购中的代码完全匹配</li><li id="8121" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">我们的依赖关系已更新</li><li id="5b94" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">捆绑内容可以。依赖项不包含在包中，生成的包使用预期的模块定义…</li><li id="704a" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">我们不包括私人或不需要的文件(<strong class="kf ir"> npm包</strong>)</li></ul><h2 id="2757" class="lk ll iq bd lr ni nj dn lv nk nl dp lz ko nm nn md ks no np mh kw nq nr ml ns bi translated"><strong class="ak">发布</strong></h2><p id="0e87" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">首先，如果你没有npm账户，你可以在<a class="ae kc" href="https://www.npmjs.com/signup" rel="noopener ugc nofollow" target="_blank">npmjs.com/signup</a>创建一个</p><ul class=""><li id="9316" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">从您的终端登录npmjs，它会询问您的用户名和密码</li></ul><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="3484" class="lk ll iq lg b gy lm ln l lo lp">npm login</span></pre><ul class=""><li id="739a" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">删除你的库版本并创建一个新的git标签</li></ul><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="c9e1" class="lk ll iq lg b gy lm ln l lo lp">npm version</span></pre><ul class=""><li id="5921" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">推送碰撞代码和新标签</li></ul><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="b504" class="lk ll iq lg b gy lm ln l lo lp">git push --follow-tags</span></pre><ul class=""><li id="1147" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">将库发布到npmjs</li></ul><pre class="lb lc ld le gt lf lg lh li aw lj bi"><span id="8e88" class="lk ll iq lg b gy lm ln l lo lp">npm publish --access public</span></pre><ul class=""><li id="1121" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">庆祝一下！您的库已经可以使用了，您可以创建一个新的应用程序并添加库作为依赖项来证明这一点</li></ul><figure class="lb lc ld le gt jr gh gi paragraph-image"><div role="button" tabindex="0" class="js jt di ju bf jv"><div class="gh gi ob"><img src="../Images/881345f897add66d00aab81de3545dd1.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/0*CYBlDvhVo-T4P7gN"/></div></div><figcaption class="jy jz gj gh gi ka kb bd b be z dk">Photo by <a class="ae kc" href="https://unsplash.com/@jdent?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Jason Dent</a> on <a class="ae kc" href="https://unsplash.com?utm_source=medium&amp;utm_medium=referral" rel="noopener ugc nofollow" target="_blank">Unsplash</a></figcaption></figure><h2 id="992d" class="lk ll iq bd lr ni nj dn lv nk nl dp lz ko nm nn md ks no np mh kw nq nr ml ns bi translated"><strong class="ak">可选</strong></h2><ul class=""><li id="0586" class="ms mt iq kf b kg mn kk mo ko oc ks od kw oe la mx my mz na bi translated">写发布说明(<a class="ae kc" href="https://help.github.com/en/github/administering-a-repository/creating-releases" rel="noopener ugc nofollow" target="_blank"> Github发布</a>)</li><li id="c91d" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">更新网站(<a class="ae kc" href="https://github.com/tschaub/gh-pages" rel="noopener ugc nofollow" target="_blank"> gh-pages </a></li></ul><h2 id="fe21" class="lk ll iq bd lr ni nj dn lv nk nl dp lz ko nm nn md ks no np mh kw nq nr ml ns bi translated">替代:np</h2><p id="e5c9" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">有一个工具可以简化发布过程，它叫做<a class="ae kc" href="https://github.com/sindresorhus/np" rel="noopener ugc nofollow" target="_blank"> np </a>。</p><h1 id="923b" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">作为操作系统库维护者的职责</h1><p id="9b0f" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">如果你想把这个库作为开源来发布，你将获得一些责任。</p><ul class=""><li id="8b81" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">回答问题，bug和PR</li><li id="3c89" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">保持相关性最新</li><li id="443c" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">保护您的图书馆安全</li><li id="f936" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">注意安全警报</li><li id="796c" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">不维护时发出警告</li></ul><p id="1318" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">没有什么是强制性的，但是如果你不履行它们，有人会分叉你的代码，开发者更喜欢维护良好的代码。</p><h1 id="f40c" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">结论</h1><p id="de3b" class="pw-post-body-paragraph kd ke iq kf b kg mn ki kj kk mo km kn ko mp kq kr ks mq ku kv kw mr ky kz la ij bi translated">在发布过程中没有什么困难:npm版本和npm发布应该足够了。</p><p id="d0e9" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">所有的“复杂性”都来自于生成易于在应用程序中使用的包:</p><ul class=""><li id="2a2c" class="ms mt iq kf b kg kh kk kl ko mu ks mv kw mw la mx my mz na bi translated">一些应用程序运行在浏览器上，一些运行在节点上</li><li id="f561" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">有些应用程序使用捆绑器，有些不使用</li><li id="b348" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">有些应用程序使用typescript，有些不使用</li><li id="2933" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">浏览器支持不同版本的ES，缓解这种情况的方法(transfile+poly fill)在模块化架构中很复杂或不明确</li><li id="6ee4" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">模块定义太多</li><li id="8cbd" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">开发人员并不完全理解传递依赖是如何解决的(对等依赖，。锁定文件、通配符)</li><li id="487b" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated">开发人员没有完全区分包管理器、捆绑器、传输器和模块加载器的职责，因为通常它们中的几个都包含在一个工具中</li><li id="cb27" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi">…</li></ul><p id="3eb3" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我希望这篇文章能帮助你弄清楚如何发布JS库。请记住，这个生态系统每天都在发展，本文首次发表于2019年12月，一些提示可能在未来无效，因此请谨慎使用。</p><p id="d77b" class="pw-post-body-paragraph kd ke iq kf b kg kh ki kj kk kl km kn ko kp kq kr ks kt ku kv kw kx ky kz la ij bi translated">我很想知道这篇文章是否对你出版一个库有所帮助，你可以通过<a class="ae kc" href="https://twitter.com/jacarma" rel="noopener ugc nofollow" target="_blank"> @jacarma </a>联系我</p><h1 id="ec4b" class="lq ll iq bd lr ls lt lu lv lw lx ly lz ma mb mc md me mf mg mh mi mj mk ml mm bi translated">追踪</h1><ul class=""><li id="b0d8" class="ms mt iq kf b kg mn kk mo ko oc ks od kw oe la mx my mz na bi translated"><a class="ae kc" href="https://medium.com/sungthecoder/javascript-module-module-loader-module-bundler-es6-module-confused-yet-6343510e7bde" rel="noopener">JavaScript模块简史</a></li><li id="dfb3" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated"><a class="ae kc" href="https://madewithlove.be/optimizing-javascript-packages-for-tree-shaking/" rel="noopener ugc nofollow" target="_blank">为摇树优化JavaScript包</a></li><li id="5d0c" class="ms mt iq kf b kg nb kk nc ko nd ks ne kw nf la mx my mz na bi translated"><a class="ae kc" href="https://www.typescriptlang.org/docs/handbook/declaration-files/publishing.html" rel="noopener ugc nofollow" target="_blank">排版出版</a></li></ul></div></div>    
</body>
</html>