<html>
<head>
<title>JavaScript Basics: Types and Coercion</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">JavaScript基础:类型和强制</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/javascript-basics-types-and-coercion-3a48ce667e39?source=collection_archive---------27-----------------------#2020-12-21">https://javascript.plainenglish.io/javascript-basics-types-and-coercion-3a48ce667e39?source=collection_archive---------27-----------------------#2020-12-21</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="5119" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">JavaScript中的数据类型</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/09e83c183c812ef9bbdee06e5b4193ab.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*bNrkK5WfvHQ8V5NBDGj06w.jpeg"/></div></div></figure></div><div class="ab cl kr ks hu kt" role="separator"><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw kx"/><span class="ku bw bk kv kw"/></div><div class="ij ik il im in"><p id="9cb7" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这篇文章中，我们将讨论JavaScript的基本数据类型和强制的概念。</p><p id="9542" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">JavaScript如何处理类型被称为<code class="fe lu lv lw lx b">dynamic typing</code>，这意味着变量的类型没有明确定义。这都是在代码运行时确定的。</p><p id="01e9" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在JavaScript中，没有关键字来告诉引擎你打算给变量分配什么样的数据(剧透:TypeScript解决了这个问题)。其他语言如Java和C++使用一种叫做<code class="fe lu lv lw lx b">static typing</code>的东西，这意味着变量的类型被定义了。如果赋值，而不是声明的值，将抛出一个错误。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="792b" class="mc md iq lx b gy me mf l mg mh">// Sample C++</span><span id="23e5" class="mc md iq lx b gy mi mf l mg mh">bool isNew = true; //valid assignment<br/>bool isError = "imNotaBooleanValue" // will throw an error</span></pre><p id="9266" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">使用JavaScript，我们可以在不声明类型的情况下给变量赋值。如果有必要，我们甚至可以将变量重新分配给完全不同的数据类型。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="a2ee" class="mc md iq lx b gy me mf l mg mh">// Sample JavaScript<br/>let isNew = true;<br/>isNew = "imStringNow";</span></pre><p id="b3eb" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">让我们快速浏览一下JavaScript中的原语(不是对象也没有方法的数据)类型:</p><ul class=""><li id="b33b" class="mj mk iq la b lb lc le lf lh ml ll mm lp mn lt mo mp mq mr bi translated"><code class="fe lu lv lw lx b">undefined</code>，代表缺乏存在。变量未设置值。</li><li id="4091" class="mj mk iq la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated"><code class="fe lu lv lw lx b">Boolean</code>，真值或假值</li><li id="42a4" class="mj mk iq la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated"><code class="fe lu lv lw lx b">Number</code>，在JavaScript中，这包括整数和小数</li><li id="6c95" class="mj mk iq la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated"><code class="fe lu lv lw lx b">BigInt</code>，JavaScript中的数字原语，可以表示任意精度的整数。可以安全地存储和操作非常大的整数。</li><li id="0674" class="mj mk iq la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated"><code class="fe lu lv lw lx b">String</code>，由""或" "包围的字符序列</li><li id="70f9" class="mj mk iq la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated"><code class="fe lu lv lw lx b">Symbol</code>，唯一不变的值</li><li id="f43e" class="mj mk iq la b lb ms le mt lh mu ll mv lp mw lt mo mp mq mr bi translated"><code class="fe lu lv lw lx b">null</code>(特殊原始人)，代表缺乏存在。当变量设置为空时，可用于变量。</li></ul><p id="c6f0" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">有一个<code class="fe lu lv lw lx b">operator</code>，<code class="fe lu lv lw lx b">typeof</code>，在运行时检查一个值的当前类型。</p><h1 id="5d8e" class="mx md iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">经营者</h1><p id="7864" class="pw-post-body-paragraph ky kz iq la b lb no jr ld le np ju lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">一个<code class="fe lu lv lw lx b">operator</code>是一个语法上不同的特殊函数。如前所述，<code class="fe lu lv lw lx b">typeof</code>是一个操作符，它接受一个a值并返回一个指示类型的字符串。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="b46a" class="mc md iq lx b gy me mf l mg mh">console.log(typeof 432) // "number";<br/>console.log(typeof 'hello') // "string";</span></pre><p id="da55" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">其他熟悉的运算符包括加、减、乘、除、小于、大于、等于，这些都是特殊类型的函数，通常接受两个参数并返回一个结果。当有多个操作符时，需要考虑一些特殊的规则。</p><p id="656a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe lu lv lw lx b">operator precedence</code>决定首先调用哪个操作功能，优先级较高。这里有一个<a class="ae nt" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" rel="noopener ugc nofollow" target="_blank">表</a>，列出了每个运算符的优先级值。让我们看一个例子:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="a555" class="mc md iq lx b gy me mf l mg mh">let a = 3 + 4 * 5 // multiplication has higher precedence<br/>//  a = 3 + 20    // addition is left<br/>//  a = 23</span></pre><p id="937b" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">如果运算符具有相同的优先级，会发生什么情况？使用同一个表，我们可以参考关联性。<code class="fe lu lv lw lx b">operator associativity</code>决定了操作符被调用的顺序。让我们来看看:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="5945" class="mc md iq lx b gy me mf l mg mh">let a = 2, b = 4, c = 9;<br/>a = b = c<br/>console.log(a) //9<br/>console.log(b) //9<br/>console.log(c) //9</span></pre><p id="c609" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">在这个例子中，我们使用了<code class="fe lu lv lw lx b">assignment</code>操作符来重新分配。因为它们都有相同的优先级，所以结合性决定了哪个操作符先被执行，哪个是<code class="fe lu lv lw lx b">right-to-left</code>。我们先关注<code class="fe lu lv lw lx b">b = c</code>。在这种情况下，<code class="fe lu lv lw lx b">c</code>是9，我们将<code class="fe lu lv lw lx b">b</code>重新分配给9。同样，我们将<code class="fe lu lv lw lx b">a</code>重新分配给9。</p><h1 id="c4bf" class="mx md iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">强迫</h1><p id="10c2" class="pw-post-body-paragraph ky kz iq la b lb no jr ld le np ju lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">我们被带到了JavaScript中一个著名的概念，<code class="fe lu lv lw lx b">coercion</code>。它是一个值从一种类型到另一种类型的转换。这在JavaScript中经常发生，因为它是动态类型的。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="0699" class="mc md iq lx b gy me mf l mg mh">// First Sample<br/>let a = "sample" + "test"<br/>console.log(a) // "sampletest"</span><span id="4d8e" class="mc md iq lx b gy mi mf l mg mh">// Second Sample<br/>let x = 1 + "2"<br/>console.log(x) // "12"</span></pre><p id="ca88" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第一个示例是有效的，因为JavaScript连接字符串并将它们组合在一起。在第二个示例中，第一个值1被JavaScript引擎强制转换成一个字符串并进行组合。与其他编程语言不同，JavaScript在处理两种不同的数据类型时不会抛出错误。</p><p id="44e7" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">由于JavaScript是动态类型的，它倾向于尝试将事物转换成您想要的值。许多这一切都是在JavaScript引擎的引擎盖下发生的。</p><h1 id="1637" class="mx md iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">比较运算符</h1><p id="325f" class="pw-post-body-paragraph ky kz iq la b lb no jr ld le np ju lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">让我们看另一个强迫的例子。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="4ff9" class="mc md iq lx b gy me mf l mg mh">console.log(1&lt;2&lt;3) // true<br/>console.log(3&lt;2&lt;1) // true</span></pre><p id="61b5" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">第一个<code class="fe lu lv lw lx b">console</code>有意义，因为1小于2，2小于3。但是，为什么第二个<code class="fe lu lv lw lx b">console</code>会返回<code class="fe lu lv lw lx b">true</code>？我们来分析一下。由于都是同一个运算符，<code class="fe lu lv lw lx b">less than</code>的结合律来自<code class="fe lu lv lw lx b">left-to-right</code>。所以还是把重点放在<code class="fe lu lv lw lx b">3&lt;2</code>上吧。结果返回<code class="fe lu lv lw lx b">false</code>。现在让我们重写语句:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="91ff" class="mc md iq lx b gy me mf l mg mh">3 &lt; 2 // false<br/>false &lt; 1</span></pre><p id="94f8" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">操作符本身需要两个数字，但是我们有一个<code class="fe lu lv lw lx b">boolean</code>和一个<code class="fe lu lv lw lx b">number</code>来处理。JavaScript试图将布尔值强制转换为数字。有一个内置的JavaScript函数<code class="fe lu lv lw lx b">Number()</code>，它接受一个值，JavaScript决定它将强制什么。</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="7045" class="mc md iq lx b gy me mf l mg mh">Number(false) // 0<br/>Number(undefined) // NaN<br/>Number(null) // 0</span></pre><p id="1f2b" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">用<code class="fe lu lv lw lx b">true/false</code>可以强制分别变成1和0。<code class="fe lu lv lw lx b">undefined</code>返回<code class="fe lu lv lw lx b">NaN</code>或非数字，<code class="fe lu lv lw lx b">null</code>转换为0。回到问题上来，</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="e08a" class="mc md iq lx b gy me mf l mg mh">false &lt; 1<br/>0 &lt; 1 // true</span></pre><p id="217a" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated"><code class="fe lu lv lw lx b">false</code>被强制为0，我们比较0小于1，结果是<code class="fe lu lv lw lx b">true</code>。第一个<code class="fe lu lv lw lx b">console</code>可能并没有像我们想象的那样被评价。让我们重温一下:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="3296" class="mc md iq lx b gy me mf l mg mh">1 &lt; 2 &lt; 3 // same operator. left-to-right<br/>1 &lt; 2 // true<br/>true &lt; 3 // true is coerced to 1<br/>1 &lt; 3 // true</span></pre><p id="7773" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">原来第一个<code class="fe lu lv lw lx b">console</code>碰巧返回了我们预期的结果。JavaScript引擎决定某个特定类型将强制什么并不总是显而易见的。</p><h1 id="9dfb" class="mx md iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">平等比较</h1><p id="255d" class="pw-post-body-paragraph ky kz iq la b lb no jr ld le np ju lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">在JavaScript中有两种方法可以检查两个东西是否相等:<code class="fe lu lv lw lx b">equality(==)</code>和<code class="fe lu lv lw lx b">strict equality(===)</code>。先说<code class="fe lu lv lw lx b">equality</code>。如果被比较的事物具有相同的类型和值，它将简单地返回<code class="fe lu lv lw lx b">true</code>。然而，如果它们不是同一类型，那么<code class="fe lu lv lw lx b">==</code>操作符将强制这些类型，并确定它们是否相等。例如:</p><pre class="kg kh ki kj gt ly lx lz ma aw mb bi"><span id="1a5e" class="mc md iq lx b gy me mf l mg mh">"" == 0 //true<br/>"0" == 0 //true<br/>false == "false" // false</span></pre><p id="5826" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">操作符可以导致一些有趣的情况，因为它仍然涉及强制。然而，<code class="fe lu lv lw lx b">===</code>操作符做的正是我们所期望的。它检查被比较的事物在类型和价值方面是否实际相等。如果类型不同，则不尝试强制，并返回<code class="fe lu lv lw lx b">false</code>。</p><h1 id="a305" class="mx md iq bd my mz na nb nc nd ne nf ng jw nh jx ni jz nj ka nk kc nl kd nm nn bi translated">结束语</h1><p id="2cde" class="pw-post-body-paragraph ky kz iq la b lb no jr ld le np ju lg lh nq lj lk ll nr ln lo lp ns lr ls lt ij bi translated">因为JavaScript是动态类型的，所以当值被操作或比较时会出现问题。在比较JavaScript中的不同类型时，可能会出现许多有趣的情况。意识到<code class="fe lu lv lw lx b">coercion</code>出现在JavaScript中有助于防止/解决开发过程中可能遇到的错误。</p><p id="2a8e" class="pw-post-body-paragraph ky kz iq la b lb lc jr ld le lf ju lg lh li lj lk ll lm ln lo lp lq lr ls lt ij bi translated">感谢您的阅读和快乐编码！</p></div></div>    
</body>
</html>