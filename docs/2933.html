<html>
<head>
<title>How to use Inquirer.js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">如何使用Inquirer.js</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/how-to-inquirer-js-c10a4e05ef1f?source=collection_archive---------2-----------------------#2020-08-08">https://javascript.plainenglish.io/how-to-inquirer-js-c10a4e05ef1f?source=collection_archive---------2-----------------------#2020-08-08</a></blockquote><div><div class="fc ib ic id ie if"/><div class="ig ih ii ij ik"><div class=""/><div class=""><h2 id="4307" class="pw-subtitle-paragraph jk im in bd b jl jm jn jo jp jq jr js jt ju jv jw jx jy jz ka kb dk translated">Inquirer是一个基于promise的npm包，在节点项目中用于为基于查询的任务创建CLI(命令行界面)工具</h2></div><p id="0356" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">在这篇文章中，我想谈论一个我非常喜欢使用的CLI工具，希望有人在这个过程中学到一些东西。</p><h1 id="7907" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">让我们从头开始:什么是Inquirer？</h1><p id="831f" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">Inquirer是一个基于promise的npm包，用在节点项目中，为基于查询的任务创建CLI(命令行界面)工具。它非常适合询问用户问题，验证用户输入，以及处理给出的响应。</p><p id="1b7c" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我使用Inquirer和mysql数据库创建了一个名为“员工管理器”的CLI工具。它询问用户他们想做什么，并给他们一个选项列表。他们可以添加新员工、分配角色、部门和办公室、设定工资等等—所有这些都无需创建前端。</p><h1 id="4112" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">Node是什么？</h1><p id="5325" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">Node.js是基于<a class="ae lv" href="https://v8.dev/" rel="noopener ugc nofollow" target="_blank"> Chrome的V8 JavaScript引擎</a>构建的JavaScript运行时。关于什么是节点以及如何设置它的更多信息，<a class="ae lv" href="https://nodejs.org/en/about/" rel="noopener ugc nofollow" target="_blank">点击这里</a>。在使用Inquirer之前，您需要Node。</p><h1 id="8a55" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">那么我该如何使用Inquirer呢？</h1><p id="7bea" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">很高兴你问了！就本文而言，我们将构建一个简单的基于Inquirer的项目，从最开始一直到更深入的内容。他们的文档(底部的链接)有你需要设置的所有信息，但是我们也在这里介绍一下。</p><p id="eb94" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您还没有这样做，请通过在项目根目录下的终端中键入以下内容来初始化项目中的npm:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="980b" class="mf kz in mb b gy mg mh l mi mj">npm init -y</span></pre><p id="5c2f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在你已经准备好安装Inquirer了。在您的终端中键入以下内容:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="3353" class="mf kz in mb b gy mg mh l mi mj">npm install inquirer</span></pre><p id="c89d" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">下一步包括将Inquirer库引入到您正在处理的文件中。您可以通过在代码开头添加以下行来实现这一点:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="dfd5" class="mf kz in mb b gy mg mh l mi mj">const inquirer = require("inquirer")</span></pre><p id="ead8" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在我们已经将inquirer引入到我们的项目中，让我们构建第一个查询并运行它。每个查询都以相同的代码开始:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="95bb" class="mf kz in mb b gy mg mh l mi mj">inquirer.prompt()</span></pre><p id="c2ff" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们访问inquirer库并使用prompt方法向用户显示我们的问题。但它比那更复杂——inquirer为它的问题获取一系列对象。所以我们在括号内打开一个数组，然后在数组内打开一个对象，得到这样的结果:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="edaa" class="mf kz in mb b gy mg mh l mi mj">inquirer.prompt([{}])</span></pre><p id="42f2" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">每个问题对象应至少包含三个关键字:</p><ul class=""><li id="cb96" class="mk ml in ke b kf kg ki kj kl mm kp mn kt mo kx mp mq mr ms bi translated">姓名——你以后如何提及这个问题(以及给出的答案)</li><li id="e50e" class="mk ml in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">这是什么类型的问题？(输入、多项选择、数字等)</li><li id="0526" class="mk ml in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">信息——你问用户的问题</li></ul><p id="ee70" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">利用这些新知识，我们可以创建一个基本问题，看起来像这样:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="548d" class="mf kz in mb b gy mg mh l mi mj">inquirer<br/>  .prompt([<br/>    {<br/>      name: "user_name",<br/>      type: "input",<br/>      message: "What is your name?",<br/>    },<br/>  ]);</span></pre><p id="7171" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="my">需要注意的是,‘type’的默认选项是‘input ’,因此在这个场景中实际上是不必要的，但是为了清楚起见，我喜欢包含它。</em></p><p id="50e7" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">但是我们还没有完成，我们已经提出了问题，但是我们没有对答案做任何事情。答案作为一个对象返回给我们，其中键是问题的“名称”属性，答案是它的值。您可以使用获取答案。then()内部有一个回调函数。假设我们想将这个问题的答案打印到控制台，我们可以使用下面的代码:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="c854" class="mf kz in mb b gy mg mh l mi mj">inquirer<br/>  .prompt([<br/>    {<br/>      name: "user_name",<br/>      type: "input",<br/>      message: "What is your name?",<br/>    },<br/>  ])<br/>  .then((answer) =&gt; {<br/>    console.log("Hello " + answer.user_name);<br/>  });</span></pre><p id="bd9f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">祝贺您，您刚刚使用Inquirer.js编写了您的第一个问题。要运行此问题，请在您的控制台中键入以下内容:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="23db" class="mf kz in mb b gy mg mh l mi mj">node &lt;filename&gt;</span></pre><p id="071a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">出于本文的目的，我编写了自己的文件来演示。</p><figure class="lw lx ly lz gt na gh gi paragraph-image"><div role="button" tabindex="0" class="nb nc di nd bf ne"><div class="gh gi mz"><img src="../Images/1e303b0403c8227c849eda3052f7adaf.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*lsoqw1zy0IKSfjDxlTJ30A.png"/></div></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">Demonstrating usage and expected outcome</figcaption></figure><h1 id="b9bf" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">让我们更进一步</h1><p id="cd7d" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">所以我们问了一个问题，我们如何问多个问题？这就像在数组中添加另一个问题对象一样简单。在下面的示例中，我在我们之前编写的代码中添加了一些小的修改，以询问用户的名字和姓氏:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="834f" class="mf kz in mb b gy mg mh l mi mj">inquirer<br/>  .prompt([<br/>    {<br/>      name: "first_name",<br/>      type: "input",<br/>      message: "What is your first name?",<br/>    },<br/>    {<br/>      name: "last_name",<br/>      type: "input",<br/>      message: "What is your last name?",<br/>    },<br/>  ])<br/>  .then((answer) =&gt; {<br/>    console.log("Hello", answer.first_name, answer.last_name);<br/>  });</span></pre><h1 id="b982" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">问题类型</h1><p id="bd84" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">所以我们学会了添加基于输入的问题。如果我们想让用户从一系列可能的选项中选择呢？我们需要做的就是改变问题的“类型”字段。Inquirer提供了许多类型的问题，我最常用的是:</p><ul class=""><li id="0144" class="mk ml in ke b kf kg ki kj kl mm kp mn kt mo kx mp mq mr ms bi translated">投入</li><li id="de50" class="mk ml in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">数字</li><li id="2190" class="mk ml in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">确认</li><li id="4734" class="mk ml in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">目录</li><li id="e8df" class="mk ml in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">检验盒</li><li id="7f7c" class="mk ml in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">密码</li></ul><p id="07bd" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们已经看到了一些输入类型的问题，所以让我们看看我们可以对其他类型做些什么。</p><h1 id="1cc8" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">类型:数量</h1><p id="f4c0" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">下面是一个使用数字并将结果打印到控制台的问题示例。</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="b005" class="mf kz in mb b gy mg mh l mi mj">inquirer<br/>  .prompt([<br/>    {<br/>      name: "pet_count",<br/>      type: "number",<br/>      message: "How many pets do you own?",<br/>    },<br/>  ])<br/>  .then((answer) =&gt; {<br/>    console.log("You own", answer.pet_count, "pets");<br/>  });</span></pre><p id="6b56" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">它带有一些内置的验证，如果你试图输入一个不是数字的东西(比如“八”)，它会返回“NaN”。我们可以利用这一点，如果你没有给出一个数字，我们可以通过将问题转化为一个函数来建立一个条件，再次询问这个问题，如下所示:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7872" class="mf kz in mb b gy mg mh l mi mj">const getPetCount = () =&gt; {<br/>  inquirer<br/>    .prompt([<br/>      {<br/>        name: "pet_count",<br/>        type: "number",<br/>        message: "How many pets do you own?",<br/>      },<br/>    ])<br/>    .then((answer) =&gt; {<br/>      if (!answer.pet_count) {<br/>        console.log("That wasn't a number!");<br/>        getPetCount();<br/>      } else {<br/>        console.log("You own", answer.pet_count, "pets");<br/>    });<br/>};</span><span id="9417" class="mf kz in mb b gy nl mh l mi mj">getPetCount();</span></pre><p id="77df" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">我们所做的是将问题转化为一个可重用的函数，如果答案为假，则再次调用该问题。注意，由于问题函数不会立即被调用，我们需要实际调用声明它的函数下面的函数<strong class="ke io">。</strong></p><h1 id="f5d7" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">类型:确认</h1><p id="4949" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">Confirm为用户提供一个简单的是或否选项，并返回一个布尔值作为答案。以下代码是如何使用确认类型的示例:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="92d5" class="mf kz in mb b gy mg mh l mi mj">inquirer<br/>  .prompt([<br/>    {<br/>      name: "wants_pizza",<br/>      type: "confirm",<br/>      message: "Do you want a free pizza?",<br/>    },<br/>  ])<br/>  .then((answer) =&gt; {<br/>    console.log(answer.wants_pizza);<br/>  });</span></pre><p id="3a80" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">向用户提出问题:</p><p id="f62b" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><strong class="ke io">你想吃免费披萨吗？(是/否)</strong></p><p id="5efe" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">一个简单的Y或N会给你“真”或“假”。您可以使用它来构建一系列问题，所有问题都保存为函数，从而创建一个披萨订单生成器。你想吃披萨吗？<em class="my">你想要多少披萨？我们应该把披萨送到什么地址？</em>这是一系列使用确认、数字和输入问题类型的问题。但是比萨饼应该有什么样的外壳呢？</p><h1 id="dad0" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">类型:列表</h1><p id="8c4a" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">列表类型要求您向问题对象添加一个额外的键:选择数组。这将为用户提供一个选项列表，用户可以从中进行选择，并将他们的提交保存为问题的答案。这种类型完全阻止用户输入他们自己的输入，并将他们的选择限制在您预先定义的列表中。这里有一个例子:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="29ab" class="mf kz in mb b gy mg mh l mi mj">inquirer<br/>  .prompt([<br/>    {<br/>      name: "pizza_crust",<br/>      type: "list",<br/>      message: "Choose your crust:",<br/>      choices: ["Thin Crust", "Stuffed Crust", "Pan"],<br/>    },<br/>  ])<br/>  .then((answer) =&gt; {<br/>    console.log(answer.pizza_crust);<br/>  });</span></pre><p id="481e" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">用户将能够从列表中选择他们的外壳类型，他们的选择将被打印到控制台。如果我们坚持pizza order builder的想法，假设您在文档的开头定义了一个“order”对象，带有地址、皮、比萨饼数量等的键..你可以将这些答案中的值推送给那个对象，然后继续下一个问题。那么，如果我们想从一个列表中选择多个选项，比如比萨饼配料，该怎么办呢？</p><h1 id="e9d1" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">类型:复选框</h1><p id="8d7c" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">复选框的工作方式类似于列表，因为您必须提供一个选择数组，只是用户可以选择多个选项。这将是一个选择比萨饼配料的好方法。这里有一个例子:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="7c58" class="mf kz in mb b gy mg mh l mi mj">const toppingArray = ["Cheese", "Pepperoni", "Onions", "Peppers", "Jalapeños", "Chicken"]</span><span id="a80c" class="mf kz in mb b gy nl mh l mi mj">inquirer<br/>  .prompt([<br/>    {<br/>      name: "pizza_toppings",<br/>      type: "checkbox",<br/>      message: "Choose your toppings:",<br/>      choices: toppingArray,<br/>    },<br/>  ])<br/>  .then((answer) =&gt; {<br/>    console.log(answer.pizza_toppings);<br/>  });</span></pre><p id="d7b3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">将向用户提出问题“选择你的浇头:”然后给出一个选项列表，在这个例子中，我在变量中定义了这个列表。用户可以使用空格来选择/取消选择选项，并按enter来提交他们的答案。一旦回答完毕，答案将作为字符串保存在一个数组中。这个问题的答案可能是这样的:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="0e54" class="mf kz in mb b gy mg mh l mi mj">["Cheese", "Onions", "Peppers", "Chicken"]</span></pre><p id="7686" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">有趣的想法，您可以将这些答案保存到一个变量中，并在以后的另一个“列表”或“复选框”样式的问题中再次使用它们。</p><h1 id="aef1" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">类型:密码</h1><p id="b198" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">这个例子并不适合比萨饼订单生成器的例子，但是它是一个重要的例子。密码类型将完全隐藏用户输入。没有星号或空白字符，当你输入时，你将什么也看不到。这是非常有用的，因为任何人从你身后看都看不到你的密码有多长！这里有一个例子:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="1e66" class="mf kz in mb b gy mg mh l mi mj">inquirer<br/>  .prompt([<br/>    {<br/>      name: "user_password",<br/>      type: "password",<br/>      message: "Enter Password:",<br/>    },<br/>  ])<br/>  .then((answer) =&gt; {<br/>    console.log(answer.user_password);<br/>  });</span></pre><p id="81f0" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">显然，您不希望将您刚刚输入的敏感信息直接打印到控制台中，但是最初这样做是测试它是否有效的一个好方法。成品中更好的解决方案可能是将密码保存到一个变量中，或者立即将其与用户名一起提交，以便让某人登录服务。</p><h1 id="becc" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">想建一个披萨订单生成器？</h1><p id="06a6" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">太棒了。我已经创建了一个超级简单的例子，并上传到GitHub ，你可以随意克隆这个回购，看看一切是如何工作的！</p><h1 id="cfc0" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">那么inquirer还能做什么呢？</h1><p id="e0d1" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">我最喜欢Inquirer的一个特性，在我知道我可以把我所有的问题分成函数之前，就是‘when’。在比pizza order builder更复杂的场景中，您可能希望添加一个后续问题，只有当用户从上一个问题中选择了某个答案时，才会询问这个问题。这里有一个如何使用when的例子:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="ce9e" class="mf kz in mb b gy mg mh l mi mj">inquirer<br/>  .prompt([<br/>    {<br/>      name: "wants_pizza",<br/>      type: "confirm",<br/>      message: "Do you want a free pizza?",<br/>    },<br/>    {<br/>      name: "confirm_answer",<br/>      type: "confirm",<br/>      message: "Are you sure?",<br/>      when: (answers) =&gt; answers.wants_pizza === false,<br/>    },<br/>  ])<br/>  .then((answers) =&gt; {<br/>    if (answers.wants_pizza) {<br/>      console.log("The user wants free pizza");<br/>    } else if (answers.confirm_answer) {<br/>      // the user definitely doesn't want pizza<br/>    } else {<br/>      // the user changed their mind<br/>      // run the function to ask this question again<br/>    } <br/>  });</span></pre><p id="d378" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">所以我们可以看到‘when’属性实际上是在使用一个带有基本条件的回调函数。如果答案是假的，那么询问用户是否确定。在。then()块，我们用一个条件来看:</p><ul class=""><li id="df70" class="mk ml in ke b kf kg ki kj kl mm kp mn kt mo kx mp mq mr ms bi translated">如果第一个问题的答案是“真”，做点什么。</li><li id="83bf" class="mk ml in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">如果第一个答案是<strong class="ke io">不是</strong>真，如果第二个答案是真，用户肯定不想要比萨饼，在这里运行某种退出功能</li><li id="3aff" class="mk ml in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">否则用户说他们不想要比萨饼，然后改变了主意，所以他们应该被重定向到最初的问题</li></ul><p id="0b9a" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">值得注意的是，如果用户说他们确实想要一个免费的披萨，他们不会被问及是否确定——这就是“何时”的力量。<strong class="ke io">通过使用‘when ’,我们可以在满足给定标准时只问一个问题<em class="my">和</em>,否则跳过它。</strong></p><h1 id="ea6e" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">那么，我应该把我的询问分成几个功能，还是用‘when’？</h1><p id="466b" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">在我看来，两者都有其用例。将事物分解成函数对于制造可重用的问题来说是很棒的，但是这些问题的答案被限制在它们的。then()块，除非您将它们保存到该范围之外的变量中。在pizza order builder的例子中，这很好，因为每个问题都为一个对象贡献了一个值。</p><p id="f47f" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated"><em class="my">pizza order builder可以有两个功能——一个显示开始菜单，另一个包含所有后续问题，因为我们总是询问列表中的所有问题。</em></p><p id="81a3" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">使用‘when’特性的一个理由是，它可以节省代码行数，使你的文件更短；你不需要写一个完整的inquirer.prompt()块，然后有一个条件要么把你送到那个问题，要么送到下一个问题。另一个好处是，通过这种方式提问，你不会因为改变范围而丢失问题的答案。</p><h1 id="d6ad" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">默认值</h1><p id="88ca" class="pw-post-body-paragraph kc kd in ke b kf lq jo kh ki lr jr kk kl ls kn ko kp lt kr ks kt lu kv kw kx ig bi translated">Inquirer允许您将默认值添加到您的查询中，以加速导航并向用户提出建议。这里有一个如何使用它的例子:</p><pre class="lw lx ly lz gt ma mb mc md aw me bi"><span id="203f" class="mf kz in mb b gy mg mh l mi mj">const mediaArray = ["Facebook", "Wikipedia", "Medium"];</span><span id="2935" class="mf kz in mb b gy nl mh l mi mj">inquirer<br/>  .prompt([<br/>    {<br/>      name: "fav_media",<br/>      type: "list",<br/>      message: "What is your favorite source for info?",<br/>      choices: mediaArray,<br/>      default: "Medium",<br/>    },<br/>  ])<br/>  .then((answer) =&gt; {<br/>    console.log(answer.fav_media);<br/>  });</span></pre><p id="39a9" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">现在，当用户被问及他们最喜欢的信息源时，选择的选项将是第三个选项——“中”。</p><figure class="lw lx ly lz gt na gh gi paragraph-image"><div class="gh gi nm"><img src="../Images/7559e3f0a9a942738840f110f54bb5b8.png" data-original-src="https://miro.medium.com/v2/resize:fit:1064/format:webp/1*HzTKlXDIwR-mQ-pItc0IQA.png"/></div><figcaption class="nh ni gj gh gi nj nk bd b be z dk">How the inquiry begins when you use a ‘default’ option</figcaption></figure><p id="5bb6" class="pw-post-body-paragraph kc kd in ke b kf kg jo kh ki kj jr kk kl km kn ko kp kq kr ks kt ku kv kw kx ig bi translated">如果您试图在项目中实现CRUD功能，特别是更新部分，这将非常有用。您可以将现有值放入变量或函数参数中，并将其用作默认值。</p><h1 id="0b68" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">更多信息</h1><ul class=""><li id="f17f" class="mk ml in ke b kf lq ki lr kl nn kp no kt np kx mp mq mr ms bi translated">如果你想了解Inquirer.js更深入的特性，可以在这里查看npm <a class="ae lv" href="https://www.npmjs.com/package/inquirer" rel="noopener ugc nofollow" target="_blank">上的官方文档。</a></li></ul><h1 id="7e6c" class="ky kz in bd la lb lc ld le lf lg lh li jt lj ju lk jw ll jx lm jz ln ka lo lp bi translated">该表扬就表扬</h1><ul class=""><li id="19b2" class="mk ml in ke b kf lq ki lr kl nn kp no kt np kx mp mq mr ms bi translated">感谢<a class="nq nr ep" href="https://medium.com/u/b616c834b117?source=post_page-----c10a4e05ef1f--------------------------------" rel="noopener" target="_blank"> Squirrel </a>关于如何向中型文章添加代码块的文章。这东西看上去一片<strong class="ke io"> <em class="my">乱</em> </strong>我才发现那条。</li><li id="e267" class="mk ml in ke b kf mt ki mu kl mv kp mw kt mx kx mp mq mr ms bi translated">感谢托马斯·w·史密斯首先教会我这一切(以及更多),并校对了这篇文章。</li></ul></div></div>    
</body>
</html>