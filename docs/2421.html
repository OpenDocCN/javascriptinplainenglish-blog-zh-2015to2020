<html>
<head>
<title>setImmediate() vs process.nextTick() in Node.Js</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">setImmediate() vs节点中的process.nextTick()。射流研究…</h1>
<blockquote>原文：<a href="https://javascript.plainenglish.io/setimmediate-vs-process-nexttick-in-nodejs-6fbfbebd60a3?source=collection_archive---------5-----------------------#2020-06-22">https://javascript.plainenglish.io/setimmediate-vs-process-nexttick-in-nodejs-6fbfbebd60a3?source=collection_archive---------5-----------------------#2020-06-22</a></blockquote><div><div class="fc ie if ig ih ii"/><div class="ij ik il im in"><div class=""/><div class=""><h2 id="9dc9" class="pw-subtitle-paragraph jn ip iq bd b jo jp jq jr js jt ju jv jw jx jy jz ka kb kc kd ke dk translated">理解setImmediate()和process.nextTick的区别以及何时使用what</h2></div><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div role="button" tabindex="0" class="kl km di kn bf ko"><div class="gh gi kf"><img src="../Images/35a87a9ef9a95c17d08bdefe013259b7.png" data-original-src="https://miro.medium.com/v2/resize:fit:1400/format:webp/1*9euVpKPj5nzBgiXExZpoOw.png"/></div></div><figcaption class="kr ks gj gh gi kt ku bd b be z dk">Image created using <a class="ae kv" href="http://carbon.now.sh/" rel="noopener ugc nofollow" target="_blank">Carbon</a></figcaption></figure><p id="0a6e" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">NodeJs以其非阻塞、事件驱动的架构而闻名。在node中处理异步任务比其他任何服务器编程语言都要容易得多。Node提供了几个处理异步任务的内置函数。</p><h1 id="4403" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">异步性</h1><p id="9316" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">为了实现异步，节点使用事件循环。事件循环是一个单线程半无限循环，它使用一个事件队列对所有io和/或定时器回调进行排队，并按顺序逐个执行它们。事件队列不是单个队列，而是队列和堆的集合。</p><figure class="kg kh ki kj gt kk gh gi paragraph-image"><div class="gh gi mp"><img src="../Images/452f98a8a610dcd88d0cd1507fc08ce2.png" data-original-src="https://miro.medium.com/v2/resize:fit:1044/format:webp/0*8Ggilhij-jpU3Y2y.png"/></div></figure><p id="dd72" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上图显示了事件循环的执行顺序。每个方框将被称为事件循环的一个阶段。</p><h1 id="8a4b" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">事件循环的阶段</h1><p id="8452" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">事件循环由以下阶段组成。</p><ul class=""><li id="8716" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr mv mw mx my bi translated"><strong class="ky ir">定时器</strong> —在此阶段，使用<code class="fe mz na nb nc b">setTimeout</code>添加的过期定时器回调或使用<code class="fe mz na nb nc b">setInterval</code>添加的间隔功能被执行。</li><li id="ead2" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">待定回调</strong> —执行延迟到下一次循环迭代的I/O回调。</li><li id="daa2" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">空闲处理程序</strong> —执行一些libuv内部的东西，内部使用。</li><li id="4016" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">准备处理程序</strong> —在轮询I/O之前执行一些准备工作，供内部使用。</li><li id="3f46" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir"> I/O轮询</strong> —检索新的I/O事件；执行与I/O相关的回调。</li><li id="2c26" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">检查处理程序</strong>——<code class="fe mz na nb nc b">setImmediate()</code>这里调用回调。</li><li id="0960" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr mv mw mx my bi translated"><strong class="ky ir">关闭回调</strong> —执行关闭处理程序</li></ul><p id="c484" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在本文中，我们将只讨论事件循环的<strong class="ky ir">检查处理程序</strong>阶段。如果你想详细了解事件循环，查看Deepal的<a class="ae kv" href="https://blog.insiderattack.net/event-loop-and-the-big-picture-nodejs-event-loop-part-1-1cb67a182810" rel="noopener ugc nofollow" target="_blank">事件循环系列</a>和官方nodejs文档<a class="ae kv" href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/" rel="noopener ugc nofollow" target="_blank">这里</a>。</p><p id="20a1" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">setImmediate()</code>和<code class="fe mz na nb nc b">process.nextTick()</code>是两个允许我们在事件循环中控制代码执行顺序的函数。这两个函数都在事件队列中调度我们的回调处理程序。但是它们是在事件循环的不同阶段执行的。</p><h1 id="7b33" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">setImmediate()</h1><p id="8094" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mz na nb nc b">setImmediate(callback[, ...args])</code>获取一个<code class="fe mz na nb nc b">callback</code>并将其添加到事件队列(特别是立即队列)。</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="7bbe" class="nm lt iq nc b gy nn no l np nq">setImmediate(() =&gt; console.log('Queued using setImmediate'))</span></pre><p id="3db6" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mz na nb nc b">setImmediate()</code>调度的回调将在事件循环的<strong class="ky ir">检查处理程序</strong>阶段执行。</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="0fdc" class="nm lt iq nc b gy nn no l np nq">console.log('Start')</span><span id="3444" class="nm lt iq nc b gy nr no l np nq">setImmediate(() =&gt; console.log('Queued using setImmediate'))</span><span id="5bdc" class="nm lt iq nc b gy nr no l np nq">console.log('End')</span></pre><p id="3967" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述脚本的输出将是</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="3081" class="nm lt iq nc b gy nn no l np nq">Start <br/>End <br/>Queued using setImmediate</span></pre><p id="9b17" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">因为事件循环只有在调用堆栈为空时才开始处理，所以事件队列中排队的回调将在脚本运行完成后处理。</p><h1 id="2072" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">process.nextTick()</h1><p id="8e0f" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mz na nb nc b">process.nextTick(callback[, ...args])</code>也会像<code class="fe mz na nb nc b">setImmediate()</code>函数一样带一个<code class="fe mz na nb nc b">callback</code>和可选的<code class="fe mz na nb nc b">args</code>参数。但是回调在“下一个节拍队列”中排队，而不是“立即队列”。</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="1e41" class="nm lt iq nc b gy nn no l np nq">process.nextTick(() =&gt; console.log('Queued using process.nextTick'))</span></pre><p id="8070" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mz na nb nc b">process.nextTick()</code>安排的回调将在当前阶段执行后处理。也就是说，在事件循环的每个阶段之间处理下一个节拍队列。此外，一旦脚本运行完成，在事件循环开始之前，将处理下一个节拍队列。</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="974d" class="nm lt iq nc b gy nn no l np nq">console.log('Start')</span><span id="98c6" class="nm lt iq nc b gy nr no l np nq">process.nextTick(() =&gt; console.log('Queued using process.nextTick'))</span><span id="1772" class="nm lt iq nc b gy nr no l np nq">console.log('End')</span></pre><p id="85da" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">上述脚本的输出将是</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="a7bd" class="nm lt iq nc b gy nn no l np nq">Start <br/>End <br/>Queued using process.nextTick</span></pre><h1 id="a148" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">set immediate()vs process . next tick()</h1><p id="9f56" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">现在我们来看看<code class="fe mz na nb nc b">setImmediate()</code>和<code class="fe mz na nb nc b">process.nextTick()</code>的区别以及什么时候用哪个。</p><ol class=""><li id="87bf" class="mq mr iq ky b kz la lc ld lf ms lj mt ln mu lr ns mw mx my bi translated"><code class="fe mz na nb nc b">setTimeout()</code>在<strong class="ky ir">检查处理程序</strong>阶段处理，<code class="fe mz na nb nc b">process.nextTick()</code>在事件循环和事件循环各阶段之间的<strong class="ky ir">开始时处理。</strong></li><li id="f92b" class="mq mr iq ky b kz nd lc ne lf nf lj ng ln nh lr ns mw mx my bi translated">在任何给定的上下文中，<code class="fe mz na nb nc b">process.nextTick()</code>的优先级高于<code class="fe mz na nb nc b">setImmediate()</code>。</li></ol><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="461e" class="nm lt iq nc b gy nn no l np nq">setImmediate(() =&gt; console.log('I run immediately'))</span><span id="19fe" class="nm lt iq nc b gy nr no l np nq">process.nextTick(() =&gt; console.log('But I run before that'))</span></pre><p id="f6cc" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="67af" class="nm lt iq nc b gy nn no l np nq">But I run before that <br/>I run immediately</span></pre><p id="54ab" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">3.如果在给定阶段调用了<code class="fe mz na nb nc b">process.nextTick()</code>，那么传递给<code class="fe mz na nb nc b">process.nextTick()</code>的所有回调都将在事件循环继续之前得到解决。如果<code class="fe mz na nb nc b">process.nextTick()</code>被递归调用，这将阻塞事件循环并产生<strong class="ky ir"> I/O饥饿</strong>。</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="4140" class="nm lt iq nc b gy nn no l np nq">let count = 0</span><span id="d0b2" class="nm lt iq nc b gy nr no l np nq">const cb = () =&gt; {<br/>    console.log(`Processing nextTick cb ${++count}`)<br/>    process.nextTick(cb)<br/>}</span><span id="7ae5" class="nm lt iq nc b gy nr no l np nq">setImmediate(() =&gt; console.log('setImmediate is called'))<br/>setTimeout(() =&gt; console.log('setTimeout executed'), 100)</span><span id="6b60" class="nm lt iq nc b gy nr no l np nq">process.nextTick(cb)</span><span id="3829" class="nm lt iq nc b gy nr no l np nq">console.log('Start')</span></pre><p id="183f" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="5b66" class="nm lt iq nc b gy nn no l np nq">Start<br/>Processing nextTick cb 1<br/>Processing nextTick cb 2<br/>Processing nextTick cb 3<br/>Processing nextTick cb 4<br/>Processing nextTick cb 5<br/>Processing nextTick cb 6<br/>Processing nextTick cb 7<br/>Processing nextTick cb 8<br/>Processing nextTick cb 9<br/>Processing nextTick cb 10<br/>...</span></pre><p id="631b" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">如您所见，对<code class="fe mz na nb nc b">process.nextTick()</code>的递归调用被连续处理，I/O被耗尽。所以<code class="fe mz na nb nc b">setImmediate()</code>和<code class="fe mz na nb nc b">setTimeout()</code>回调不会被执行。</p><p id="4113" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">4.与<code class="fe mz na nb nc b">process.nextTick()</code>不同，对<code class="fe mz na nb nc b">setImmediate()</code>的递归调用不会阻塞事件循环，因为每次递归调用只在下一次事件循环迭代时执行。</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="4e0d" class="nm lt iq nc b gy nn no l np nq">let count = 0</span><span id="d494" class="nm lt iq nc b gy nr no l np nq">const cb = () =&gt; {<br/>    console.log(`Processing setImmediate cb ${++count}`)<br/>    setImmediate(cb)<br/>}</span><span id="0aaa" class="nm lt iq nc b gy nr no l np nq">setImmediate(cb)<br/>setTimeout(() =&gt; console.log('setTimeout executed'), 100)</span><span id="09bf" class="nm lt iq nc b gy nr no l np nq">console.log('Start')</span></pre><p id="7ceb" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">输出:</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="251c" class="nm lt iq nc b gy nn no l np nq">Start<br/>Processing setImmediate cb 1<br/>Processing setImmediate cb 2<br/>Processing setImmediate cb 3<br/>Processing setImmediate cb 4<br/>...<br/>Processing setImmediate cb 503<br/>Processing setImmediate cb 504<br/>setTimeout executed<br/>Processing setImmediate cb 505<br/>Processing setImmediate cb 506<br/>...</span></pre><p id="80b5" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">在这里，即使<code class="fe mz na nb nc b">setImmediate()</code>被递归调用，它也不会阻塞事件循环，并且在指定的超时之后执行<code class="fe mz na nb nc b">setTimeout()</code>回调。</p><h1 id="bb24" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">用例</h1><p id="e1d6" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated">作为官方文件，总是使用<code class="fe mz na nb nc b">setImmediate()</code>。</p><blockquote class="nt"><p id="6532" class="nu nv iq bd nw nx ny nz oa ob oc lr dk translated">我们建议开发人员在所有情况下都使用setImmediate()，因为它更容易推理。</p></blockquote><p id="4e98" class="pw-post-body-paragraph kw kx iq ky b kz od jr lb lc oe ju le lf of lh li lj og ll lm ln oh lp lq lr ij bi translated">那么什么时候用<code class="fe mz na nb nc b">process.nextTick()</code>？</p><p id="c3f9" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">考虑下面的代码片段。</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="16d1" class="nm lt iq nc b gy nn no l np nq">function readFile(fileName, callback) {</span><span id="31db" class="nm lt iq nc b gy nr no l np nq">    if (typeof fileName !== 'string') {<br/>        return callback(new TypeError('file name should be string'))<br/>    }</span><span id="47ea" class="nm lt iq nc b gy nr no l np nq">    fs.readFile(fileName, (err, data) =&gt; {<br/>        if (err) return callback(err)</span><span id="9a9c" class="nm lt iq nc b gy nr no l np nq">        return callback(null, data)<br/>    })<br/>}</span></pre><p id="1374" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这段代码的问题是<code class="fe mz na nb nc b">readFile()</code>可以根据输入参数同步或异步。这可能会导致不可预测的结果。</p><p id="d210" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">那么如何才能做到100%异步呢？<code class="fe mz na nb nc b">process.nextTick()</code>这里可以帮到我们。</p><p id="0a33" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">使用<code class="fe mz na nb nc b">process.nextTick()</code>我们可以像这样重写函数。</p><pre class="kg kh ki kj gt ni nc nj nk aw nl bi"><span id="b215" class="nm lt iq nc b gy nn no l np nq">function readFile(fileName, callback) {</span><span id="0b37" class="nm lt iq nc b gy nr no l np nq">    if (typeof fileName !== 'string') {<br/>        return process.nextTick(<br/>            callback, <br/>            new TypeError('file name should be string')<br/>        )<br/>    }</span><span id="1f61" class="nm lt iq nc b gy nr no l np nq">    fs.readFile(fileName, (err, data) =&gt; {<br/>        if (err) return callback(err)</span><span id="d0e7" class="nm lt iq nc b gy nr no l np nq">        return callback(null, data)<br/>    })<br/>}</span></pre><p id="2d59" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">现在这个函数是完全异步的。现在，如果文件名不是字符串，它将抛出一个错误，只是在运行脚本完成之后，事件循环开始之前。</p><p id="cadd" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><code class="fe mz na nb nc b">process.nextTick()</code>在脚本运行完成后必须立即执行回调的其他情况下也很有用。</p><h1 id="e42a" class="ls lt iq bd lu lv lw lx ly lz ma mb mc jw md jx me jz mf ka mg kc mh kd mi mj bi translated">结论</h1><p id="cd11" class="pw-post-body-paragraph kw kx iq ky b kz mk jr lb lc ml ju le lf mm lh li lj mn ll lm ln mo lp lq lr ij bi translated"><code class="fe mz na nb nc b">process.nextTick()</code>和<code class="fe mz na nb nc b">setImmediate()</code>允许用户在事件循环中安排回调。<code class="fe mz na nb nc b">process.nextTick()</code>在事件循环的每个阶段后处理，而<code class="fe mz na nb nc b">setImmediate()</code>仅在事件循环的检查处理程序阶段处理。</p><p id="158c" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated">这两个函数的名称令人困惑。<code class="fe mz na nb nc b">process.nextTick()</code>在同一阶段立即触发，而<code class="fe mz na nb nc b">setImmediate()</code>在事件循环的下一次迭代或“滴答”时触发。</p></div><div class="ab cl oi oj hu ok" role="separator"><span class="ol bw bk om on oo"/><span class="ol bw bk om on oo"/><span class="ol bw bk om on"/></div><div class="ij ik il im in"><p id="f888" class="pw-post-body-paragraph kw kx iq ky b kz la jr lb lc ld ju le lf lg lh li lj lk ll lm ln lo lp lq lr ij bi translated"><em class="op">原载于</em><a class="ae kv" href="https://jinoantony.com/blog/setimmediate-vs-process-nexttick-in-nodejs" rel="noopener ugc nofollow" target="_blank"><em class="op">https://jinoantony.com</em></a><em class="op">。</em></p></div></div>    
</body>
</html>